//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import { AquaRestBaseClass } from "./AquaRestBaseClass";

export class AgentClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Create agent
     * @param apiAgentCreateOperation The data required to execute agent - create operation.
     * @return Information on the created agent
     */
    createAgent(apiAgentCreateOperation: ApiAgentCreateOperation): Promise<ApiAgentBase> {
        let url_ = this.baseUrl + "/api/Agent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiAgentCreateOperation);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateAgent(_response);
        });
    }

    protected processCreateAgent(response: Response): Promise<ApiAgentBase> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAgentBase;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAgentBase>(null as any);
    }

    /**
     * Update agent
     * @param agentId The id of the agent.
     * @param operation Request containing the modify information for the agent.
     */
    update(agentId: number, operation: ApiAgentPatchOperation): Promise<void> {
        let url_ = this.baseUrl + "/api/Agent/{agentId}";
        if (agentId === undefined || agentId === null)
            throw new Error("The parameter 'agentId' must be defined.");
        url_ = url_.replace("{agentId}", encodeURIComponent("" + agentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(operation);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete agent
     * @param agentId Id of an agent to be deleted.
     */
    deleteAgent(agentId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Agent/{agentId}";
        if (agentId === undefined || agentId === null)
            throw new Error("The parameter 'agentId' must be defined.");
        url_ = url_.replace("{agentId}", encodeURIComponent("" + agentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteAgent(_response);
        });
    }

    protected processDeleteAgent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get currently executing task
     * @param agentId The id of the agent
     * @return The currently executed task
     */
    getCurrentlyExecutingTask(agentId: number): Promise<ApiCurrentlyExecutedStepInfo> {
        let url_ = this.baseUrl + "/api/Agent/{agentId}/CurrentlyExecuting";
        if (agentId === undefined || agentId === null)
            throw new Error("The parameter 'agentId' must be defined.");
        url_ = url_.replace("{agentId}", encodeURIComponent("" + agentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCurrentlyExecutingTask(_response);
        });
    }

    protected processGetCurrentlyExecutingTask(response: Response): Promise<ApiCurrentlyExecutedStepInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiCurrentlyExecutedStepInfo;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiCurrentlyExecutedStepInfo>(null as any);
    }
}

export class AgileClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get items
     * @param request Item list request parameters
     * @return A list of items matching the given criteria.
     */
    itemListMultipleTypes(request: ApiItemListRequest): Promise<ApiItemListResult> {
        let url_ = this.baseUrl + "/api/Agile/ItemList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processItemListMultipleTypes(_response);
        });
    }

    protected processItemListMultipleTypes(response: Response): Promise<ApiItemListResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemListResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemListResult>(null as any);
    }

    /**
     * Reorder agile backlog items
     * @param request Reorder request data
     */
    reorderItems(request: ApiAgileReorderItemsRequest): Promise<ApiAgileReorderItemsResponse> {
        let url_ = this.baseUrl + "/api/Agile/ReorderItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReorderItems(_response);
        });
    }

    protected processReorderItems(response: Response): Promise<ApiAgileReorderItemsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAgileReorderItemsResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAgileReorderItemsResponse>(null as any);
    }

    /**
     * Get Agile settings
     * @param projectId Project ID
     */
    getSettings(projectId: number): Promise<ApiAgileSettings> {
        let url_ = this.baseUrl + "/api/Agile/Settings/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSettings(_response);
        });
    }

    protected processGetSettings(response: Response): Promise<ApiAgileSettings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAgileSettings;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAgileSettings>(null as any);
    }

    /**
     * Update Agile settings
     * @param projectId Project ID
     * @param agileSettings Updated Agile settings
     */
    updateSettings(projectId: number, agileSettings: ApiAgileSettings): Promise<void> {
        let url_ = this.baseUrl + "/api/Agile/Settings/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(agileSettings);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateSettings(_response);
        });
    }

    protected processUpdateSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create sprint
     * @param newItem The data for the new sprint which should be created.
     * @return Id of the created sprint
     */
    createSprint(newItem: ApiSprintNew): Promise<ApiSprintNewResponse> {
        let url_ = this.baseUrl + "/api/Agile/Sprint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newItem);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateSprint(_response);
        });
    }

    protected processCreateSprint(response: Response): Promise<ApiSprintNewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiSprintNewResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSprintNewResponse>(null as any);
    }

    /**
     * Get sprint
     * @param id The id of the sprint as integer
     * @param includeStatistics (optional) Flag that indicates if statistics are included or not, default false.
     * @return The requested sprint
     */
    getSprint(id: number, includeStatistics?: boolean | undefined): Promise<ApiSprint> {
        let url_ = this.baseUrl + "/api/Agile/Sprint/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includeStatistics === null)
            throw new Error("The parameter 'includeStatistics' cannot be null.");
        else if (includeStatistics !== undefined)
            url_ += "includeStatistics=" + encodeURIComponent("" + includeStatistics) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSprint(_response);
        });
    }

    protected processGetSprint(response: Response): Promise<ApiSprint> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiSprint;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSprint>(null as any);
    }

    /**
     * Update sprint
     * @param id The id of the sprint as integer
     * @param update This object contains the changes which should be performed
     */
    updateSprint(id: number, update: ApiSprintUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/Agile/Sprint/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateSprint(_response);
        });
    }

    protected processUpdateSprint(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete sprint
     * @param id The id of the sprint as integer
     */
    deleteSprint(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Agile/Sprint/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteSprint(_response);
        });
    }

    protected processDeleteSprint(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BatchOperationClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Modify generic collection
     * @param patchRequest Operation details.
     * @return Guid of the batch operation. 
    Status of the the operation can be retrieved using GET api/System/LongOperation/{guid}/Status or GET api/System/LongOperation/{guid}.
    In case of this batch operation the data retrieved from 'GET api/System/LongOperation/{guid}' contains additional information 
    as defined in ApiItemLongOperationInfo (FailedItems).
    Additionally, you SignalR (group "LongOperation_{customerId}_{guid}") can be used to receive information when operation finishes.
     */
    modifyItems(patchRequest: ApiItemsPatchRequest): Promise<ApiLongOperationOfBoolean> {
        let url_ = this.baseUrl + "/api/Batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patchRequest);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyItems(_response);
        });
    }

    protected processModifyItems(response: Response): Promise<ApiLongOperationOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperationOfBoolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperationOfBoolean>(null as any);
    }

    /**
     * Get allowed values
     * @param apiBatchAllowedValuesRequest Request details
     * @return Allowed values than can be used when batch-updating given items
     */
    getPossibleValues(apiBatchAllowedValuesRequest: ApiBatchAllowedValuesRequest): Promise<ApiBatchAllowedValuesResponse> {
        let url_ = this.baseUrl + "/api/Batch/AllowedValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiBatchAllowedValuesRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPossibleValues(_response);
        });
    }

    protected processGetPossibleValues(response: Response): Promise<ApiBatchAllowedValuesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBatchAllowedValuesResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiBatchAllowedValuesResponse>(null as any);
    }
}

export class ConfigClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get default config elemets
     * @param dataPath Path of the config element e.g. edit-template.defaults.defect.
     * @param projectId (optional) The id of the project. Can be null what means looking up for non-project related config elements only.
     * @param includeData (optional) If true then returned elements contain data as well (Content field).
     * @return Matching config element or null if nothing found.
     */
    lookupConfigDefault(dataPath: string | null, projectId?: number | null | undefined, includeData?: boolean | undefined): Promise<ApiConfigElement> {
        let url_ = this.baseUrl + "/api/ConfigData/Default?";
        if (dataPath === undefined)
            throw new Error("The parameter 'dataPath' must be defined.");
        else if(dataPath !== null)
            url_ += "dataPath=" + encodeURIComponent("" + dataPath) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (includeData === null)
            throw new Error("The parameter 'includeData' cannot be null.");
        else if (includeData !== undefined)
            url_ += "includeData=" + encodeURIComponent("" + includeData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLookupConfigDefault(_response);
        });
    }

    protected processLookupConfigDefault(response: Response): Promise<ApiConfigElement> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiConfigElement;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiConfigElement>(null as any);
    }

    /**
     * Replace default config elements
     * @param config Details of config element to be saved.
     * @return The saved config element.
     */
    saveOrUpdateConfigDefault(config: ApiConfigElementSave): Promise<ApiConfigElement> {
        let url_ = this.baseUrl + "/api/ConfigData/Default";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(config);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveOrUpdateConfigDefault(_response);
        });
    }

    protected processSaveOrUpdateConfigDefault(response: Response): Promise<ApiConfigElement> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiConfigElement;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiConfigElement>(null as any);
    }

    /**
     * Modify default config elements
     * @param patchOperation Details of the patch operation.
     */
    modifyConfigDefault(patchOperation: ApiConfigElementPatchOperation): Promise<void> {
        let url_ = this.baseUrl + "/api/ConfigData/Default";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patchOperation);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyConfigDefault(_response);
        });
    }

    protected processModifyConfigDefault(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete my config element entry
     * @param id The id of the configuration element entry.
     */
    deleteConfigUser(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ConfigData/Entry/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteConfigUser(_response);
        });
    }

    protected processDeleteConfigUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get unified config elements
     * @param dataPath Path of the config element e.g. edit-template.defaults.defect.
     * @param projectId (optional) The id of the project. Can be null what means looking up for non-project related config elements only.
     * @param includeData (optional) If true then returned elements contain data as well (Content field).
     * @return The list of matching config elements
     */
    lookupConfigUnified(dataPath: string | null, projectId?: number | null | undefined, includeData?: boolean | undefined): Promise<ApiConfigElement[]> {
        let url_ = this.baseUrl + "/api/ConfigData/Unified?";
        if (dataPath === undefined)
            throw new Error("The parameter 'dataPath' must be defined.");
        else if(dataPath !== null)
            url_ += "dataPath=" + encodeURIComponent("" + dataPath) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (includeData === null)
            throw new Error("The parameter 'includeData' cannot be null.");
        else if (includeData !== undefined)
            url_ += "includeData=" + encodeURIComponent("" + includeData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLookupConfigUnified(_response);
        });
    }

    protected processLookupConfigUnified(response: Response): Promise<ApiConfigElement[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiConfigElement[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiConfigElement[]>(null as any);
    }

    /**
     * Get my config elements
     * @param dataPath Path of the config element e.g. edit-template.defaults.defect.
     * @param projectId (optional) The id of the project. Can be null what means looking up for non-project related config elements only.
     * @param includeData (optional) If true then returned elements contain data as well (Content field).
     * @return Matching config element or null if nothing found.
     */
    lookupConfigUser(dataPath: string | null, projectId?: number | null | undefined, includeData?: boolean | undefined): Promise<ApiConfigElement> {
        let url_ = this.baseUrl + "/api/ConfigData/User?";
        if (dataPath === undefined)
            throw new Error("The parameter 'dataPath' must be defined.");
        else if(dataPath !== null)
            url_ += "dataPath=" + encodeURIComponent("" + dataPath) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (includeData === null)
            throw new Error("The parameter 'includeData' cannot be null.");
        else if (includeData !== undefined)
            url_ += "includeData=" + encodeURIComponent("" + includeData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLookupConfigUser(_response);
        });
    }

    protected processLookupConfigUser(response: Response): Promise<ApiConfigElement> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiConfigElement;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiConfigElement>(null as any);
    }

    /**
     * Replace my config elements
     * @param config Details of config element to be saved.
     * @return The saved config element.
     */
    saveOrUpdateConfigUser(config: ApiConfigElementSave): Promise<ApiConfigElement> {
        let url_ = this.baseUrl + "/api/ConfigData/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(config);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveOrUpdateConfigUser(_response);
        });
    }

    protected processSaveOrUpdateConfigUser(response: Response): Promise<ApiConfigElement> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiConfigElement;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiConfigElement>(null as any);
    }

    /**
     * Modify my config elements
     * @param patchOperation Details of the patch operation.
     */
    modifyConfigUser(patchOperation: ApiConfigElementPatchOperation): Promise<void> {
        let url_ = this.baseUrl + "/api/ConfigData/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patchOperation);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyConfigUser(_response);
        });
    }

    protected processModifyConfigUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DashboardNGClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get my dashboards
     * @return All dashboards available for current user
     */
    getDashboardsForUser(): Promise<ApiDashboardNG[]> {
        let url_ = this.baseUrl + "/api/DashboardNG";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDashboardsForUser(_response);
        });
    }

    protected processGetDashboardsForUser(response: Response): Promise<ApiDashboardNG[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiDashboardNG[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiDashboardNG[]>(null as any);
    }

    /**
     * Create dashboard.
     * @param dashboard Dashboard to be saved
     * @return Saved dashboard data (contains valid Id)
     */
    createDashboard(dashboard: ApiDashboardNG): Promise<ApiDashboardNG> {
        let url_ = this.baseUrl + "/api/DashboardNG";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dashboard);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateDashboard(_response);
        });
    }

    protected processCreateDashboard(response: Response): Promise<ApiDashboardNG> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiDashboardNG;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiDashboardNG>(null as any);
    }

    /**
     * Get dashboard
     * @param dashboardId Id of the dashboard to retrieve
     * @param includeWidgets (optional) If true then widgets collection will be returned. If false, then widgets collection will be null.
     * @param includeShares (optional) If true then shares collection will be returned. If false, then shares collection will be null.
     * @param includeData (optional) If true then actual data in widgets collection will be includes as well (implies includeWidgets).
     * @return Dashboard data
     */
    getDashboard(dashboardId: number, includeWidgets?: boolean | undefined, includeShares?: boolean | undefined, includeData?: boolean | undefined): Promise<ApiDashboardNG> {
        let url_ = this.baseUrl + "/api/DashboardNG/{dashboardId}?";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        if (includeWidgets === null)
            throw new Error("The parameter 'includeWidgets' cannot be null.");
        else if (includeWidgets !== undefined)
            url_ += "includeWidgets=" + encodeURIComponent("" + includeWidgets) + "&";
        if (includeShares === null)
            throw new Error("The parameter 'includeShares' cannot be null.");
        else if (includeShares !== undefined)
            url_ += "includeShares=" + encodeURIComponent("" + includeShares) + "&";
        if (includeData === null)
            throw new Error("The parameter 'includeData' cannot be null.");
        else if (includeData !== undefined)
            url_ += "includeData=" + encodeURIComponent("" + includeData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDashboard(_response);
        });
    }

    protected processGetDashboard(response: Response): Promise<ApiDashboardNG> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiDashboardNG;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiDashboardNG>(null as any);
    }

    /**
     * Update dashboard
     * @param dashboardId If of the dashboard to be updated
     * @param dashboard Dashboard data to be updated
     * @return Updated dashboard data
     */
    updateDashboard(dashboardId: number, dashboard: ApiDashboardNG): Promise<ApiDashboardNG> {
        let url_ = this.baseUrl + "/api/DashboardNG/{dashboardId}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dashboard);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateDashboard(_response);
        });
    }

    protected processUpdateDashboard(response: Response): Promise<ApiDashboardNG> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiDashboardNG;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiDashboardNG>(null as any);
    }

    /**
     * Delete dashboard
     * @param dashboardId The id of the dashboard
     */
    deleteDashboard(dashboardId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/DashboardNG/{dashboardId}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteDashboard(_response);
        });
    }

    protected processDeleteDashboard(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Add favourite
     * @param dashboardId The id of the dashboard to add to favourites.
     */
    markDashboardFavourite(dashboardId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/DashboardNG/{dashboardId}/Favourite";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMarkDashboardFavourite(_response);
        });
    }

    protected processMarkDashboardFavourite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove favourite
     * @param dashboardId The id of the dashboard to remove from favourites.
     */
    unMarkDashboardFavourite(dashboardId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/DashboardNG/{dashboardId}/Favourite";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUnMarkDashboardFavourite(_response);
        });
    }

    protected processUnMarkDashboardFavourite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create widget
     * @param dashboardId The id of the dashboard where to add the widget
     * @param widget Widget data
     */
    addWidgetInDashboard(dashboardId: number, widget: ApiDashboardNGWidget): Promise<ApiDashboardNGWidget> {
        let url_ = this.baseUrl + "/api/DashboardNG/{dashboardId}/Widget";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(widget);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddWidgetInDashboard(_response);
        });
    }

    protected processAddWidgetInDashboard(response: Response): Promise<ApiDashboardNGWidget> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiDashboardNGWidget;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiDashboardNGWidget>(null as any);
    }

    /**
     * Reorder widgets
     * @param dashboardId The id of the dashboard
     * @param apiReorderWidgets List of widgetIds with new positions
     */
    reorderWidgets(dashboardId: number, apiReorderWidgets: ApiDashboardNGReorderWidgets[]): Promise<void> {
        let url_ = this.baseUrl + "/api/DashboardNG/{dashboardId}/Widget";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiReorderWidgets);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReorderWidgets(_response);
        });
    }

    protected processReorderWidgets(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update dashboard
     * @param dashboardId The id of the dashboard
     * @param widgetId The id of the widget
     * @param widget New widget data
     * @return The updated widget
     */
    updateWidget(dashboardId: number, widgetId: number, widget: ApiDashboardNGWidget): Promise<ApiDashboardNGWidget> {
        let url_ = this.baseUrl + "/api/DashboardNG/{dashboardId}/Widget/{widgetId}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        if (widgetId === undefined || widgetId === null)
            throw new Error("The parameter 'widgetId' must be defined.");
        url_ = url_.replace("{widgetId}", encodeURIComponent("" + widgetId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(widget);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateWidget(_response);
        });
    }

    protected processUpdateWidget(response: Response): Promise<ApiDashboardNGWidget> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiDashboardNGWidget;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiDashboardNGWidget>(null as any);
    }

    /**
     * Delete widget
     * @param dashboardId The id of the dashboard
     * @param widgetId The id of the widget
     */
    deleteWidget(dashboardId: number, widgetId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/DashboardNG/{dashboardId}/Widget/{widgetId}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        if (widgetId === undefined || widgetId === null)
            throw new Error("The parameter 'widgetId' must be defined.");
        url_ = url_.replace("{widgetId}", encodeURIComponent("" + widgetId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteWidget(_response);
        });
    }

    protected processDeleteWidget(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get widget
     * @param dashboardId The id of the dashboard
     * @param widgetId The id of the widget
     */
    getWidgetData(dashboardId: number, widgetId: number): Promise<ApiWidgetData> {
        let url_ = this.baseUrl + "/api/DashboardNG/{dashboardId}/Widget/{widgetId}/Data";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        if (widgetId === undefined || widgetId === null)
            throw new Error("The parameter 'widgetId' must be defined.");
        url_ = url_.replace("{widgetId}", encodeURIComponent("" + widgetId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetWidgetData(_response);
        });
    }

    protected processGetWidgetData(response: Response): Promise<ApiWidgetData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiWidgetData;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiWidgetData>(null as any);
    }

    /**
     * Create widget preview
     * @param dashboardId The id of the dashboard
     * @param widgetId The id of the widget
     * @param widget Widget data (including data specification)
     */
    getWidgetPreview(dashboardId: number, widgetId: number, widget: ApiDashboardNGWidget): Promise<ApiWidgetData> {
        let url_ = this.baseUrl + "/api/DashboardNG/{dashboardId}/Widget/{widgetId}/Preview";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        if (widgetId === undefined || widgetId === null)
            throw new Error("The parameter 'widgetId' must be defined.");
        url_ = url_.replace("{widgetId}", encodeURIComponent("" + widgetId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(widget);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetWidgetPreview(_response);
        });
    }

    protected processGetWidgetPreview(response: Response): Promise<ApiWidgetData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiWidgetData;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiWidgetData>(null as any);
    }
}

export class DefectClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Create defect
     * @param newItem The data for the new defect which should be created.
     * @param applyDefaultValues (optional) Indicates whether default values should be applied for fields which are not included in the request.
     * @return Basic information on the new defect.
     */
    create(newItem: ApiItemNewWithEnclosures, applyDefaultValues?: boolean | undefined): Promise<ApiItemInfo> {
        let url_ = this.baseUrl + "/api/Defect?";
        if (applyDefaultValues === null)
            throw new Error("The parameter 'applyDefaultValues' cannot be null.");
        else if (applyDefaultValues !== undefined)
            url_ += "applyDefaultValues=" + encodeURIComponent("" + applyDefaultValues) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newItem);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ApiItemInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemInfo>(null as any);
    }

    /**
     * Modify defect collection
     * @param patchRequest Operation details.
     * @return Guid of the batch operation. 
    Status of the the operation can be retrieved using GET api/System/LongOperation/{guid}/Status or GET api/System/LongOperation/{guid}.
    In case of this batch operation the data retrieved from 'GET api/System/LongOperation/{guid}' contains additional information 
    as defined in ApiItemLongOperationInfo (FailedItems).
    Additionally, you SignalR (group "LongOperation_{customerId}_{guid}") can be used to receive information when operation finishes.
     */
    modifyItems(patchRequest: ApiItemsPatchRequest): Promise<ApiLongOperationOfBoolean> {
        let url_ = this.baseUrl + "/api/Defect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patchRequest);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyItems(_response);
        });
    }

    protected processModifyItems(response: Response): Promise<ApiLongOperationOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperationOfBoolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperationOfBoolean>(null as any);
    }

    /**
     * Get defect
     * @param id The id of the defect as integer (without DF).
     * @param withEditableInfo (optional) Indicates whether information about the
                edit lock should be included.
     * @param withEnclosure (optional) Indicates whether enclosures are included or not.
     * @param withEditLayout (optional) Indicates whether information about the edit layout should be included.
                Edit layout is a superset of view layout (you don't have to specify withViewLayout) and contains all information 
                required to display and edit the item.
     * @param withViewLayout (optional) Indicates whether information about the
                view layout should be included. The view layout is a subset of edit layout and 
                contains all information required to display the item.
     * @return The requested defect.
     */
    get(id: number, withEditableInfo?: boolean | undefined, withEnclosure?: boolean | undefined, withEditLayout?: boolean | undefined, withViewLayout?: boolean | undefined): Promise<ApiDefect> {
        let url_ = this.baseUrl + "/api/Defect/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (withEditableInfo === null)
            throw new Error("The parameter 'withEditableInfo' cannot be null.");
        else if (withEditableInfo !== undefined)
            url_ += "withEditableInfo=" + encodeURIComponent("" + withEditableInfo) + "&";
        if (withEnclosure === null)
            throw new Error("The parameter 'withEnclosure' cannot be null.");
        else if (withEnclosure !== undefined)
            url_ += "withEnclosure=" + encodeURIComponent("" + withEnclosure) + "&";
        if (withEditLayout === null)
            throw new Error("The parameter 'withEditLayout' cannot be null.");
        else if (withEditLayout !== undefined)
            url_ += "withEditLayout=" + encodeURIComponent("" + withEditLayout) + "&";
        if (withViewLayout === null)
            throw new Error("The parameter 'withViewLayout' cannot be null.");
        else if (withViewLayout !== undefined)
            url_ += "withViewLayout=" + encodeURIComponent("" + withViewLayout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ApiDefect> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiDefect;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiDefect>(null as any);
    }

    /**
     * Update defect
     * @param id The id of the defect.
     * @param update This object contains the changes which should be performed.
     * @param explicitLock (optional) Indicates that the defect has been explicitly locked before this request.
     * @param applyDefaultValues (optional) Indicates whether default values should be applied for fields which are not included in the request.
     */
    update(id: number, update: ApiItemUpdateWithEnclosures, explicitLock?: boolean | undefined, applyDefaultValues?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Defect/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (explicitLock === null)
            throw new Error("The parameter 'explicitLock' cannot be null.");
        else if (explicitLock !== undefined)
            url_ += "explicitLock=" + encodeURIComponent("" + explicitLock) + "&";
        if (applyDefaultValues === null)
            throw new Error("The parameter 'applyDefaultValues' cannot be null.");
        else if (applyDefaultValues !== undefined)
            url_ += "applyDefaultValues=" + encodeURIComponent("" + applyDefaultValues) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete defect
     * @param id The id of the defect.
     */
    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Defect/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get attachments metadata as list
     * @param id The id of the defect.
     * @return A list with meta information on all the attachments of this defect.
     */
    getAttachments(id: number): Promise<ApiAttachmentInfo[]> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Attachment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachments(_response);
        });
    }

    protected processGetAttachments(response: Response): Promise<ApiAttachmentInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo[]>(null as any);
    }

    /**
     * Create attachment
     * @param id The id of the defect.
     * @param filename (optional) The filename of the attachment. This parameter is optional. If it
                is not specified, the file name from the multi part form data will be used.
     * @param file (optional) 
     * @return The metadata of the created attachment.
     */
    addAttachment(id: number, filename?: string | null | undefined, file?: FileParameter[] | undefined): Promise<ApiAttachmentInfo> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Attachment?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (filename !== undefined && filename !== null)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddAttachment(_response);
        });
    }

    protected processAddAttachment(response: Response): Promise<ApiAttachmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo>(null as any);
    }

    /**
     * Get attachment metadata
     * @param id The id of the defect.
     * @param attachmentId The id of the attachment.
     * @return The meta information for the specified attachment.
     */
    getAttachment(id: number, attachmentId: number): Promise<ApiAttachmentInfo> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Attachment/{attachmentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachment(_response);
        });
    }

    protected processGetAttachment(response: Response): Promise<ApiAttachmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo>(null as any);
    }

    /**
     * Delete attachment
     * @param id The id of the defect.
     * @param attachmentId The id of the attachment.
     */
    deleteAttachment(id: number, attachmentId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Attachment/{attachmentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteAttachment(_response);
        });
    }

    protected processDeleteAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get attachment
     * @param id The id of the defect.
     * @param attachmentId The id of the attachment.
     * @param download (optional) When true, the response contains a content-disposition header to
                force the browser to download the attachment.
     * @param token (optional) Optional OAuth token.
     * @param tenantId (optional) The ID of the tenant. Only required in multi-tenant environments.
     * @return The file content of the attachment.
     */
    getAttachmentData(id: number, attachmentId: number, download?: boolean | undefined, token?: string | null | undefined, tenantId?: number | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Attachment/{attachmentId}/data?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        if (download === null)
            throw new Error("The parameter 'download' cannot be null.");
        else if (download !== undefined)
            url_ += "download=" + encodeURIComponent("" + download) + "&";
        if (token !== undefined && token !== null)
            url_ += "access_token=" + encodeURIComponent("" + token) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachmentData(_response);
        });
    }

    protected processGetAttachmentData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 307) {
            return response.text().then((_responseText) => {
            let result307: any = null;
            result307 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRedirectResult;
            return throwException("The request is redirected.", status, _responseText, _headers, result307);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get fields edit meta
     * @param id The id of the defect for which the edit meta is requested.
     * @param statusTo The id of the status we are switching to.
     * @return Basic information on the fields of the defect.
     */
    editMeta(id: number, statusTo: number): Promise<ApiItemEditMeta> {
        let url_ = this.baseUrl + "/api/Defect/{id}/EditMeta?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (statusTo === undefined || statusTo === null)
            throw new Error("The parameter 'statusTo' must be defined and cannot be null.");
        else
            url_ += "statusTo=" + encodeURIComponent("" + statusTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEditMeta(_response);
        });
    }

    protected processEditMeta(response: Response): Promise<ApiItemEditMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemEditMeta;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemEditMeta>(null as any);
    }

    /**
     * Get edit status
     * @param id The id of the defect.
     */
    getEditStatus(id: number): Promise<ApiItemEditStatus> {
        let url_ = this.baseUrl + "/api/Defect/{id}/EditStatus";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEditStatus(_response);
        });
    }

    protected processGetEditStatus(response: Response): Promise<ApiItemEditStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemEditStatus;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemEditStatus>(null as any);
    }

    /**
     * Get enclosures as list
     * @param id The id of the defect.
     * @return A list of all enclosures of the defect.
     */
    getEnclosures(id: number): Promise<ApiEnclosure[]> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Enclosure";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEnclosures(_response);
        });
    }

    protected processGetEnclosures(response: Response): Promise<ApiEnclosure[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiEnclosure[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiEnclosure[]>(null as any);
    }

    /**
     * Create enclosure
     * @param id The id of the defect.
     * @param apiEnclosure The data for the new enclosure.
     * @return The created enclousre.
     */
    createEnclosure(id: number, apiEnclosure: ApiEnclosureUpdate): Promise<ApiEnclosure> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Enclosure";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiEnclosure);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateEnclosure(_response);
        });
    }

    protected processCreateEnclosure(response: Response): Promise<ApiEnclosure> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiEnclosure;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiEnclosure>(null as any);
    }

    /**
     * Get enclosure
     * @param id The id of the defect.
     * @param enclosureId The id of the enclosure.
     * @return The enclosure with the given id.
     */
    getEnclosure(id: number, enclosureId: number): Promise<ApiEnclosure> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Enclosure/{enclosureId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (enclosureId === undefined || enclosureId === null)
            throw new Error("The parameter 'enclosureId' must be defined.");
        url_ = url_.replace("{enclosureId}", encodeURIComponent("" + enclosureId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEnclosure(_response);
        });
    }

    protected processGetEnclosure(response: Response): Promise<ApiEnclosure> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiEnclosure;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiEnclosure>(null as any);
    }

    /**
     * Update enclosure
     * @param id The id of the defect.
     * @param enclosureId The id of the enclosure.
     * @param apiEnclosure The data to update in the enclosure with the specified id.
     * @return The enclosure with the given id.
     */
    updateEnclosure(id: number, enclosureId: number, apiEnclosure: ApiEnclosureUpdate): Promise<ApiEnclosure> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Enclosure/{enclosureId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (enclosureId === undefined || enclosureId === null)
            throw new Error("The parameter 'enclosureId' must be defined.");
        url_ = url_.replace("{enclosureId}", encodeURIComponent("" + enclosureId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiEnclosure);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateEnclosure(_response);
        });
    }

    protected processUpdateEnclosure(response: Response): Promise<ApiEnclosure> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiEnclosure;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiEnclosure>(null as any);
    }

    /**
     * Delete enclosure
     * @param id The id of the defect.
     * @param enclosureId The id of the enclosure.
     */
    deleteEnclosure(id: number, enclosureId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Enclosure/{enclosureId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (enclosureId === undefined || enclosureId === null)
            throw new Error("The parameter 'enclosureId' must be defined.");
        url_ = url_.replace("{enclosureId}", encodeURIComponent("" + enclosureId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteEnclosure(_response);
        });
    }

    protected processDeleteEnclosure(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get history
     * @param id The id of the defect.
     * @return A list with all changes in chronological order.
     */
    getHistory(id: number): Promise<ApiHistoryEntryDefect[]> {
        let url_ = this.baseUrl + "/api/Defect/{id}/History";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetHistory(_response);
        });
    }

    protected processGetHistory(response: Response): Promise<ApiHistoryEntryDefect[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiHistoryEntryDefect[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiHistoryEntryDefect[]>(null as any);
    }

    /**
     * Create lock
     * @param id The id of the defect to lock.
     * @param lockInfo Contains the information necessary to acquire a lock.
     */
    createLock(id: number, lockInfo: ApiLockNew): Promise<void> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lockInfo);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateLock(_response);
        });
    }

    protected processCreateLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete lock
     * @param id The id of the defect for which the lock should be released.
     */
    deleteLock(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteLock(_response);
        });
    }

    protected processDeleteLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get posts
     * @param id The id of the defect.
     * @param firstResult (optional) The first result wich should be fetched. The default value is 0.
     * @param maxResults (optional) The maximal number of results wich should be fetched. The default value is 100.
     * @param ascending (optional) The sorting order of the result. If true sorted ascending otherwise descending. The default value is true.
     * @return A list of paginated posts associated with the given defect and the total count of all posts for this defect.
     */
    getPosts(id: number, firstResult?: number | undefined, maxResults?: number | undefined, ascending?: boolean | undefined): Promise<ApiPostPaginated> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Post?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (firstResult === null)
            throw new Error("The parameter 'firstResult' cannot be null.");
        else if (firstResult !== undefined)
            url_ += "firstResult=" + encodeURIComponent("" + firstResult) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (ascending === null)
            throw new Error("The parameter 'ascending' cannot be null.");
        else if (ascending !== undefined)
            url_ += "ascending=" + encodeURIComponent("" + ascending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPosts(_response);
        });
    }

    protected processGetPosts(response: Response): Promise<ApiPostPaginated> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostPaginated;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostPaginated>(null as any);
    }

    /**
     * Create post
     * @param id The id of the defect in which the new post should be created.
     * @param content The content of the new post. The content must be provided in exactly one format.
     * @return The meta information of the new post.
     */
    createPost(id: number, content: ApiRichText): Promise<ApiPostInfo> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Post";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreatePost(_response);
        });
    }

    protected processCreatePost(response: Response): Promise<ApiPostInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostInfo>(null as any);
    }

    /**
     * Get post
     * @param id The id of the defect.
     * @param postId The id of the post.
     * @return The requested post.
     */
    getPost(id: number, postId: number): Promise<ApiPost> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Post/{postId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPost(_response);
        });
    }

    protected processGetPost(response: Response): Promise<ApiPost> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPost;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPost>(null as any);
    }

    /**
     * Delete post
     * @param id The id of the defect.
     * @param postId The id of the post which should be deleted.
     * @return The meta information of the deleted post.
     */
    deletePost(id: number, postId: number): Promise<ApiPostInfo> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Post/{postId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeletePost(_response);
        });
    }

    protected processDeletePost(response: Response): Promise<ApiPostInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostInfo;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostInfo>(null as any);
    }

    /**
     * Replace post
     * @param id The id of the defect.
     * @param postId The id of the post which should be replaced.
     * @param content The new content of the post. The content must be provided in exactly one format.
     * @return The meta information of the replaced post.
     */
    updatePost(id: number, postId: number, content: ApiRichText): Promise<ApiPostInfo> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Post/{postId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePost(_response);
        });
    }

    protected processUpdatePost(response: Response): Promise<ApiPostInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostInfo>(null as any);
    }

    /**
     * Get relations
     * @param id The id of the defect.
     * @param depth (optional) The depth to which the relations are loaded. Depth 2 means that
                that the relations of relations are also loaded and so on. The default is 1.
     * @param maxItemsPerType (optional) The next level of relations is only loaded if at most
                this number of items of a certain type is present. Otherwise, the tree is cutoff.
                When this limit is not specified, this call might take a long time if the depth is
                greater than 1.
     * @param include (optional) Comma separated list of the data to include in the response.
                Supported includes: Relations.OtherItem.*Info to load basic info on the relation target,
                Relations.OtherItem.*Details to load the details of the relation target,
                Item.*Info to load basic info on the item for which the relations were requested,
                Item.*Details to load the details of the item for which the relations were requested.
     * @param fields (optional) The ids of the fields which should be included when details are included.
                When left empty, all fields will be included.
     * @return A list with all the relations together with some additional information.
     */
    getRelations(id: number, depth?: number | undefined, maxItemsPerType?: number | null | undefined, include?: string | null | undefined, fields?: string | null | undefined): Promise<ApiRelations> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Relation?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (depth === null)
            throw new Error("The parameter 'depth' cannot be null.");
        else if (depth !== undefined)
            url_ += "depth=" + encodeURIComponent("" + depth) + "&";
        if (maxItemsPerType !== undefined && maxItemsPerType !== null)
            url_ += "maxItemsPerType=" + encodeURIComponent("" + maxItemsPerType) + "&";
        if (include !== undefined && include !== null)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        if (fields !== undefined && fields !== null)
            url_ += "fields=" + encodeURIComponent("" + fields) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRelations(_response);
        });
    }

    protected processGetRelations(response: Response): Promise<ApiRelations> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelations;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelations>(null as any);
    }

    /**
     * Create relation
     * @param id The id of the defect.
     * @param relation The other information necessary to create the relation.
     * @return The created relation.
     */
    createRelation(id: number, relation: ApiRelationNew): Promise<ApiRelation> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Relation";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(relation);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateRelation(_response);
        });
    }

    protected processCreateRelation(response: Response): Promise<ApiRelation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelation;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelation>(null as any);
    }

    /**
     * Delete relation
     * @param id The id of the defect.
     * @param relationId The id of the relation.
     */
    deleteRelations(id: number, relationId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Relation/{relationId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (relationId === undefined || relationId === null)
            throw new Error("The parameter 'relationId' must be defined.");
        url_ = url_.replace("{relationId}", encodeURIComponent("" + relationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteRelations(_response);
        });
    }

    protected processDeleteRelations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get relation metadata
     * @param id The id of the defect.
     * @return The metadata required to create new relations.
     */
    getRelationCreateMeta(id: number): Promise<ApiRelationCreateMeta> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Relation/CreateMeta";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRelationCreateMeta(_response);
        });
    }

    protected processGetRelationCreateMeta(response: Response): Promise<ApiRelationCreateMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelationCreateMeta;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelationCreateMeta>(null as any);
    }

    /**
     * Get watching users as list
     * @param id The id of the defect.
     * @return List of users watching this defect.
     */
    getWatchers(id: number): Promise<ApiUserInfo[]> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetWatchers(_response);
        });
    }

    protected processGetWatchers(response: Response): Promise<ApiUserInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUserInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiUserInfo[]>(null as any);
    }

    /**
     * Add to watch list
     * @param id The id of the defect.
     * @param newWatcher Contains id of the user to be subscribed.
     */
    addWatcher(id: number, newWatcher: ApiWatcherNew): Promise<void> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newWatcher);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddWatcher(_response);
        });
    }

    protected processAddWatcher(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Updates the watch list
     * @param id The id of the defect.
     * @param watchersUpdate Contains the id of the user to be (un-)subscribed.
     */
    updateWatchers(id: number, watchersUpdate: ApiWatchersUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(watchersUpdate);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateWatchers(_response);
        });
    }

    protected processUpdateWatchers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove from watch list
     * @param id The id of the defect.
     * @param userId The id of the user to be unsubscribed.
     */
    removeWatcher(id: number, userId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Defect/{id}/Watchers/{userId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveWatcher(_response);
        });
    }

    protected processRemoveWatcher(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get fields metadata
     * @param projectId The id of the project.
     * @param folderId The id of the folder where the item will be created (0 means root level).
     * @param statusTo (optional) The id of status with which the new item will be saved. Workflow
                restrictions might depend on this status and hence the meta data might change depending
                on the selected status. If no status id is provided, the default value for the status
                is assumed.
     * @return Basic information on the fields of a new defect created in given project and folder.
     */
    createMeta(projectId: number, folderId: number, statusTo?: number | null | undefined): Promise<ApiItemCreateMeta> {
        let url_ = this.baseUrl + "/api/Defect/CreateMeta?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined and cannot be null.");
        else
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (statusTo !== undefined && statusTo !== null)
            url_ += "statusTo=" + encodeURIComponent("" + statusTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMeta(_response);
        });
    }

    protected processCreateMeta(response: Response): Promise<ApiItemCreateMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemCreateMeta;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemCreateMeta>(null as any);
    }

    /**
     * Get defects
     * @param projectId The id of the project of which the items are loaded.
     * @param folderId (optional) The id of the folder of which the items are loaded.
     * @param includeSubfolders (optional) Indicates whether items from sub folders should be included.
     * @param includeArchived (optional) Indicates whether archieved items should be included.
     * @param filter (optional) The filter syntax is as follows:
                [["Priority", "=", "High"], "and", ["DateCreatedDateTime", ">=", "2018-01-01"]]
                The field meta data can be used to check which filter operators are supported for which fields.
     * @param sorting (optional) The sorting syntax is as follows:
                [["Significane", "desc"], ["Status", "asc]]
                The field meta data can be used to check which fields support sorting.
     * @param search (optional) A fulltext search will be performed with this term and only matching
                items will be included in the result.
     * @param startAt (optional) The index of the first item which should be included. Allows pagination
                of the results.
     * @param maxResults (optional) The maximum number of items to return. Allows pagination of the results.
     * @return A list of items matching the given criteria.
     */
    getItemList(projectId: number, folderId?: number | undefined, includeSubfolders?: boolean | undefined, includeArchived?: boolean | undefined, filter?: string | null | undefined, sorting?: string | null | undefined, search?: string | null | undefined, startAt?: number | undefined, maxResults?: number | undefined): Promise<ApiItemListResult> {
        let url_ = this.baseUrl + "/api/Defect/ItemList?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (includeSubfolders === null)
            throw new Error("The parameter 'includeSubfolders' cannot be null.");
        else if (includeSubfolders !== undefined)
            url_ += "includeSubfolders=" + encodeURIComponent("" + includeSubfolders) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetItemList(_response);
        });
    }

    protected processGetItemList(response: Response): Promise<ApiItemListResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemListResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemListResult>(null as any);
    }
}

export class EnvironmentClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Provides information about a system environment
     */
    getEnvironmentInfo(): Promise<ApiEnvironmentInfo> {
        let url_ = this.baseUrl + "/api/Environment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEnvironmentInfo(_response);
        });
    }

    protected processGetEnvironmentInfo(response: Response): Promise<ApiEnvironmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiEnvironmentInfo;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiEnvironmentInfo>(null as any);
    }
}

export class ExportClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Download the Result of an Export
     * @param exportFileGuid the file gui from api/System/LongOperation/{guid}
     */
    getExportData(exportFileGuid: string | null): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/ExportItems/{exportFileGuid}";
        if (exportFileGuid === undefined || exportFileGuid === null)
            throw new Error("The parameter 'exportFileGuid' must be defined.");
        url_ = url_.replace("{exportFileGuid}", encodeURIComponent("" + exportFileGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetExportData(_response);
        });
    }

    protected processGetExportData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Export item to zipped Excel
     * @param projectId The target project for the import
     * @param folderId The target folderid for the import
     * @param request Export options
     * @return Guid of the import operation. 
    Status of the the operation can be retrieved using GET api/System/LongOperation/{guid}/Status or GET api/System/LongOperation/{guid}.
    In the result of api/System/LongOperation/{guid} you can find the file guid to download the file from GET api/ExportItems/{fileguid}
    Additionally, you SignalR (group "LongOperation_{customerId}_{guid}") can be used to receive information when operation finishes.
     */
    exportToExcel(projectId: number, folderId: number, request: ApiItemExportRequest): Promise<ApiLongOperationOfBoolean> {
        let url_ = this.baseUrl + "/api/ExportItems/{projectId}/{folderId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined.");
        url_ = url_.replace("{folderId}", encodeURIComponent("" + folderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExportToExcel(_response);
        });
    }

    protected processExportToExcel(response: Response): Promise<ApiLongOperationOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperationOfBoolean;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperationOfBoolean>(null as any);
    }
}

export class FileClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Upload file
     * @param fileName (optional) The file name to use. This parameter is optional. If it is not
                specified the file name from the multi part form data will be used.
     * @param file (optional) 
     * @return The metadata of the uploaded file
     */
    uploadFile(fileName?: string | null | undefined, file?: FileParameter[] | undefined): Promise<ApiFileUploadInfo> {
        let url_ = this.baseUrl + "/api/File?";
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: Response): Promise<ApiFileUploadInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiFileUploadInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiFileUploadInfo>(null as any);
    }

    /**
     * Get file
     * @param guid The guid of the file.
     * @return The content of the file
     */
    getFile(guid: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/File/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFile(_response);
        });
    }

    protected processGetFile(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Upload file with GUID
     * @param guid The guid of the file.
     * @param uploadedFile The file to upload. Do NOT provide a JSON here. Instead,
                directly upload the file by sending it as the request body.
     */
    uploadFileWithGuid(guid: string, uploadedFile: Blob | null): Promise<void> {
        let url_ = this.baseUrl + "/api/File/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = uploadedFile;

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "*/*",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUploadFileWithGuid(_response);
        });
    }

    protected processUploadFileWithGuid(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create upload URL
     * @param fileUploadUrlRequest The file metadata which is required to create the upload URL.
     */
    createFileUploadUrL(fileUploadUrlRequest: ApiFileUploadUrlRequest): Promise<ApiFileUploadUrlResponse> {
        let url_ = this.baseUrl + "/api/File/UploadUrl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fileUploadUrlRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateFileUploadUrL(_response);
        });
    }

    protected processCreateFileUploadUrL(response: Response): Promise<ApiFileUploadUrlResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiFileUploadUrlResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiFileUploadUrlResponse>(null as any);
    }
}

export class GlobalSearchClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Returns aqua objects which types and names match the conditions represented 
    in apiGlobalSearchRequest
     */
    get(request: ApiGlobalSearchRequest): Promise<ApiGlobalSearchResult> {
        let url_ = this.baseUrl + "/api/GlobalSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ApiGlobalSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiGlobalSearchResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiGlobalSearchResult>(null as any);
    }
}

export class ImageClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Upload image
     * @param file (optional) 
     * @return The metadata of the uploaded image
     */
    uploadImage(file?: FileParameter[] | undefined): Promise<ApiImageUploadInfo> {
        let url_ = this.baseUrl + "/api/Image";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUploadImage(_response);
        });
    }

    protected processUploadImage(response: Response): Promise<ApiImageUploadInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiImageUploadInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiImageUploadInfo>(null as any);
    }

    /**
     * Get image metadata by checksum
     * @param checksum The checksum of the image
     * @return The metadata of the image
     */
    getImageInfo2(checksum: string | null): Promise<ApiImageInfo> {
        let url_ = this.baseUrl + "/api/Image/{checksum}";
        if (checksum === undefined || checksum === null)
            throw new Error("The parameter 'checksum' must be defined.");
        url_ = url_.replace("{checksum}", encodeURIComponent("" + checksum));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetImageInfo2(_response);
        });
    }

    protected processGetImageInfo2(response: Response): Promise<ApiImageInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiImageInfo;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiImageInfo>(null as any);
    }

    /**
     * Get image by checksum
     * @param checksum The checksum of the image
     * @param resize (optional) Indicates whether the image should be resized to the dimensions given in the rich text.
                The original image can have different dimensions. The default is true.
     * @return The content of the image
     */
    getImageData2(checksum: string | null, resize?: boolean | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Image/{checksum}/data?";
        if (checksum === undefined || checksum === null)
            throw new Error("The parameter 'checksum' must be defined.");
        url_ = url_.replace("{checksum}", encodeURIComponent("" + checksum));
        if (resize === null)
            throw new Error("The parameter 'resize' cannot be null.");
        else if (resize !== undefined)
            url_ += "resize=" + encodeURIComponent("" + resize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetImageData2(_response);
        });
    }

    protected processGetImageData2(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get image metadata by id and checksum
     * @param id The id of the image
     * @param checksum The checksum of the image
     * @return The metadata of the image
     */
    getImageInfo(id: number, checksum: string | null): Promise<ApiImageInfo> {
        let url_ = this.baseUrl + "/api/Image/{id}/{checksum}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (checksum === undefined || checksum === null)
            throw new Error("The parameter 'checksum' must be defined.");
        url_ = url_.replace("{checksum}", encodeURIComponent("" + checksum));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetImageInfo(_response);
        });
    }

    protected processGetImageInfo(response: Response): Promise<ApiImageInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiImageInfo;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiImageInfo>(null as any);
    }

    /**
     * Get image by id and checksum
     * @param id The id of the image
     * @param checksum The checksum of the image
     * @param resize (optional) Indicates whether the image should be resized to the dimensions given in the rich text.
                The original image can have different dimensions. The default is true.
     * @return The content of the image
     */
    getImageData(id: number, checksum: string | null, resize?: boolean | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Image/{id}/{checksum}/data?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (checksum === undefined || checksum === null)
            throw new Error("The parameter 'checksum' must be defined.");
        url_ = url_.replace("{checksum}", encodeURIComponent("" + checksum));
        if (resize === null)
            throw new Error("The parameter 'resize' cannot be null.");
        else if (resize !== undefined)
            url_ += "resize=" + encodeURIComponent("" + resize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetImageData(_response);
        });
    }

    protected processGetImageData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get image by imageName
     * @param imageName The name of the image
     * @return The content of the image
     */
    getImage(imageName: string | null): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Image/Temp/{imageName}";
        if (imageName === undefined || imageName === null)
            throw new Error("The parameter 'imageName' must be defined.");
        url_ = url_.replace("{imageName}", encodeURIComponent("" + imageName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetImage(_response);
        });
    }

    protected processGetImage(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class ImportClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Import item from Excel file
     * @param projectId The target project for the import
     * @param folderId The target folderid for the import
     * @param request The file which should be imported.
    The file should be uploaded to the endpoint
    [UploadFile](#operation/File_UploadFile)
    first.
     * @return Guid of the import operation. 
    Status of the the operation can be retrieved using GET api/System/LongOperation/{guid}/Status or GET api/System/LongOperation/{guid}.
    In case of this batch operation the data retrieved from 'GET api/System/LongOperation/{guid}' contains additional information 
    as defined in ApiItemLongOperationInfo (FailedItems).
    Additionally, you SignalR (group "LongOperation_{customerId}_{guid}") can be used to receive information when operation finishes.
     */
    importFromExcel(projectId: number, folderId: number, request: ApiItemImportRequest): Promise<ApiLongOperationOfBoolean> {
        let url_ = this.baseUrl + "/api/ImportItems/{projectId}/{folderId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined.");
        url_ = url_.replace("{folderId}", encodeURIComponent("" + folderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImportFromExcel(_response);
        });
    }

    protected processImportFromExcel(response: Response): Promise<ApiLongOperationOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperationOfBoolean;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperationOfBoolean>(null as any);
    }

    /**
     * Information for Excel import file
     * @param projectId The target project for the import
     * @param folderId The target folderid for the import
     * @param objectTypes (optional) The objecttype to create the template for
     * @return The information for the worksheet in the excel file
     */
    getFieldInfo(projectId: number, folderId: number, objectTypes?: ObjectType[] | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/ImportItems/{projectId}/{folderId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined.");
        url_ = url_.replace("{folderId}", encodeURIComponent("" + folderId));
        if (objectTypes !== undefined && objectTypes !== null)
            objectTypes && objectTypes.forEach(item => { url_ += "objectTypes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFieldInfo(_response);
        });
    }

    protected processGetFieldInfo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class IntegrationsClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get Configurations
     * @param onlyProjectLevel (optional) The project level integrations are only returned if this is true
     * @return The integration configurations for global or for the specified project together with
                some necessary meta data.
     */
    getIntegrationConfigurations(onlyProjectLevel?: boolean | undefined): Promise<ApiIntegrationConfigurations> {
        let url_ = this.baseUrl + "/api/Integration/Configuration?";
        if (onlyProjectLevel === null)
            throw new Error("The parameter 'onlyProjectLevel' cannot be null.");
        else if (onlyProjectLevel !== undefined)
            url_ += "onlyProjectLevel=" + encodeURIComponent("" + onlyProjectLevel) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetIntegrationConfigurations(_response);
        });
    }

    protected processGetIntegrationConfigurations(response: Response): Promise<ApiIntegrationConfigurations> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiIntegrationConfigurations;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiIntegrationConfigurations>(null as any);
    }

    /**
     * Replace global configurations
     * @param update The new global integration configurations.
     */
    saveGlobalIntegrationConfigurations(update: ApiIntegrationConfigurationsUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/Integration/Configuration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveGlobalIntegrationConfigurations(_response);
        });
    }

    protected processSaveGlobalIntegrationConfigurations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get project configurations
     * @param projectId The id of the project for which the integration configurations
                are requested.
     * @return The integration configurations for the specified project together with
                some necessary meta data.
     */
    getProjectIntegrationConfigurations(projectId: number): Promise<ApiIntegrationConfigurations> {
        let url_ = this.baseUrl + "/api/Integration/Configuration/Project/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProjectIntegrationConfigurations(_response);
        });
    }

    protected processGetProjectIntegrationConfigurations(response: Response): Promise<ApiIntegrationConfigurations> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiIntegrationConfigurations;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiIntegrationConfigurations>(null as any);
    }

    /**
     * Replace project configurations
     * @param projectId The id of project of which the integration configurations are replaced.
     * @param update The new integration configurations for the specified project.
     */
    saveProjectIntegrationConfigurations(projectId: number, update: ApiIntegrationConfigurationsUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/Integration/Configuration/Project/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveProjectIntegrationConfigurations(_response);
        });
    }

    protected processSaveProjectIntegrationConfigurations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get effective project configurations
     * @param projectId The id of the project.
     */
    getEffectiveIntegrations(projectId: number): Promise<ApiIntegrationConfigurations> {
        let url_ = this.baseUrl + "/api/Integration/Effective/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEffectiveIntegrations(_response);
        });
    }

    protected processGetEffectiveIntegrations(response: Response): Promise<ApiIntegrationConfigurations> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiIntegrationConfigurations;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiIntegrationConfigurations>(null as any);
    }

    /**
     * Enable
     * @param config The details for the specific integration
     */
    enable(config: ApiIntegrationEnable): Promise<void> {
        let url_ = this.baseUrl + "/api/Integration/Enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(config);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEnable(_response);
        });
    }

    protected processEnable(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Verify
     * @param config The integration details
     * @return An indication if the connection could be made or not
     */
    verify(config: ApiIntegrationConfigVerifyBase): Promise<ApiIntegrationVerifyResponse> {
        let url_ = this.baseUrl + "/api/Integration/Verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(config);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: Response): Promise<ApiIntegrationVerifyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiIntegrationVerifyResponse;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiIntegrationVerifyResponse>(null as any);
    }
}

export class LabelClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Create new label
     * @param itemTypes The item types this label supports as a comma-separated list. Possible values for item
    type are: TestCase.
     */
    createLabel(newLabel: ApiLabelNew, itemTypes: string | null): Promise<ApiLabelNewResponse> {
        let url_ = this.baseUrl + "/api/Label?";
        if (itemTypes === undefined)
            throw new Error("The parameter 'itemTypes' must be defined.");
        else if(itemTypes !== null)
            url_ += "itemTypes=" + encodeURIComponent("" + itemTypes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newLabel);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateLabel(_response);
        });
    }

    protected processCreateLabel(response: Response): Promise<ApiLabelNewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLabelNewResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLabelNewResponse>(null as any);
    }

    /**
     * List labels
     * @param itemType The item type for which to get labels. Possible values are: TestCase.
     * @param folderId (optional) 
     */
    listLabels(projectId: number, itemType: string | null, folderId?: number | null | undefined): Promise<ApiLabelListResult> {
        let url_ = this.baseUrl + "/api/Label?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (itemType === undefined)
            throw new Error("The parameter 'itemType' must be defined.");
        else if(itemType !== null)
            url_ += "itemType=" + encodeURIComponent("" + itemType) + "&";
        if (folderId !== undefined && folderId !== null)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processListLabels(_response);
        });
    }

    protected processListLabels(response: Response): Promise<ApiLabelListResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLabelListResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLabelListResult>(null as any);
    }

    /**
     * Update label
     */
    updateLabel(id: number, update: ApiLabelUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/Label/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateLabel(_response);
        });
    }

    protected processUpdateLabel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete label
     */
    deleteLabel(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Label/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteLabel(_response);
        });
    }

    protected processDeleteLabel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class NavigationClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get dependent items
     * @param ids Comma separated list of item ids where dependencies are searched for.
     * @param itemType The type of dependent items which should be loaded.
     * @param projectId The id of the project.
     */
    getDependency(ids: string | null, itemType: ApiItemType, projectId: number): Promise<ApiNavigationDependencyResponse> {
        let url_ = this.baseUrl + "/api/Navigation/DependencyList?";
        if (ids === undefined)
            throw new Error("The parameter 'ids' must be defined.");
        else if(ids !== null)
            url_ += "ids=" + encodeURIComponent("" + ids) + "&";
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined and cannot be null.");
        else
            url_ += "itemType=" + encodeURIComponent("" + itemType) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDependency(_response);
        });
    }

    protected processGetDependency(response: Response): Promise<ApiNavigationDependencyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNavigationDependencyResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiNavigationDependencyResponse>(null as any);
    }

    /**
     * Get groups
     * @param itemType The type of items which should be grouped.
     * @param projectId The id of the project of which the items are grouped.
     * @param folderId The id of the folder of which the items are grouped.
     * @param includeSubfolders (optional) Indicates whether items from sub folders should be included.
     * @param includeArchived (optional) Indicates whether archieved items should be included.
     * @param filter (optional) The filter syntax is as follows:
                [["Priority", "=", "High"], "and", ["DateCreatedDateTime", ">=", "2018-01-01"]]
                The field meta data can be used to check which filter operators are supported for which fields.
     * @param sorting (optional) The sorting syntax is as follows:
                [["Significane", "desc"], ["Status", "asc]]
                The field meta data can be used to check which fields support sorting.
     * @param search (optional) A fulltext search will be performed with this term and only matching
                items will be considered for the grouping
     * @param groups (optional) The grouping syntax is as follows:
                [["Significane", "desc"], ["Status", "asc]]
                The field meta data can be used to check which fields support grouping. Grouping always includes
                sorting by the grouped fields. The fields provided in sorting are used for additional sorting.
     */
    getGroupsGET(itemType: ApiItemType, projectId: number, folderId: number, includeSubfolders?: boolean | undefined, includeArchived?: boolean | undefined, filter?: string | null | undefined, sorting?: string | null | undefined, search?: string | null | undefined, groups?: string | null | undefined): Promise<ApiItemGroupsResult> {
        let url_ = this.baseUrl + "/api/Navigation/GroupList?";
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined and cannot be null.");
        else
            url_ += "itemType=" + encodeURIComponent("" + itemType) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined and cannot be null.");
        else
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (includeSubfolders === null)
            throw new Error("The parameter 'includeSubfolders' cannot be null.");
        else if (includeSubfolders !== undefined)
            url_ += "includeSubfolders=" + encodeURIComponent("" + includeSubfolders) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (groups !== undefined && groups !== null)
            url_ += "groups=" + encodeURIComponent("" + groups) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGroupsGET(_response);
        });
    }

    protected processGetGroupsGET(response: Response): Promise<ApiItemGroupsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemGroupsResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemGroupsResult>(null as any);
    }

    /**
     * Get groups
     * @param itemArrangementGrouping Contains filter, sorting and search information and grouping.
     * @param itemType The type of items which should be grouped.
     * @param projectId The id of the project of which the items are grouped.
     * @param folderId The id of the folder of which the items are grouped.
     * @param includeSubfolders (optional) Indicates whether items from sub folders should be included.
     * @param includeArchived (optional) Indicates whether archieved items should be included.
     */
    getGroupsPOST(itemArrangementGrouping: ApiItemArrangementGrouping, itemType: ApiItemType, projectId: number, folderId: number, includeSubfolders?: boolean | undefined, includeArchived?: boolean | undefined): Promise<ApiItemGroupsResult> {
        let url_ = this.baseUrl + "/api/Navigation/GroupList?";
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined and cannot be null.");
        else
            url_ += "itemType=" + encodeURIComponent("" + itemType) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined and cannot be null.");
        else
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (includeSubfolders === null)
            throw new Error("The parameter 'includeSubfolders' cannot be null.");
        else if (includeSubfolders !== undefined)
            url_ += "includeSubfolders=" + encodeURIComponent("" + includeSubfolders) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(itemArrangementGrouping);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGroupsPOST(_response);
        });
    }

    protected processGetGroupsPOST(response: Response): Promise<ApiItemGroupsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemGroupsResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemGroupsResult>(null as any);
    }

    /**
     * Get items
     * @param itemType The type of items which should be loaded.
     * @param projectId The id of the project of which the items are loaded.
     * @param folderId (optional) The id of the folder of which the items are loaded.
     * @param includeSubfolders (optional) Indicates whether items from sub folders should be included.
     * @param includeArchived (optional) Indicates whether archieved items should be included.
     * @param includePermissions (optional) If true permissions are returned as well (default is false).
     * @param filter (optional) The filter syntax is as follows:
                [["Priority", "=", "High"], "and", ["DateCreatedDateTime", ">=", "2018-01-01"]].
                The [field meta data](#operation/ProjectMeta_GetProjectFieldMeta) can be used to check which filter operators are supported for which fields.
     * @param sorting (optional) The sorting syntax is as follows:
                [["Significane", "desc"], ["Status", "asc]].
                The [field meta data](#operation/ProjectMeta_GetProjectFieldMeta) can be used to check which fields support sorting.
     * @param search (optional) A fulltext search will be performed with this term and only matching
                items will be included in the result.
     * @param startAt (optional) The index of the first item which should be included. Allows pagination
                of the results.
     * @param maxResults (optional) The maximum number of items to return. Allows pagination of the results.
     * @return A list of items matching the given criteria.
     */
    itemListGET(itemType: ApiItemType, projectId: number, folderId?: number | undefined, includeSubfolders?: boolean | undefined, includeArchived?: boolean | undefined, includePermissions?: boolean | undefined, filter?: string | null | undefined, sorting?: string | null | undefined, search?: string | null | undefined, startAt?: number | undefined, maxResults?: number | undefined): Promise<ApiItemListResult> {
        let url_ = this.baseUrl + "/api/Navigation/ItemList?";
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined and cannot be null.");
        else
            url_ += "itemType=" + encodeURIComponent("" + itemType) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (includeSubfolders === null)
            throw new Error("The parameter 'includeSubfolders' cannot be null.");
        else if (includeSubfolders !== undefined)
            url_ += "includeSubfolders=" + encodeURIComponent("" + includeSubfolders) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        if (includePermissions === null)
            throw new Error("The parameter 'includePermissions' cannot be null.");
        else if (includePermissions !== undefined)
            url_ += "includePermissions=" + encodeURIComponent("" + includePermissions) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processItemListGET(_response);
        });
    }

    protected processItemListGET(response: Response): Promise<ApiItemListResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemListResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemListResult>(null as any);
    }

    /**
     * Get items
     * @param itemArrangement Contains filter, sorting and search information.
     * @param itemType The type of items which should be loaded.
     * @param projectId The id of the project of which the items are loaded.
     * @param folderId (optional) The id of the folder of which the items are loaded.
     * @param includeSubfolders (optional) Indicates whether items from sub folders should be included.
     * @param includeArchived (optional) Indicates whether archieved items should be included.
     * @param includePermissions (optional) If true permissions are returned as well (default is false).
     * @param startAt (optional) The index of the first item which should be included. Allows pagination
                of the results.
     * @param maxResults (optional) The maximum number of items to return. Allows pagination of the results.
     * @return A list of items matching the given criteria.
     */
    itemListPOST(itemArrangement: ApiItemArrangement, itemType: ApiItemType, projectId: number, folderId?: number | undefined, includeSubfolders?: boolean | undefined, includeArchived?: boolean | undefined, includePermissions?: boolean | undefined, startAt?: number | undefined, maxResults?: number | undefined): Promise<ApiItemListResult> {
        let url_ = this.baseUrl + "/api/Navigation/ItemList?";
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined and cannot be null.");
        else
            url_ += "itemType=" + encodeURIComponent("" + itemType) + "&";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (includeSubfolders === null)
            throw new Error("The parameter 'includeSubfolders' cannot be null.");
        else if (includeSubfolders !== undefined)
            url_ += "includeSubfolders=" + encodeURIComponent("" + includeSubfolders) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        if (includePermissions === null)
            throw new Error("The parameter 'includePermissions' cannot be null.");
        else if (includePermissions !== undefined)
            url_ += "includePermissions=" + encodeURIComponent("" + includePermissions) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(itemArrangement);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processItemListPOST(_response);
        });
    }

    protected processItemListPOST(response: Response): Promise<ApiItemListResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemListResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemListResult>(null as any);
    }

    /**
     * Get subfolders
     * @param parentFolders JSON array of requested parent folders to retrieve subfolder for. For example:
                ['5_0', '3_114'] where first number is a project id and second number is folder id (or zero for root).
     * @param includeProjects (optional) Indicate whether to return project list as well.
     * @param includeArchived (optional) Indicates whether archived items should be included.
     * @return A response object containing project list (if requested) and subfolders of all requested nodes.
     */
    getProjectTreeData(parentFolders: string | null, includeProjects?: boolean | undefined, includeArchived?: boolean | undefined): Promise<ApiProjectTreeResponse> {
        let url_ = this.baseUrl + "/api/Navigation/Tree?";
        if (parentFolders === undefined)
            throw new Error("The parameter 'parentFolders' must be defined.");
        else if(parentFolders !== null)
            url_ += "parentFolders=" + encodeURIComponent("" + parentFolders) + "&";
        if (includeProjects === null)
            throw new Error("The parameter 'includeProjects' cannot be null.");
        else if (includeProjects !== undefined)
            url_ += "includeProjects=" + encodeURIComponent("" + includeProjects) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProjectTreeData(_response);
        });
    }

    protected processGetProjectTreeData(response: Response): Promise<ApiProjectTreeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectTreeResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectTreeResponse>(null as any);
    }

    /**
     * Get folder path
     * @param projectId The id of the project where folder is located.
     * @param folderId The id of the folder.
     * @return "Folder path" information for given folder.
     */
    getProjectTreePath(projectId: number, folderId: number): Promise<ApiProjectTreePathResponse> {
        let url_ = this.baseUrl + "/api/Navigation/TreePath/{projectId}/{folderId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined.");
        url_ = url_.replace("{folderId}", encodeURIComponent("" + folderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProjectTreePath(_response);
        });
    }

    protected processGetProjectTreePath(response: Response): Promise<ApiProjectTreePathResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectTreePathResponse;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectTreePathResponse>(null as any);
    }
}

export class OperationLogClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get log categories as list
     * @return List of all available categories.
     */
    getCategories(): Promise<ApiOperationLogCategory[]> {
        let url_ = this.baseUrl + "/api/OperationLog/Category";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCategories(_response);
        });
    }

    protected processGetCategories(response: Response): Promise<ApiOperationLogCategory[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiOperationLogCategory[];
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiOperationLogCategory[]>(null as any);
    }

    /**
     * Search log
     * @param firstResults (optional) Used for pagination, defines how many items to skip in the
                found result set.
     * @param maxResults (optional) Used for pagination, defines how many items to take from the
                found result set (starting from firstResults).
     * @param projectId (optional) The id of the project the log entry is related to. When no project id
                is provided, system level entries will be returned. Note that system level log entries are only
                accessible by system administrators.
     * @param folderId (optional) The id of the folder the log entry is related to. If provided, projectId
                must be specified as well.
     * @param folderPath (optional) Part of folder path the log entry is related to. If provided, projectId
                must be specified as well.
     * @param operationUserId (optional) The id of the user who did the change.
     * @param dateFromUTC (optional) If provided, only operations performed at this date or later are matched.
     * @param dateToUTC (optional) If provided, only operations performed at this date or earlier are matched.
     * @param category (optional) Allows to filter by category. Supports partial categories (prefixes)
                e.g. admin.project.automation
     * @return An array of ApiOperationLog matching the criteria.
     */
    searchOperationLogs(firstResults?: number | null | undefined, maxResults?: number | null | undefined, projectId?: number | null | undefined, folderId?: number | null | undefined, folderPath?: string | null | undefined, operationUserId?: number | null | undefined, dateFromUTC?: Date | null | undefined, dateToUTC?: Date | null | undefined, category?: string | null | undefined): Promise<ApiSearchOperationLogResult> {
        let url_ = this.baseUrl + "/api/OperationLog/Search?";
        if (firstResults !== undefined && firstResults !== null)
            url_ += "firstResults=" + encodeURIComponent("" + firstResults) + "&";
        if (maxResults !== undefined && maxResults !== null)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (projectId !== undefined && projectId !== null)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId !== undefined && folderId !== null)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (folderPath !== undefined && folderPath !== null)
            url_ += "folderPath=" + encodeURIComponent("" + folderPath) + "&";
        if (operationUserId !== undefined && operationUserId !== null)
            url_ += "operationUserId=" + encodeURIComponent("" + operationUserId) + "&";
        if (dateFromUTC !== undefined && dateFromUTC !== null)
            url_ += "dateFromUTC=" + encodeURIComponent(dateFromUTC ? "" + dateFromUTC.toISOString() : "") + "&";
        if (dateToUTC !== undefined && dateToUTC !== null)
            url_ += "dateToUTC=" + encodeURIComponent(dateToUTC ? "" + dateToUTC.toISOString() : "") + "&";
        if (category !== undefined && category !== null)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchOperationLogs(_response);
        });
    }

    protected processSearchOperationLogs(response: Response): Promise<ApiSearchOperationLogResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiSearchOperationLogResult;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSearchOperationLogResult>(null as any);
    }
}

export class ProjectClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get my projects
     * @param onlySharedWithProject (optional) When the id of a project is provided, only projects which
                share their template with specified project are included.
     * @param includePermissions (optional) Indicates whether the project permissions of the current user should be included
                for each project.
     * @param includeArchived (optional) Indicates whether archived projects should be returned. Default: true.
     * @return returns a list of available projects
     */
    getAll(onlySharedWithProject?: number | null | undefined, includePermissions?: boolean | undefined, includeArchived?: boolean | undefined): Promise<ApiProjectInfo[]> {
        let url_ = this.baseUrl + "/api/Project?";
        if (onlySharedWithProject !== undefined && onlySharedWithProject !== null)
            url_ += "onlySharedWithProject=" + encodeURIComponent("" + onlySharedWithProject) + "&";
        if (includePermissions === null)
            throw new Error("The parameter 'includePermissions' cannot be null.");
        else if (includePermissions !== undefined)
            url_ += "includePermissions=" + encodeURIComponent("" + includePermissions) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<ApiProjectInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectInfo[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectInfo[]>(null as any);
    }

    /**
     * Create project
     * @param projectCreate The data for the new project which should be created.
     * @return The id of the new project
     */
    createProject(projectCreate: ApiProjectCreate): Promise<ApiProjectNewResponse> {
        let url_ = this.baseUrl + "/api/Project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectCreate);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateProject(_response);
        });
    }

    protected processCreateProject(response: Response): Promise<ApiProjectNewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectNewResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectNewResponse>(null as any);
    }

    /**
     * Get project
     * @param includePermissions (optional) Indicates whether the project permissions of the current user should be included
                for each project.
     * @return The requested project
     */
    get(id: number, includePermissions?: boolean | undefined): Promise<ApiProjectInfo> {
        let url_ = this.baseUrl + "/api/Project/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includePermissions === null)
            throw new Error("The parameter 'includePermissions' cannot be null.");
        else if (includePermissions !== undefined)
            url_ += "includePermissions=" + encodeURIComponent("" + includePermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ApiProjectInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectInfo;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectInfo>(null as any);
    }

    /**
     * Update project
     * @param id The id of the project.
     * @param operation Request containing the modify information for the project.
     */
    update(id: number, operation: ApiProjectPatchOperation): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(operation);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get sprints as list
     * @param id The id of project.
     * @param includeSprints (optional) Include all, active or only inactive sprints. Default is all.
     * @return The requested project sprints
     */
    getSprints(id: number, includeSprints?: ApiSprintsInclude | undefined): Promise<ApiSprint[]> {
        let url_ = this.baseUrl + "/api/Project/{id}/Sprint?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includeSprints === null)
            throw new Error("The parameter 'includeSprints' cannot be null.");
        else if (includeSprints !== undefined)
            url_ += "includeSprints=" + encodeURIComponent("" + includeSprints) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSprints(_response);
        });
    }

    protected processGetSprints(response: Response): Promise<ApiSprint[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiSprint[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSprint[]>(null as any);
    }

    /**
     * Get agents as list
     * @param projectId The id of project.
     * @return The result contains a list with agents.
     */
    getAgents(projectId: number): Promise<ApiAgentBase[]> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Agent";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAgents(_response);
        });
    }

    protected processGetAgents(response: Response): Promise<ApiAgentBase[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAgentBase[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAgentBase[]>(null as any);
    }

    /**
     * Get top-level folders
     * @param projectId The id of project from which you want to get the folders.
     * @param includePermissions (optional) Indicates whether to include permissions information in each folder. Default is true.
     * @return A flat list of (top level) folders available in the project.
     */
    getFolders(projectId: number, includePermissions?: boolean | undefined): Promise<ApiProjectFolder[]> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Folder?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (includePermissions === null)
            throw new Error("The parameter 'includePermissions' cannot be null.");
        else if (includePermissions !== undefined)
            url_ += "includePermissions=" + encodeURIComponent("" + includePermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFolders(_response);
        });
    }

    protected processGetFolders(response: Response): Promise<ApiProjectFolder[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectFolder[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectFolder[]>(null as any);
    }

    /**
     * Get folder
     * @param projectId The id of the of project to which the folder belongs.
     * @param folderId The id of the folder to fetch.
     * @param includePermissions (optional) Indicates whether to include permissions information. Default is true.
     * @return The project folder.
     */
    getFolder(projectId: number, folderId: number, includePermissions?: boolean | undefined): Promise<ApiProjectFolder> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Folder/{folderId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined.");
        url_ = url_.replace("{folderId}", encodeURIComponent("" + folderId));
        if (includePermissions === null)
            throw new Error("The parameter 'includePermissions' cannot be null.");
        else if (includePermissions !== undefined)
            url_ += "includePermissions=" + encodeURIComponent("" + includePermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFolder(_response);
        });
    }

    protected processGetFolder(response: Response): Promise<ApiProjectFolder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectFolder;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectFolder>(null as any);
    }

    /**
     * Modify folder
     * @param projectId The id of the project.
     * @param folderId The id of the folder.
     * @param operation The modify operation.
     * @return Returns ApiLongOperation that either contains a result of the operation that has been performed synchronously (positive) 
                or guid that represents the move operation that is performed in background.
     */
    modifyFolder(projectId: number, folderId: number, operation: ApiProjectFolderPatchOperation): Promise<ApiLongOperationOfBoolean> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Folder/{folderId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined.");
        url_ = url_.replace("{folderId}", encodeURIComponent("" + folderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(operation);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyFolder(_response);
        });
    }

    protected processModifyFolder(response: Response): Promise<ApiLongOperationOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperationOfBoolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperationOfBoolean>(null as any);
    }

    /**
     * Delete folder
     * @param projectId The id of the project.
     * @param folderId The id of the folder.
     * @param deleteContent (optional) If true, then tries to delete folder content (items) before deleting the folder. 
                Otherwise (deleteContent is false) deletes the folder only if is empty. Default is false.
     */
    deleteFolder(projectId: number, folderId: number, deleteContent?: boolean | undefined): Promise<ApiLongOperation> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Folder/{folderId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined.");
        url_ = url_.replace("{folderId}", encodeURIComponent("" + folderId));
        if (deleteContent === null)
            throw new Error("The parameter 'deleteContent' cannot be null.");
        else if (deleteContent !== undefined)
            url_ += "deleteContent=" + encodeURIComponent("" + deleteContent) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteFolder(_response);
        });
    }

    protected processDeleteFolder(response: Response): Promise<ApiLongOperation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperation;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperation>(null as any);
    }

    /**
     * Get subfolders
     * @param projectId The id of project.
     * @param folderId The id of the parent folder. Use 0 to get top level folders.
     * @param includePermissions (optional) Indicates whether to include permissions information in each folder. Default is true.
     * @param recursive (optional) Indicates whether all folders in a certain folder are loaded (including children of children and so on). Default is false.
     * @return A list of subfolders.
     */
    getSubFolders(projectId: number, folderId: number, includePermissions?: boolean | undefined, recursive?: boolean | undefined): Promise<ApiProjectSubFolder[]> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Folder/{folderId}/Subfolder?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined.");
        url_ = url_.replace("{folderId}", encodeURIComponent("" + folderId));
        if (includePermissions === null)
            throw new Error("The parameter 'includePermissions' cannot be null.");
        else if (includePermissions !== undefined)
            url_ += "includePermissions=" + encodeURIComponent("" + includePermissions) + "&";
        if (recursive === null)
            throw new Error("The parameter 'recursive' cannot be null.");
        else if (recursive !== undefined)
            url_ += "recursive=" + encodeURIComponent("" + recursive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSubFolders(_response);
        });
    }

    protected processGetSubFolders(response: Response): Promise<ApiProjectSubFolder[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectSubFolder[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectSubFolder[]>(null as any);
    }

    /**
     * Modify subfolder collection
     * @param projectId The id of project.
     * @param folderId The id of the parent folder. Zero for root folder.
     * @param operation A patch operation to be performed.
     */
    modifySubfolders(projectId: number, folderId: number, operation: ApiProjectSubfoldersPatchOperation): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Folder/{folderId}/Subfolder";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined.");
        url_ = url_.replace("{folderId}", encodeURIComponent("" + folderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(operation);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifySubfolders(_response);
        });
    }

    protected processModifySubfolders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create folder
     * @param projectId The id of project.
     * @param folderId The id of the parent folder.
     * @param operation New folder details.
     * @return Returns either id of the created folder (when creating from scratch) of LongOperation 
                identifier to track the asynchronous process of the copying. 
                Note: due to limitation, the information returned when tracking LongOperation-s of this type does not contain information about actual numbers,
                contains only jos status.
     */
    createFolder(projectId: number, folderId: number, operation: ApiProjectFolderCreate): Promise<ApiLongOperationOfInteger> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Folder/{folderId}/Subfolder";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined.");
        url_ = url_.replace("{folderId}", encodeURIComponent("" + folderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(operation);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateFolder(_response);
        });
    }

    protected processCreateFolder(response: Response): Promise<ApiLongOperationOfInteger> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperationOfInteger;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperationOfInteger>(null as any);
    }

    /**
     * Get sub and parent folders as list
     * @param projectId The id of project.
     * @param folderId The id of the folder. Use 0 to get top level folders.
     * @param includePermissions (optional) Indicates whether to include permissions information in each folder. Default is true.
     * @return Returned list contains subfolders of a given folder but also subfolders of all folders going "up" in the folder tree. 
                The main purpose of this is to be able to render an expanded folder tree up to the given folder (so all parent folders are expanded as well).
                a list of direct subfolders available in the given folder (optionally also subfolders of parent folders). 
                Returned list is ordered in a way that parent folder is always before the child folder and folders on same level are natural sorted by name.
     */
    getSubFoldersPath(projectId: number, folderId: number, includePermissions?: boolean | undefined): Promise<ApiProjectSubFolder[]> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Folder/{folderId}/SubfolderPath?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined.");
        url_ = url_.replace("{folderId}", encodeURIComponent("" + folderId));
        if (includePermissions === null)
            throw new Error("The parameter 'includePermissions' cannot be null.");
        else if (includePermissions !== undefined)
            url_ += "includePermissions=" + encodeURIComponent("" + includePermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSubFoldersPath(_response);
        });
    }

    protected processGetSubFoldersPath(response: Response): Promise<ApiProjectSubFolder[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectSubFolder[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectSubFolder[]>(null as any);
    }

    /**
     * Search items
     * @param projectId The id of project.
     * @param folderId (optional) The id of the folder. If zero then search through the whole project.
                  This parameter is optional (default is 0).
     * @param searchTerm (optional) The string to seach for. The following wildcards are supported: 
                  _ for a single character, % for zero or more characters. Empty search string returns all elements.
                  This parameter is optional (default is empty).
     * @param itemType (optional) The item type to search for. 
                This parameter is optional (default behavior is to return items of all types).
                Note: if itemType is not provided the result of a call is the aggregation of results retrived for all available item types. 
                The parameters firstResults/maxResults (if provided) are effective in each group separately.
     * @param includeArchived (optional) If true archived items are returned as well (default is false).
     * @param firstResults (optional) Specifies how many items to skip when returning results from list of matching items ordered by last modification date.
                  Usefull for implementing pagination (see also maxResults parameter). 
                  This parameter is optional (default value is 0 which means to not skip any items).
                  Note: if itemType is not specified, the firstResults parameter affects each of results group separately (per separate item type of all found).
     * @param maxResults (optional) Specifies how many items to retrive (from list of matching items ordered by last modification date, 
                  starting from location defined by firstResults). Usefull for implementing pagination. 
                  This parameter is optional (default value is 0 which means to retrive all found items).
                  Note: if itemType is not specified, the maxResults parameter affects each of results group separately (per separate item type of all found).
                  WARNING! if this parameter is not specified, all matching items are returned despite of actual number. 
                  Please use with caution in bigger projects as might lead to performance problems.
     * @param includePermissions (optional) If true permissions are returned as well (default is false).
     * @return The result contains a list with basic information on the found items and some meta information.
                The results are ordered descending by date of last modification.
     */
    searchItems(projectId: number, folderId?: number | undefined, searchTerm?: string | null | undefined, itemType?: ApiItemType | null | undefined, includeArchived?: boolean | undefined, firstResults?: number | undefined, maxResults?: number | undefined, includePermissions?: boolean | undefined): Promise<ApiItemSearchResult> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Item?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (itemType !== undefined && itemType !== null)
            url_ += "itemType=" + encodeURIComponent("" + itemType) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        if (firstResults === null)
            throw new Error("The parameter 'firstResults' cannot be null.");
        else if (firstResults !== undefined)
            url_ += "firstResults=" + encodeURIComponent("" + firstResults) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (includePermissions === null)
            throw new Error("The parameter 'includePermissions' cannot be null.");
        else if (includePermissions !== undefined)
            url_ += "includePermissions=" + encodeURIComponent("" + includePermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchItems(_response);
        });
    }

    protected processSearchItems(response: Response): Promise<ApiItemSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemSearchResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemSearchResult>(null as any);
    }

    /**
     * Get report definitions as list
     * @param projectId The id of the project
     * @param includePermissions (optional) Indicates whether to include permissions information. Default is true.
     */
    getReportDefinitions(projectId: number, includePermissions?: boolean | undefined): Promise<ApiReportDefinitionInfo[]> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/ReportDefinition?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (includePermissions === null)
            throw new Error("The parameter 'includePermissions' cannot be null.");
        else if (includePermissions !== undefined)
            url_ += "includePermissions=" + encodeURIComponent("" + includePermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetReportDefinitions(_response);
        });
    }

    protected processGetReportDefinitions(response: Response): Promise<ApiReportDefinitionInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiReportDefinitionInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiReportDefinitionInfo[]>(null as any);
    }

    /**
     * Import report defintions
     * @param projectId The id of the project where the reports should be imported.
     * @param request The request containing a list of uploaded report definitions and the patch operation.
     */
    importReportDefinition(projectId: number, request: ApiReportPatchOperation): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/ReportDefinition";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImportReportDefinition(_response);
        });
    }

    protected processImportReportDefinition(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Import report definition
     * @param projectId The id of the project.
     * @param fileName (optional) The file name to use. This parameter is optional. If it is not
                specified the file name from the multi part form data will be used.
     * @param file (optional) 
     * @return The metadata of the uploaded file.
     */
    importSingleReportDefinition(projectId: number, fileName?: string | null | undefined, file?: FileParameter[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/ReportDefinition/Transfer?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImportSingleReportDefinition(_response);
        });
    }

    protected processImportSingleReportDefinition(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get report plugins as list
     * @param projectId The id of project.
     * @return The result contains a list with report plugins.
     */
    getReportPlugins(projectId: number): Promise<ApiReportPlugin[]> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/ReportPlugin";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetReportPlugins(_response);
        });
    }

    protected processGetReportPlugins(response: Response): Promise<ApiReportPlugin[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiReportPlugin[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiReportPlugin[]>(null as any);
    }

    /**
     * Get requirement information as list
     * @param projectId The id of project.
     * @param startAt (optional) The index of the first result to include. This allows to skip items which are not included in the response. Can be used to implement pagination. This parameter is optional and default is 0.
     * @param maxResults (optional) The maximum number of results to return. This parameter is optional and default is 0.
     * @return The result contains a list with basic information on the items and some meta information.
     * @deprecated
     */
    getRequirements(projectId: number, startAt?: number | null | undefined, maxResults?: number | null | undefined): Promise<ApiPaginatedResultOfApiItemInfo> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Requirement?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (startAt !== undefined && startAt !== null)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults !== undefined && maxResults !== null)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRequirements(_response);
        });
    }

    protected processGetRequirements(response: Response): Promise<ApiPaginatedResultOfApiItemInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPaginatedResultOfApiItemInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPaginatedResultOfApiItemInfo>(null as any);
    }

    /**
     * Get project users as list
     * @param projectId The id of a project.
     * @param filter (optional) If provided then only users containing the given string are returned. Default value is null (no filter).
     * @param startAt (optional) Indicates how many users to skip (useful for implementing pagination). 
                This parameter is optional, default value is 0, what means not to skip anything.
     * @param maxResults (optional) Indicates how many users should be returned. 
                This parameter is optional, default value is 0, what indicates returning all found users.
     * @return Returns a list of available users in given project.
     */
    getUsers(projectId: number, filter?: string | null | undefined, startAt?: number | undefined, maxResults?: number | undefined): Promise<ApiUserInfo[]> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/User?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: Response): Promise<ApiUserInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUserInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiUserInfo[]>(null as any);
    }

    /**
     * Create user role assignment
     * @param projectId The id of the project.
     */
    createUserAssignment(projectId: number, assignementCreate: ApiUserProjectFolderAssignment): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/UserAssignment";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assignementCreate);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateUserAssignment(_response);
        });
    }

    protected processCreateUserAssignment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete user role assignment
     * @param projectId The id of the project.
     * @param userId The id of the user.
     * @param folderId (optional) The id of the folder.
     * @param cascadeDelete (optional) Indicates whether the deletion is cascaded. When this flag is true and a project-level
                role assignment for a certain user is deleted, all folder-level role assignments are deleted as well.
     */
    deleteUserAssignment(projectId: number, userId: number, folderId?: number | undefined, cascadeDelete?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/UserAssignment?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (cascadeDelete === null)
            throw new Error("The parameter 'cascadeDelete' cannot be null.");
        else if (cascadeDelete !== undefined)
            url_ += "cascadeDelete=" + encodeURIComponent("" + cascadeDelete) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteUserAssignment(_response);
        });
    }

    protected processDeleteUserAssignment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get user role assignments
     * @param projectId The id of the project.
     * @param folderId (optional) The id of the folder.
     * @param recursive (optional) This flag is only applicable on project level, it indicates that all assignments (folder level) will be integrated in the response.
     */
    getUserAssignments(projectId: number, folderId?: number | undefined, recursive?: boolean | undefined): Promise<ApiGetUserAssignmentResponse> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/UserAssignment?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (recursive === null)
            throw new Error("The parameter 'recursive' cannot be null.");
        else if (recursive !== undefined)
            url_ += "recursive=" + encodeURIComponent("" + recursive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserAssignments(_response);
        });
    }

    protected processGetUserAssignments(response: Response): Promise<ApiGetUserAssignmentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiGetUserAssignmentResponse;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiGetUserAssignmentResponse>(null as any);
    }

    /**
     * Modify user role assignment
     * @param projectId The id of the project.
     * @param operation The modify operation.
     * @param userId The id of the user.
     * @param folderId (optional) The id of the folder.
     */
    modifyUserAssignment(projectId: number, operation: ApiUserProjectFolderAssignmentPatchOperation, userId: number, folderId?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/UserAssignment?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(operation);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyUserAssignment(_response);
        });
    }

    protected processModifyUserAssignment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Modify user role assignments
     * @param projectId The id of the project.
     * @param update Update data
     * @param cascadeDelete (optional) Indicates whether the deletion is cascaded. When this flag is true and a project-level
                role assignment for a certain user is deleted, all folder-level role assignments are deleted as well.
     */
    createFolderUserRoles(projectId: number, update: ApiProjectUpdateProjectFolderRolesRequest, cascadeDelete?: boolean | undefined): Promise<ApiProjectUpdateProjectFolderRolesResponse> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/UserRoles?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (cascadeDelete === null)
            throw new Error("The parameter 'cascadeDelete' cannot be null.");
        else if (cascadeDelete !== undefined)
            url_ += "cascadeDelete=" + encodeURIComponent("" + cascadeDelete) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateFolderUserRoles(_response);
        });
    }

    protected processCreateFolderUserRoles(response: Response): Promise<ApiProjectUpdateProjectFolderRolesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectUpdateProjectFolderRolesResponse;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectUpdateProjectFolderRolesResponse>(null as any);
    }

    /**
     * Get user views as list
     * @param projectId The id of the project.
     * @param includePermissions (optional) Indicates if permissions are loaded.
     * @param restrictToType (optional) Restrict the user views to this item type.
     */
    getUserViews(projectId: number, includePermissions?: boolean | undefined, restrictToType?: ApiItemType | null | undefined): Promise<ApiUserViewInfo[]> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/UserView?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (includePermissions === null)
            throw new Error("The parameter 'includePermissions' cannot be null.");
        else if (includePermissions !== undefined)
            url_ += "includePermissions=" + encodeURIComponent("" + includePermissions) + "&";
        if (restrictToType !== undefined && restrictToType !== null)
            url_ += "restrictToType=" + encodeURIComponent("" + restrictToType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserViews(_response);
        });
    }

    protected processGetUserViews(response: Response): Promise<ApiUserViewInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUserViewInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiUserViewInfo[]>(null as any);
    }
}

export class ProjectMetaClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get item type field rules
     * @param projectId The id of the project for which the field rules are requested.
     * @param itemType The item type for which the field rules are requested.
     * @return A list with all field rules for the specified item type in the specified project.
     */
    getFieldRules2(projectId: number, itemType: ApiItemType): Promise<ApiFieldRulesWithOwnership> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/{itemType}/FieldRules";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined.");
        url_ = url_.replace("{itemType}", encodeURIComponent("" + itemType));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFieldRules2(_response);
        });
    }

    protected processGetFieldRules2(response: Response): Promise<ApiFieldRulesWithOwnership> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiFieldRulesWithOwnership;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiFieldRulesWithOwnership>(null as any);
    }

    /**
     * Replace item type field rules
     * @param projectId The id of the project in which the field rules are replaces.
     * @param itemType The item type for which the field rules are replaced.
     * @param update The changes which should be applied to the field rules.
     */
    replaceFieldRules(projectId: number, itemType: ApiItemType, update: ApiFieldRulesUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/{itemType}/FieldRules";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined.");
        url_ = url_.replace("{itemType}", encodeURIComponent("" + itemType));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReplaceFieldRules(_response);
        });
    }

    protected processReplaceFieldRules(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get fields meta-data as list
     * @param projectId The id of the project to look in
     * @param itemType The type of the item (Defect, Requirement etc.)
     * @param includeRichTextFields (optional) Indicates whether richtext fields should be included
     * @param sortMode (optional) The way in which the fields are sorted
     * @param includeDeactivated (optional) Indicates whether deactivated fields should be included
     * @return The list of fields
     */
    getProjectFieldsMeta(projectId: number, itemType: ApiItemType, includeRichTextFields?: boolean | undefined, sortMode?: ApiFieldSortMode | undefined, includeDeactivated?: boolean | undefined): Promise<ApiFieldMeta[]> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/{itemType}/Fields?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined.");
        url_ = url_.replace("{itemType}", encodeURIComponent("" + itemType));
        if (includeRichTextFields === null)
            throw new Error("The parameter 'includeRichTextFields' cannot be null.");
        else if (includeRichTextFields !== undefined)
            url_ += "includeRichTextFields=" + encodeURIComponent("" + includeRichTextFields) + "&";
        if (sortMode === null)
            throw new Error("The parameter 'sortMode' cannot be null.");
        else if (sortMode !== undefined)
            url_ += "sortMode=" + encodeURIComponent("" + sortMode) + "&";
        if (includeDeactivated === null)
            throw new Error("The parameter 'includeDeactivated' cannot be null.");
        else if (includeDeactivated !== undefined)
            url_ += "includeDeactivated=" + encodeURIComponent("" + includeDeactivated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProjectFieldsMeta(_response);
        });
    }

    protected processGetProjectFieldsMeta(response: Response): Promise<ApiFieldMeta[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiFieldMeta[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiFieldMeta[]>(null as any);
    }

    /**
     * Get field meta-data
     * @param projectId Id of the project to look in
     * @param itemType Type of the item (Defect, Requirement etc.)
     * @param fieldId PropertyName of a field to be retrieved
     * @param includeDeactivated (optional) Indicates whether deactivated fields should be included
     * @return The requested field
     */
    getProjectFieldMeta(projectId: number, itemType: ApiItemType, fieldId: string | null, includeDeactivated?: boolean | undefined): Promise<ApiFieldMeta> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/{itemType}/Fields/{fieldId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined.");
        url_ = url_.replace("{itemType}", encodeURIComponent("" + itemType));
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (includeDeactivated === null)
            throw new Error("The parameter 'includeDeactivated' cannot be null.");
        else if (includeDeactivated !== undefined)
            url_ += "includeDeactivated=" + encodeURIComponent("" + includeDeactivated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProjectFieldMeta(_response);
        });
    }

    protected processGetProjectFieldMeta(response: Response): Promise<ApiFieldMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiFieldMeta;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiFieldMeta>(null as any);
    }

    /**
     * Get dictionary entries
     * @param projectId The id of the project for which the set of dictionary entries is retrieved.
     * @param itemType The item type for which the set of dictionary entries is retrieved.
     * @param fieldId The id of the field for which the set of dictionary entries is retrieved.
                The field must be a dictionary field. The id of a field is its internal property name.
     * @return The set of dictionary entries of the specified field including some metadata.
     */
    getProjectFieldDictionaryEntries(projectId: number, itemType: ApiItemType, fieldId: string | null): Promise<ApiProjectTemplateDictionary> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/{itemType}/Fields/{fieldId}/Entries";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined.");
        url_ = url_.replace("{itemType}", encodeURIComponent("" + itemType));
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProjectFieldDictionaryEntries(_response);
        });
    }

    protected processGetProjectFieldDictionaryEntries(response: Response): Promise<ApiProjectTemplateDictionary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectTemplateDictionary;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectTemplateDictionary>(null as any);
    }

    /**
     * Add dictionary entry
     * @param projectId The id of the project to which the dictionary entry is added.
     * @param itemType The item type to which the dictionary entry is added.
     * @param fieldId The id of the field to which the dictionary entry is added. The field
                must be a dictionary field. The id of a field is its internal property name.
     * @param entry The new dictionary entry which should be added to the dictionary.
     */
    addProjectFieldDictionaryEntry(projectId: number, itemType: ApiItemType, fieldId: string | null, entry: ApiProjectTemplateDictionaryEntryNew): Promise<ApiProjectTemplateDictionaryEntry> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/{itemType}/Fields/{fieldId}/Entries";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined.");
        url_ = url_.replace("{itemType}", encodeURIComponent("" + itemType));
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entry);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddProjectFieldDictionaryEntry(_response);
        });
    }

    protected processAddProjectFieldDictionaryEntry(response: Response): Promise<ApiProjectTemplateDictionaryEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectTemplateDictionaryEntry;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectTemplateDictionaryEntry>(null as any);
    }

    /**
     * Replace dictionary entries
     * @param projectId The id of the project for which the dictionary values are modified.
     * @param itemType The item type for which the dictionary values are modified.
     * @param fieldId The id of the field for which the dictionary values are modified. The field
                must be a dictionary field. The id of a field is its internal property name.
     * @param updatedDictionary The modified dictionary values which should be saved.
     */
    updateProjectFieldDictionaryEntries(projectId: number, itemType: ApiItemType, fieldId: string | null, updatedDictionary: ApiProjectTemplateDictionaryUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/{itemType}/Fields/{fieldId}/Entries";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined.");
        url_ = url_.replace("{itemType}", encodeURIComponent("" + itemType));
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedDictionary);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateProjectFieldDictionaryEntries(_response);
        });
    }

    protected processUpdateProjectFieldDictionaryEntries(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get field rules
     * @param projectId The id of the project for which the field rules are requested.
     * @return A list with all field rules for all item types in the specified project.
     */
    getFieldRules(projectId: number): Promise<ApiProjectFieldRules> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/FieldRules";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFieldRules(_response);
        });
    }

    protected processGetFieldRules(response: Response): Promise<ApiProjectFieldRules> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectFieldRules;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectFieldRules>(null as any);
    }

    /**
     * Update field rules
     * @param projectId The id of the project in which the field rules are modified.
     * @param update The changes which should be applied to the field rules.
     */
    modifyFieldRules(projectId: number, update: ApiProjectFieldRulesUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/FieldRules";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyFieldRules(_response);
        });
    }

    protected processModifyFieldRules(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Modify fields
     * @param projectId Id of the project to look in.
     * @param patchOperations The requested patchoperations.
     * @param forceLayoutChange (optional) indicates that the changes should be made even though they causes
                significant changes to layout in desktop client accordingly.
     */
    modifyFields(projectId: number, patchOperations: ApiFieldPatchOperation[], forceLayoutChange?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/Fields?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (forceLayoutChange === null)
            throw new Error("The parameter 'forceLayoutChange' cannot be null.");
        else if (forceLayoutChange !== undefined)
            url_ += "forceLayoutChange=" + encodeURIComponent("" + forceLayoutChange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patchOperations);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyFields(_response);
        });
    }

    protected processModifyFields(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get notification rules as list
     * @param projectId The id of the project.
     */
    getProjectDefaultNotificationRule(projectId: number): Promise<ApiProjectNotificationRule[]> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/NotificationRule";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProjectDefaultNotificationRule(_response);
        });
    }

    protected processGetProjectDefaultNotificationRule(response: Response): Promise<ApiProjectNotificationRule[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectNotificationRule[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectNotificationRule[]>(null as any);
    }

    /**
     * Replace notification rule
     * @param projectId The id of the project.
     * @param newRules Necessary information to create a new default notification rules.
     */
    updateProjectDefaultNotificationRule(projectId: number, newRules: ApiFolderNotificationRuleReplacementWithType[]): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/NotificationRule";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newRules);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateProjectDefaultNotificationRule(_response);
        });
    }

    protected processUpdateProjectDefaultNotificationRule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get setting options
     * @param projectId The id of the project.
     */
    getProjectOptions(projectId: number): Promise<ApiProjectOptionsWithOwnership> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/Options";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProjectOptions(_response);
        });
    }

    protected processGetProjectOptions(response: Response): Promise<ApiProjectOptionsWithOwnership> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectOptionsWithOwnership;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectOptionsWithOwnership>(null as any);
    }

    /**
     * Replace setting options
     * @param projectId The id of the project.
     * @param apiProjectOptions The new options of the project.
     */
    saveProjectOptions(projectId: number, apiProjectOptions: ApiProjectOptions): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/Options";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiProjectOptions);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveProjectOptions(_response);
        });
    }

    protected processSaveProjectOptions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get project template info
     * @param projectId Id of the project to look in.
     */
    getProjectTemplateInfos(projectId: number): Promise<ApiProjectTemplateInformation> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/ProjectTemplateInfo";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProjectTemplateInfos(_response);
        });
    }

    protected processGetProjectTemplateInfos(response: Response): Promise<ApiProjectTemplateInformation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectTemplateInformation;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectTemplateInformation>(null as any);
    }

    /**
     * Get shared dictionaries as list
     * @param projectId The id of the project to look in.
     * @param includeEntries (optional) If true then returned dictionaries include also entries (default: true).
     * @return The list of shared dictionaries in the project with/without entries
     */
    getSharedDictionaries(projectId: number, includeEntries?: boolean | undefined): Promise<ApiProjectTemplateDictionaryWithUsage[]> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/SharedDictionary?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (includeEntries === null)
            throw new Error("The parameter 'includeEntries' cannot be null.");
        else if (includeEntries !== undefined)
            url_ += "includeEntries=" + encodeURIComponent("" + includeEntries) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSharedDictionaries(_response);
        });
    }

    protected processGetSharedDictionaries(response: Response): Promise<ApiProjectTemplateDictionaryWithUsage[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectTemplateDictionaryWithUsage[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectTemplateDictionaryWithUsage[]>(null as any);
    }

    /**
     * Create shared dictionary
     * @param projectId The id of the project.
     * @param newDictionary Data of new dictionary to be created.
     */
    createSharedDictionary(projectId: number, newDictionary: ApiProjectTemplateDictionaryNew): Promise<ApiProjectTemplateDictionary> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/SharedDictionary";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newDictionary);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateSharedDictionary(_response);
        });
    }

    protected processCreateSharedDictionary(response: Response): Promise<ApiProjectTemplateDictionary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectTemplateDictionary;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectTemplateDictionary>(null as any);
    }

    /**
     * Get shared dictionary
     * @param projectId The id of the project.
     * @param dictionaryId The id of the dictionary.
     * @return Shared dictionary defined in given project identified by given Id.
     */
    getSharedDictionary(projectId: number, dictionaryId: number): Promise<ApiProjectTemplateDictionaryWithUsage> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/SharedDictionary/{dictionaryId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (dictionaryId === undefined || dictionaryId === null)
            throw new Error("The parameter 'dictionaryId' must be defined.");
        url_ = url_.replace("{dictionaryId}", encodeURIComponent("" + dictionaryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSharedDictionary(_response);
        });
    }

    protected processGetSharedDictionary(response: Response): Promise<ApiProjectTemplateDictionaryWithUsage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectTemplateDictionaryWithUsage;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectTemplateDictionaryWithUsage>(null as any);
    }

    /**
     * Delete shared dictionary
     * @param projectId The id of the project.
     * @param dictionaryId The id of the dictionary.
     */
    deleteSharedDictionary(projectId: number, dictionaryId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/SharedDictionary/{dictionaryId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (dictionaryId === undefined || dictionaryId === null)
            throw new Error("The parameter 'dictionaryId' must be defined.");
        url_ = url_.replace("{dictionaryId}", encodeURIComponent("" + dictionaryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteSharedDictionary(_response);
        });
    }

    protected processDeleteSharedDictionary(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update shared dictionary
     * @param projectId The id of the project.
     * @param dictionaryId The id of the dictionary.
     * @param updatedDictionary The data of the shared dictionary wich should be updated.
     */
    updateSharedDictionary(projectId: number, dictionaryId: number, updatedDictionary: ApiProjectTemplateDictionaryUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/SharedDictionary/{dictionaryId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (dictionaryId === undefined || dictionaryId === null)
            throw new Error("The parameter 'dictionaryId' must be defined.");
        url_ = url_.replace("{dictionaryId}", encodeURIComponent("" + dictionaryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedDictionary);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateSharedDictionary(_response);
        });
    }

    protected processUpdateSharedDictionary(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Export configuration
     * @param projectId The id of the project of which the configuration should be exported
     * @return The file containing the exported project configuration
     */
    export(projectId: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/Transfer";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Import configuration
     * @param projectId The id of the project to which the project configuration should be imported
     * @param itemTypes (optional) The item types to import as comma-separated list.
                By default, all item types are imported.
                Possible values for item type are: Defect, Requirement, TestCase, TestScenario, TestExecution and Script.
     * @param importSubtemplates (optional) Indicates whether sub templates should be imported.
                By default, sub templates are imported
     * @param importWorkflows (optional) Indicates whether workflows should be imported.
                By default, workflows are imported
     * @param file (optional) 
     */
    importFromFile(projectId: number, itemTypes?: string | null | undefined, importSubtemplates?: boolean | undefined, importWorkflows?: boolean | undefined, file?: FileParameter[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/Transfer?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemTypes !== undefined && itemTypes !== null)
            url_ += "itemTypes=" + encodeURIComponent("" + itemTypes) + "&";
        if (importSubtemplates === null)
            throw new Error("The parameter 'importSubtemplates' cannot be null.");
        else if (importSubtemplates !== undefined)
            url_ += "importSubtemplates=" + encodeURIComponent("" + importSubtemplates) + "&";
        if (importWorkflows === null)
            throw new Error("The parameter 'importWorkflows' cannot be null.");
        else if (importWorkflows !== undefined)
            url_ += "importWorkflows=" + encodeURIComponent("" + importWorkflows) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImportFromFile(_response);
        });
    }

    protected processImportFromFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Import configuration
     * @param projectId The id of the project to which the project configuration should be imported
     * @param projectConfig The file which contains the project configuration to import.
    The file should be uploaded to the endpoint
    [UploadFile](#operation/File_UploadFile)
    first.
     * @param itemTypes (optional) The item types to import as comma-separated list.
                By default, all item types are imported.
                Possible values for item type are: Defect, Requirement, TestCase, TestScenario, TestExecution and Script.
     * @param importSubtemplates (optional) Indicates whether sub templates should be imported.
                By default, sub templates are imported
     * @param importWorkflows (optional) Indicates whether workflows should be imported.
                By default, workflows are imported
     */
    import(projectId: number, projectConfig: ApiFileUploadInfo, itemTypes?: string | null | undefined, importSubtemplates?: boolean | undefined, importWorkflows?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/Transfer?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemTypes !== undefined && itemTypes !== null)
            url_ += "itemTypes=" + encodeURIComponent("" + itemTypes) + "&";
        if (importSubtemplates === null)
            throw new Error("The parameter 'importSubtemplates' cannot be null.");
        else if (importSubtemplates !== undefined)
            url_ += "importSubtemplates=" + encodeURIComponent("" + importSubtemplates) + "&";
        if (importWorkflows === null)
            throw new Error("The parameter 'importWorkflows' cannot be null.");
        else if (importWorkflows !== undefined)
            url_ += "importWorkflows=" + encodeURIComponent("" + importWorkflows) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectConfig);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImport(_response);
        });
    }

    protected processImport(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Import configuration preview
     * @param projectId The id of the project to which the project configuration should be imported.
     * @param projectConfig The file which contains the project configuration to import.
    The file should be uploaded to the endpoint
    [UploadFile](#operation/File_UploadFile)
    first.
     * @param itemTypes (optional) The item types to import as comma-separated list.
                Possible values for item type are: Defect, Requirement, TestCase, TestScenario and Script.
     * @param importSubtemplates (optional) Indicates whether sub templates should be imported.
                By default, sub templates are imported
     * @param importWorkflows (optional) Indicates whether workflows should be imported.
                By default, workflows are imported
     */
    importPreview(projectId: number, projectConfig: ApiFileUploadInfo, itemTypes?: string | null | undefined, importSubtemplates?: boolean | undefined, importWorkflows?: boolean | undefined): Promise<ApiImportProjectTemplatePreviewResponse> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Meta/Transfer/Preview?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemTypes !== undefined && itemTypes !== null)
            url_ += "itemTypes=" + encodeURIComponent("" + itemTypes) + "&";
        if (importSubtemplates === null)
            throw new Error("The parameter 'importSubtemplates' cannot be null.");
        else if (importSubtemplates !== undefined)
            url_ += "importSubtemplates=" + encodeURIComponent("" + importSubtemplates) + "&";
        if (importWorkflows === null)
            throw new Error("The parameter 'importWorkflows' cannot be null.");
        else if (importWorkflows !== undefined)
            url_ += "importWorkflows=" + encodeURIComponent("" + importWorkflows) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectConfig);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImportPreview(_response);
        });
    }

    protected processImportPreview(response: Response): Promise<ApiImportProjectTemplatePreviewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiImportProjectTemplatePreviewResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiImportProjectTemplatePreviewResponse>(null as any);
    }
}

export class ProjectNotificationClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get notification templates
     * @param projectId The id of the project to look in
     */
    getProjectNotificationTemplates(projectId: number): Promise<ApiProjectNotificationTemplates> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Notification/Templates";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProjectNotificationTemplates(_response);
        });
    }

    protected processGetProjectNotificationTemplates(response: Response): Promise<ApiProjectNotificationTemplates> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectNotificationTemplates;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectNotificationTemplates>(null as any);
    }

    /**
     * Replace notification templates
     * @param projectId Id of the project to save templates in
     * @param templates Data of templates to be saved
     */
    saveProjectNotificationTemplates(projectId: number, templates: ApiProjectNotificationTemplate[]): Promise<void> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Notification/Templates";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(templates);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveProjectNotificationTemplates(_response);
        });
    }

    protected processSaveProjectNotificationTemplates(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Export notification templates
     * @param projectId The id of project
     * @return The content of email notification templates
     */
    exportProjectNotificationTemplates(projectId: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Notification/Templates/Transfer";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExportProjectNotificationTemplates(_response);
        });
    }

    protected processExportProjectNotificationTemplates(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Import notification templates
     * @param projectId The id of the project to which the notification templates are imported
     * @param file (optional) 
     */
    importProjectNotificationTemplates(projectId: number, file?: FileParameter[] | undefined): Promise<ApiProjectNotificationTemplates> {
        let url_ = this.baseUrl + "/api/Project/{projectId}/Notification/Templates/Transfer";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImportProjectNotificationTemplates(_response);
        });
    }

    protected processImportProjectNotificationTemplates(response: Response): Promise<ApiProjectNotificationTemplates> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectNotificationTemplates;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectNotificationTemplates>(null as any);
    }
}

export class ReportClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Create lock
     * @param reportId The id of the report to lock
     */
    createLock(reportId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Report/{reportId}/Lock";
        if (reportId === undefined || reportId === null)
            throw new Error("The parameter 'reportId' must be defined.");
        url_ = url_.replace("{reportId}", encodeURIComponent("" + reportId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateLock(_response);
        });
    }

    protected processCreateLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete lock
     * @param reportId The id of the report for which the lock should be released
     */
    deleteLock(reportId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Report/{reportId}/Lock";
        if (reportId === undefined || reportId === null)
            throw new Error("The parameter 'reportId' must be defined.");
        url_ = url_.replace("{reportId}", encodeURIComponent("" + reportId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteLock(_response);
        });
    }

    protected processDeleteLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get report options
     * @param reportId The id of the report
     * @param includeParameter (optional) If true the report includes parameter as well, this will significantly slow down the end point.
     * @return Report options
     */
    getReportOptions(reportId: number, includeParameter?: boolean | undefined): Promise<ApiReportOptions> {
        let url_ = this.baseUrl + "/api/Report/{reportId}/Options?";
        if (reportId === undefined || reportId === null)
            throw new Error("The parameter 'reportId' must be defined.");
        url_ = url_.replace("{reportId}", encodeURIComponent("" + reportId));
        if (includeParameter === null)
            throw new Error("The parameter 'includeParameter' cannot be null.");
        else if (includeParameter !== undefined)
            url_ += "includeParameter=" + encodeURIComponent("" + includeParameter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetReportOptions(_response);
        });
    }

    protected processGetReportOptions(response: Response): Promise<ApiReportOptions> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiReportOptions;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiReportOptions>(null as any);
    }

    /**
     * Update report
     * @param reportId The id of the report definition
     * @param optionsUpdate This object contains the updated report options
     * @param explicitLock (optional) If true, indicates the report is expected to be already locked by the current user and the lock will not be released after the operation finishes.
                If explicitLock is 'false' then we try to automatically get edit lock (if possible) and then release it after the operation finishes
     */
    updateReportDefinitionOptions(reportId: number, optionsUpdate: ApiReportOptionsUpdate, explicitLock?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Report/{reportId}/Options?";
        if (reportId === undefined || reportId === null)
            throw new Error("The parameter 'reportId' must be defined.");
        url_ = url_.replace("{reportId}", encodeURIComponent("" + reportId));
        if (explicitLock === null)
            throw new Error("The parameter 'explicitLock' cannot be null.");
        else if (explicitLock !== undefined)
            url_ += "explicitLock=" + encodeURIComponent("" + explicitLock) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(optionsUpdate);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateReportDefinitionOptions(_response);
        });
    }

    protected processUpdateReportDefinitionOptions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create report
     * @param createRequest This object contains the report details
     * @return Id of the created report
     */
    createReportDefinition(createRequest: ApiReportCreateRequest): Promise<number> {
        let url_ = this.baseUrl + "/api/Report/Definition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateReportDefinition(_response);
        });
    }

    protected processCreateReportDefinition(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Modify the collection of reports
     * @param update Contains the relevant data to perform an update on the definition collection
     */
    updateReportDefinitionCollection(update: ApiReportDefinitionPatchCollectionOperation): Promise<ApiReportDefinitionPatchCollectionResponse> {
        let url_ = this.baseUrl + "/api/Report/Definition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateReportDefinitionCollection(_response);
        });
    }

    protected processUpdateReportDefinitionCollection(response: Response): Promise<ApiReportDefinitionPatchCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiReportDefinitionPatchCollectionResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiReportDefinitionPatchCollectionResponse>(null as any);
    }

    /**
     * Delete report
     * @param reportId The id of the report definition to be deleted
     */
    deleteReportDefinition(reportId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Report/Definition/{reportId}";
        if (reportId === undefined || reportId === null)
            throw new Error("The parameter 'reportId' must be defined.");
        url_ = url_.replace("{reportId}", encodeURIComponent("" + reportId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteReportDefinition(_response);
        });
    }

    protected processDeleteReportDefinition(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Modify report
     * @param reportId The id of the report definition to be modified
     * @param request Request containing the type for the report definition modify operation
     */
    publishReportDefinition(reportId: number, request: ApiReportDefinitionPatchRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/Report/Definition/{reportId}";
        if (reportId === undefined || reportId === null)
            throw new Error("The parameter 'reportId' must be defined.");
        url_ = url_.replace("{reportId}", encodeURIComponent("" + reportId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPublishReportDefinition(_response);
        });
    }

    protected processPublishReportDefinition(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get edit status
     * @param reportId The id of the report definition.
     */
    getEditStatus(reportId: number): Promise<ApiEditStatus> {
        let url_ = this.baseUrl + "/api/Report/Definition/{reportId}/EditStatus";
        if (reportId === undefined || reportId === null)
            throw new Error("The parameter 'reportId' must be defined.");
        url_ = url_.replace("{reportId}", encodeURIComponent("" + reportId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEditStatus(_response);
        });
    }

    protected processGetEditStatus(response: Response): Promise<ApiEditStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiEditStatus;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiEditStatus>(null as any);
    }

    /**
     * Get report
     * @param reportId The id of the report definition
     * @return The content of the report definition
     */
    exportReportDefinition(reportId: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Report/Definition/{reportId}/Transfer";
        if (reportId === undefined || reportId === null)
            throw new Error("The parameter 'reportId' must be defined.");
        url_ = url_.replace("{reportId}", encodeURIComponent("" + reportId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExportReportDefinition(_response);
        });
    }

    protected processExportReportDefinition(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Create report printout
     * @param request Report id, source data specification and report options
     * @return Stream containing the generated printout data in requested format.
     */
    createReportFile(request: ApiReportPrintoutRequestFile): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Report/FilePrintout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateReportFile(_response);
        });
    }

    protected processCreateReportFile(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class RequirementClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Create requirement
     * @param newItem The data for the new requirement which should be created.
     * @param applyDefaultValues (optional) Indicates whether default values should be applied for fields which are not included in the request.
     * @return Basic information on the new requirement.
     */
    create(newItem: ApiItemNewWithDescription, applyDefaultValues?: boolean | undefined): Promise<ApiItemInfo> {
        let url_ = this.baseUrl + "/api/Requirement?";
        if (applyDefaultValues === null)
            throw new Error("The parameter 'applyDefaultValues' cannot be null.");
        else if (applyDefaultValues !== undefined)
            url_ += "applyDefaultValues=" + encodeURIComponent("" + applyDefaultValues) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newItem);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ApiItemInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemInfo>(null as any);
    }

    /**
     * Modify requirement collection
     * @param batchOperation The batch operation to perform.
     */
    performBatchOperation(batchOperation: ApiBatchOperation): Promise<void> {
        let url_ = this.baseUrl + "/api/Requirement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(batchOperation);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPerformBatchOperation(_response);
        });
    }

    protected processPerformBatchOperation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Modify requirement collection
     * @param patchRequest Operation details.
     * @return Guid of the batch operation. 
    Status of the the operation can be retrieved using GET api/System/LongOperation/{guid}/Status or GET api/System/LongOperation/{guid}.
    In case of this batch operation the data retrieved from 'GET api/System/LongOperation/{guid}' contains additional information 
    as defined in ApiItemLongOperationInfo (FailedItems).
    Additionally, you SignalR (group "LongOperation_{customerId}_{guid}") can be used to receive information when operation finishes.
     */
    modifyItems(patchRequest: ApiItemsPatchRequest): Promise<ApiLongOperationOfBoolean> {
        let url_ = this.baseUrl + "/api/Requirement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patchRequest);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyItems(_response);
        });
    }

    protected processModifyItems(response: Response): Promise<ApiLongOperationOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperationOfBoolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperationOfBoolean>(null as any);
    }

    /**
     * Get requirement
     * @param id The id of the requirement as integer (without RQ).
     * @param withEditableInfo (optional) Indicates whether information about the
                edit lock should be included.
     * @param withEditLayout (optional) Indicates whether information about the edit layout should be included.
                Edit layout is a superset of view layout (you don't have to specify withViewLayout) and contains all information 
                required to display and edit the item.
     * @param withViewLayout (optional) Indicates whether information about the
                view layout should be included. The view layout is a subset of edit layout and 
                contains all information required to display the item.
     * @return The requested requirement.
     */
    get(id: number, withEditableInfo?: boolean | undefined, withEditLayout?: boolean | undefined, withViewLayout?: boolean | undefined): Promise<ApiRequirement> {
        let url_ = this.baseUrl + "/api/Requirement/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (withEditableInfo === null)
            throw new Error("The parameter 'withEditableInfo' cannot be null.");
        else if (withEditableInfo !== undefined)
            url_ += "withEditableInfo=" + encodeURIComponent("" + withEditableInfo) + "&";
        if (withEditLayout === null)
            throw new Error("The parameter 'withEditLayout' cannot be null.");
        else if (withEditLayout !== undefined)
            url_ += "withEditLayout=" + encodeURIComponent("" + withEditLayout) + "&";
        if (withViewLayout === null)
            throw new Error("The parameter 'withViewLayout' cannot be null.");
        else if (withViewLayout !== undefined)
            url_ += "withViewLayout=" + encodeURIComponent("" + withViewLayout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ApiRequirement> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRequirement;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRequirement>(null as any);
    }

    /**
     * Update requirement
     * @param id The id of the requirement to modify.
     * @param update This object contains the changes which should be performed.
     * @param explicitLock (optional) Indicates that the requirement has been explicitly locked before this request.
     * @param applyDefaultValues (optional) Indicates whether default values should be applied for fields which are not included in the request.
     */
    update(id: number, update: ApiItemUpdateWithDescription, explicitLock?: boolean | undefined, applyDefaultValues?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Requirement/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (explicitLock === null)
            throw new Error("The parameter 'explicitLock' cannot be null.");
        else if (explicitLock !== undefined)
            url_ += "explicitLock=" + encodeURIComponent("" + explicitLock) + "&";
        if (applyDefaultValues === null)
            throw new Error("The parameter 'applyDefaultValues' cannot be null.");
        else if (applyDefaultValues !== undefined)
            url_ += "applyDefaultValues=" + encodeURIComponent("" + applyDefaultValues) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete requirement
     * @param id The id of the requirement.
     */
    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Requirement/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get attachments metadata as list
     * @param id The id of the requirement.
     * @return A list with meta information on all the attachments of this requirement.
     */
    getAttachments(id: number): Promise<ApiAttachmentInfo[]> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Attachment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachments(_response);
        });
    }

    protected processGetAttachments(response: Response): Promise<ApiAttachmentInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo[]>(null as any);
    }

    /**
     * Create attachment
     * @param id The id of the requirement.
     * @param filename (optional) The filename of the attachment. This parameter is optional. If it
                is not specified, the file name from the multi part form data will be used.
     * @param file (optional) 
     * @return The metadata of the created attachment.
     */
    addAttachment(id: number, filename?: string | null | undefined, file?: FileParameter[] | undefined): Promise<ApiAttachmentInfo> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Attachment?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (filename !== undefined && filename !== null)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddAttachment(_response);
        });
    }

    protected processAddAttachment(response: Response): Promise<ApiAttachmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo>(null as any);
    }

    /**
     * Get attachment metadata
     * @param id The id of the requirement.
     * @param attachmentId The id of the attachment.
     * @return The meta information for the specified attachment.
     */
    getAttachment(id: number, attachmentId: number): Promise<ApiAttachmentInfo> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Attachment/{attachmentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachment(_response);
        });
    }

    protected processGetAttachment(response: Response): Promise<ApiAttachmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo>(null as any);
    }

    /**
     * Delete attachment
     * @param id The id of the requirement.
     * @param attachmentId The id of the attachment.
     */
    deleteAttachment(id: number, attachmentId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Attachment/{attachmentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteAttachment(_response);
        });
    }

    protected processDeleteAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get attachment
     * @param id The id of the requirement.
     * @param attachmentId The id of the attachment.
     * @param download (optional) When true, the response contains a content-disposition header to
                force the browser to download the attachment.
     * @param token (optional) Optional OAuth token.
     * @param tenantId (optional) The ID of the tenant. Only required in multi-tenant environments.
     * @return The file content of the attachment.
     */
    getAttachmentData(id: number, attachmentId: number, download?: boolean | undefined, token?: string | null | undefined, tenantId?: number | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Attachment/{attachmentId}/data?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        if (download === null)
            throw new Error("The parameter 'download' cannot be null.");
        else if (download !== undefined)
            url_ += "download=" + encodeURIComponent("" + download) + "&";
        if (token !== undefined && token !== null)
            url_ += "access_token=" + encodeURIComponent("" + token) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachmentData(_response);
        });
    }

    protected processGetAttachmentData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 307) {
            return response.text().then((_responseText) => {
            let result307: any = null;
            result307 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRedirectResult;
            return throwException("The request is redirected.", status, _responseText, _headers, result307);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get fields edit meta
     * @param id The id of the requirement for which the edit meta is requested.
     * @param statusTo The id of the status we are switching to.
     * @return Basic information on the fields of the requirement.
     */
    editMeta(id: number, statusTo: number): Promise<ApiItemEditMeta> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/EditMeta?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (statusTo === undefined || statusTo === null)
            throw new Error("The parameter 'statusTo' must be defined and cannot be null.");
        else
            url_ += "statusTo=" + encodeURIComponent("" + statusTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEditMeta(_response);
        });
    }

    protected processEditMeta(response: Response): Promise<ApiItemEditMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemEditMeta;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemEditMeta>(null as any);
    }

    /**
     * Get edit status
     * @param id The id of the requirement.
     */
    getEditStatus(id: number): Promise<ApiItemEditStatus> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/EditStatus";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEditStatus(_response);
        });
    }

    protected processGetEditStatus(response: Response): Promise<ApiItemEditStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemEditStatus;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemEditStatus>(null as any);
    }

    /**
     * Get history
     * @param id The id of the requirement.
     * @return A list with all changes in chronological order.
     */
    getHistory(id: number): Promise<ApiHistoryEntryRequirement[]> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/History";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetHistory(_response);
        });
    }

    protected processGetHistory(response: Response): Promise<ApiHistoryEntryRequirement[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiHistoryEntryRequirement[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiHistoryEntryRequirement[]>(null as any);
    }

    /**
     * Create lock
     * @param id The id of the requirement to lock.
     * @param lockInfo Contains the information necessary to acquire a lock.
     */
    createLock(id: number, lockInfo: ApiLockNew): Promise<void> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lockInfo);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateLock(_response);
        });
    }

    protected processCreateLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete lock
     * @param id The id of the requirement for which the lock should be released.
     */
    deleteLock(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteLock(_response);
        });
    }

    protected processDeleteLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get posts
     * @param id The id of the requirement.
     * @param firstResult (optional) The first result wich should be fetched. The default value is 0.
     * @param maxResults (optional) The maximal number of results wich should be fetched. The default value is 100.
     * @param ascending (optional) The sorting order of the result. If true sorted ascending otherwise descending. The default value is true.
     * @return A list of paginated posts associated with the given requirement and the total count of all posts for this requirement.
     */
    getPosts(id: number, firstResult?: number | undefined, maxResults?: number | undefined, ascending?: boolean | undefined): Promise<ApiPostPaginated> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Post?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (firstResult === null)
            throw new Error("The parameter 'firstResult' cannot be null.");
        else if (firstResult !== undefined)
            url_ += "firstResult=" + encodeURIComponent("" + firstResult) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (ascending === null)
            throw new Error("The parameter 'ascending' cannot be null.");
        else if (ascending !== undefined)
            url_ += "ascending=" + encodeURIComponent("" + ascending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPosts(_response);
        });
    }

    protected processGetPosts(response: Response): Promise<ApiPostPaginated> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostPaginated;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostPaginated>(null as any);
    }

    /**
     * Create post
     * @param id The id of the requirement in which the new post should be created.
     * @param content The content of the new post. The content must be provided in exactly one format.
     * @return The meta information of the new post.
     */
    createPost(id: number, content: ApiRichText): Promise<ApiPostInfo> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Post";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreatePost(_response);
        });
    }

    protected processCreatePost(response: Response): Promise<ApiPostInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostInfo>(null as any);
    }

    /**
     * Get post
     * @param id The id of the requirement.
     * @param postId The id of the post.
     * @return The requested post.
     */
    getPost(id: number, postId: number): Promise<ApiPost> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Post/{postId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPost(_response);
        });
    }

    protected processGetPost(response: Response): Promise<ApiPost> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPost;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPost>(null as any);
    }

    /**
     * Replace post
     * @param id The id of the requirement.
     * @param postId The id of the post which should be replaced.
     * @param content The new content of the post. The content must be provided in exactly one format.
     * @return The meta information of the replaced post.
     */
    updatePost(id: number, postId: number, content: ApiRichText): Promise<ApiPostInfo> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Post/{postId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePost(_response);
        });
    }

    protected processUpdatePost(response: Response): Promise<ApiPostInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostInfo>(null as any);
    }

    /**
     * Delete post
     * @param id The id of the requirement.
     * @param postId The id of the post which should be deleted.
     * @return The meta information of the deleted post.
     */
    deletePost(id: number, postId: number): Promise<ApiPostInfo> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Post/{postId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeletePost(_response);
        });
    }

    protected processDeletePost(response: Response): Promise<ApiPostInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostInfo;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostInfo>(null as any);
    }

    /**
     * Get relations
     * @param id The id of the requirement.
     * @param depth (optional) The depth to which the relations are loaded. Depth 2 means that
                that the relations of relations are also loaded and so on. The default is 1.
     * @param maxItemsPerType (optional) The next level of relations is only loaded if at most
                this number of items of a certain type is present. Otherwise, the tree is cutoff.
                When this limit is not specified, this call might take a long time if the depth is
                greater than 1.
     * @param include (optional) Comma separated list of the data to include in the response.
                Supported includes: Relations.OtherItem.*Info to load basic info on the relation target,
                Relations.OtherItem.*Details to load the details of the relation target,
                Item.*Info to load basic info on the item for which the relations were requested,
                Item.*Details to load the details of the item for which the relations were requested.
     * @param fields (optional) The ids of the fields which should be included when details are included.
                When left empty, all fields will be included.
     * @return A list with all the relations together with some additional information.
     */
    getRelations(id: number, depth?: number | undefined, maxItemsPerType?: number | null | undefined, include?: string | null | undefined, fields?: string | null | undefined): Promise<ApiRelations> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Relation?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (depth === null)
            throw new Error("The parameter 'depth' cannot be null.");
        else if (depth !== undefined)
            url_ += "depth=" + encodeURIComponent("" + depth) + "&";
        if (maxItemsPerType !== undefined && maxItemsPerType !== null)
            url_ += "maxItemsPerType=" + encodeURIComponent("" + maxItemsPerType) + "&";
        if (include !== undefined && include !== null)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        if (fields !== undefined && fields !== null)
            url_ += "fields=" + encodeURIComponent("" + fields) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRelations(_response);
        });
    }

    protected processGetRelations(response: Response): Promise<ApiRelations> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelations;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelations>(null as any);
    }

    /**
     * Create relation
     * @param id The id of the requirement.
     * @param relation The other information necessary to create the relation.
     * @return The created relation.
     */
    createRelation(id: number, relation: ApiRelationNew): Promise<ApiRelation> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Relation";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(relation);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateRelation(_response);
        });
    }

    protected processCreateRelation(response: Response): Promise<ApiRelation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelation;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelation>(null as any);
    }

    /**
     * Delete relation
     * @param id The id of the requirement.
     * @param relationId The id of the relation.
     */
    deleteRelations(id: number, relationId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Relation/{relationId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (relationId === undefined || relationId === null)
            throw new Error("The parameter 'relationId' must be defined.");
        url_ = url_.replace("{relationId}", encodeURIComponent("" + relationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteRelations(_response);
        });
    }

    protected processDeleteRelations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get relation metadata
     * @param id The id of the requirement.
     * @return The metadata required to create new relations.
     */
    getRelationCreateMeta(id: number): Promise<ApiRelationCreateMeta> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Relation/CreateMeta";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRelationCreateMeta(_response);
        });
    }

    protected processGetRelationCreateMeta(response: Response): Promise<ApiRelationCreateMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelationCreateMeta;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelationCreateMeta>(null as any);
    }

    /**
     * Get subrequirements as list
     * @param id The id of the requirement.
     * @param depth (optional) The depth up to which the subrequirements are loaded.
                The default is 1 which means that only the immediate childs are included.
     * @return A list with basic information on all the subrequirements.
     */
    getSubrequirements(id: number, depth?: number | undefined): Promise<ApiSubrequirement[]> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Subrequirement?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (depth === null)
            throw new Error("The parameter 'depth' cannot be null.");
        else if (depth !== undefined)
            url_ += "depth=" + encodeURIComponent("" + depth) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSubrequirements(_response);
        });
    }

    protected processGetSubrequirements(response: Response): Promise<ApiSubrequirement[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiSubrequirement[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSubrequirement[]>(null as any);
    }

    /**
     * Add subrequirement
     * @param id The id of the requirement.
     * @param newSubrequirement Information on the requirement which should be added as a sub requirement.
     * @return The new subrequirement.
     */
    createSubrequirement(id: number, newSubrequirement: ApiSubrequirementNew): Promise<ApiSubrequirement> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Subrequirement";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newSubrequirement);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateSubrequirement(_response);
        });
    }

    protected processCreateSubrequirement(response: Response): Promise<ApiSubrequirement> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiSubrequirement;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSubrequirement>(null as any);
    }

    /**
     * Update subrequirement
     * @param id The id of the requirement.
     * @param subrequirementId The id of the subrequirement to update.
     * @param update The information which should be updated in the subrequirement.
     * @return The updated subrequirement.
     */
    updateSubrequirement(id: number, subrequirementId: number, update: ApiSubrequirementUpdate): Promise<ApiSubrequirement> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Subrequirement/{subrequirementId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (subrequirementId === undefined || subrequirementId === null)
            throw new Error("The parameter 'subrequirementId' must be defined.");
        url_ = url_.replace("{subrequirementId}", encodeURIComponent("" + subrequirementId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateSubrequirement(_response);
        });
    }

    protected processUpdateSubrequirement(response: Response): Promise<ApiSubrequirement> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiSubrequirement;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSubrequirement>(null as any);
    }

    /**
     * Remove subrequirement
     * @param id The id of the requirement.
     * @param subrequirementId The id of the subrequirement to remove.
     */
    deleteSubrequirement(id: number, subrequirementId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Subrequirement/{subrequirementId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (subrequirementId === undefined || subrequirementId === null)
            throw new Error("The parameter 'subrequirementId' must be defined.");
        url_ = url_.replace("{subrequirementId}", encodeURIComponent("" + subrequirementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteSubrequirement(_response);
        });
    }

    protected processDeleteSubrequirement(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get subrequirement tree
     * @param id The id of the requirement.
     * @param withEditableInfo (optional) If true, locking information is included in the result.
     * @return A list with basic information on all requirements in the tree.
     */
    getSubrequirementTree(id: number, withEditableInfo?: boolean | undefined): Promise<ApiSubrequirement[]> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/SubrequirementTree?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (withEditableInfo === null)
            throw new Error("The parameter 'withEditableInfo' cannot be null.");
        else if (withEditableInfo !== undefined)
            url_ += "withEditableInfo=" + encodeURIComponent("" + withEditableInfo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSubrequirementTree(_response);
        });
    }

    protected processGetSubrequirementTree(response: Response): Promise<ApiSubrequirement[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiSubrequirement[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSubrequirement[]>(null as any);
    }

    /**
     * Rearrange subrequirement tree
     * @param id The id of the requirement.
     * @param update Contains the information how the sub requirement tree
                should be rearranged.
     * @return A list with basic information on all requirements in the tree.
     */
    updateSubrequirementTree(id: number, update: ApiSubrequirementsUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/SubrequirementTree";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateSubrequirementTree(_response);
        });
    }

    protected processUpdateSubrequirementTree(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Add subrequirements
     * @param id The id of the requirement.
     * @param newSubrequirements The list of new subrequirements to be saved.
     * @return A list with basic information on all requirements in the tree.
     */
    addSubrequirements(id: number, newSubrequirements: ApiSubrequirementsNew): Promise<void> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/SubrequirementTree";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newSubrequirements);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddSubrequirements(_response);
        });
    }

    protected processAddSubrequirements(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create subrequirment locks
     * @param id The id of the requirement.
     * @return A list with basic information on all requirements in the tree including the
                information whether the subrequirement was successfully locked.
     */
    lockSubrequirementTree(id: number): Promise<ApiSubrequirement[]> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/SubrequirementTree/Lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLockSubrequirementTree(_response);
        });
    }

    protected processLockSubrequirementTree(response: Response): Promise<ApiSubrequirement[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiSubrequirement[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSubrequirement[]>(null as any);
    }

    /**
     * Get watching users as list
     * @param id id of the requirement.
     * @return List of users watching this requirement.
     */
    getWatchers(id: number): Promise<ApiUserInfo[]> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetWatchers(_response);
        });
    }

    protected processGetWatchers(response: Response): Promise<ApiUserInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUserInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiUserInfo[]>(null as any);
    }

    /**
     * Add to watch list
     * @param id The id of the requirement.
     * @param newWatcher Contains id of the user to be subscribed.
     */
    addWatcher(id: number, newWatcher: ApiWatcherNew): Promise<void> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newWatcher);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddWatcher(_response);
        });
    }

    protected processAddWatcher(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Updates the watch list
     * @param id The id of the requirement.
     * @param watchersUpdate Contains the id of the user to be (un-)subscribed.
     */
    updateWatchers(id: number, watchersUpdate: ApiWatchersUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(watchersUpdate);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateWatchers(_response);
        });
    }

    protected processUpdateWatchers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove from watch list
     * @param id The id of the requirement.
     * @param userId The id of the user to be unsubscribed.
     */
    removeWatcher(id: number, userId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Requirement/{id}/Watchers/{userId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveWatcher(_response);
        });
    }

    protected processRemoveWatcher(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get fields metadata
     * @param projectId The id of the project.
     * @param folderId The id of the folder where the requirement will be created (0 means root level).
     * @param statusTo (optional) The id of status with which the new item will be saved. Workflow
                restrictions might depend on this status and hence the meta data might change depending
                on the selected status. If no status id is provided, the default value for the status
                is assumed.
     * @return Basic information on the fields of a new requirement created in given project and folder.
     */
    createMeta(projectId: number, folderId: number, statusTo?: number | null | undefined): Promise<ApiItemCreateMeta> {
        let url_ = this.baseUrl + "/api/Requirement/CreateMeta?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined and cannot be null.");
        else
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (statusTo !== undefined && statusTo !== null)
            url_ += "statusTo=" + encodeURIComponent("" + statusTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMeta(_response);
        });
    }

    protected processCreateMeta(response: Response): Promise<ApiItemCreateMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemCreateMeta;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemCreateMeta>(null as any);
    }

    /**
     * Get requirements
     * @param projectId The id of the project of which the items are loaded.
     * @param folderId (optional) The id of the folder of which the items are loaded.
     * @param includeSubfolders (optional) Indicates whether items from sub folders should be included.
     * @param includeArchived (optional) Indicates whether archieved items should be included.
     * @param filter (optional) The filter syntax is as follows:
                [["Priority", "=", "High"], "and", ["DateCreatedDateTime", ">=", "2018-01-01"]]
                The field meta data can be used to check which filter operators are supported for which fields.
     * @param sorting (optional) The sorting syntax is as follows:
                [["Significane", "desc"], ["Status", "asc]]
                The field meta data can be used to check which fields support sorting.
     * @param search (optional) A fulltext search will be performed with this term and only matching
                items will be included in the result
     * @param startAt (optional) The index of the first item which should be included. Allows pagination
                of the results.
     * @param maxResults (optional) The maximum number of items to return. Allows pagination of the results.
     * @return A list of items matching the given criteria.
     */
    getItemList(projectId: number, folderId?: number | undefined, includeSubfolders?: boolean | undefined, includeArchived?: boolean | undefined, filter?: string | null | undefined, sorting?: string | null | undefined, search?: string | null | undefined, startAt?: number | undefined, maxResults?: number | undefined): Promise<ApiItemListResult> {
        let url_ = this.baseUrl + "/api/Requirement/ItemList?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (includeSubfolders === null)
            throw new Error("The parameter 'includeSubfolders' cannot be null.");
        else if (includeSubfolders !== undefined)
            url_ += "includeSubfolders=" + encodeURIComponent("" + includeSubfolders) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetItemList(_response);
        });
    }

    protected processGetItemList(response: Response): Promise<ApiItemListResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemListResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemListResult>(null as any);
    }
}

export class ResetPasswordClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Resets the user's password
     * @param apiResetPasswordUser Information about email and tenant
     */
    reset(apiResetPasswordUser: ApiResetPasswordUser): Promise<ApiResetPasswordResult> {
        let url_ = this.baseUrl + "/api/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiResetPasswordUser);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReset(_response);
        });
    }

    protected processReset(response: Response): Promise<ApiResetPasswordResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiResetPasswordResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResetPasswordResult>(null as any);
    }
}

export class ScriptClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Modify script collection
     * @param patchRequest Operation details.
     * @return Guid of the batch operation. 
    Status of the the operation can be retrieved using GET api/System/LongOperation/{guid}/Status or GET api/System/LongOperation/{guid}.
    In case of this batch operation the data retrieved from 'GET api/System/LongOperation/{guid}' contains additional information 
    as defined in ApiItemLongOperationInfo (FailedItems).
    Additionally, you SignalR (group "LongOperation_{customerId}_{guid}") can be used to receive information when operation finishes.
     */
    modifyItems(patchRequest: ApiItemsPatchRequest): Promise<ApiLongOperationOfBoolean> {
        let url_ = this.baseUrl + "/api/Script";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patchRequest);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyItems(_response);
        });
    }

    protected processModifyItems(response: Response): Promise<ApiLongOperationOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperationOfBoolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperationOfBoolean>(null as any);
    }

    /**
     * Get script
     * @param id The id of the script as integer.
     * @param withEditableInfo (optional) Indicates whether information about the
                edit lock should be included.
     * @param withEditLayout (optional) Indicates whether information about the edit layout should be included.
                Edit layout is a superset of view layout (you don't have to specify withViewLayout) and contains all information 
                required to display and edit the item.
     * @param withViewLayout (optional) Indicates whether information about the
                view layout should be included. The view layout is a subset of edit layout and 
                contains all information required to display the item.
     * @return The requested script.
     */
    get(id: number, withEditableInfo?: boolean | undefined, withEditLayout?: boolean | undefined, withViewLayout?: boolean | undefined): Promise<ApiScript> {
        let url_ = this.baseUrl + "/api/Script/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (withEditableInfo === null)
            throw new Error("The parameter 'withEditableInfo' cannot be null.");
        else if (withEditableInfo !== undefined)
            url_ += "withEditableInfo=" + encodeURIComponent("" + withEditableInfo) + "&";
        if (withEditLayout === null)
            throw new Error("The parameter 'withEditLayout' cannot be null.");
        else if (withEditLayout !== undefined)
            url_ += "withEditLayout=" + encodeURIComponent("" + withEditLayout) + "&";
        if (withViewLayout === null)
            throw new Error("The parameter 'withViewLayout' cannot be null.");
        else if (withViewLayout !== undefined)
            url_ += "withViewLayout=" + encodeURIComponent("" + withViewLayout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ApiScript> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiScript;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiScript>(null as any);
    }

    /**
     * Get attachments metadata as list
     * @param id The id of the script.
     * @return A list with meta information on all the attachments of this script.
     */
    getAttachments(id: number): Promise<ApiAttachmentInfo[]> {
        let url_ = this.baseUrl + "/api/Script/{id}/Attachment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachments(_response);
        });
    }

    protected processGetAttachments(response: Response): Promise<ApiAttachmentInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo[]>(null as any);
    }

    /**
     * Create attachment
     * @param id The id of the script.
     * @param filename (optional) The filename of the attachment. This parameter is optional. If it
                is not specified, the file name from the multi part form data will be used.
     * @param file (optional) 
     * @return The metadata of the created attachment.
     */
    addAttachment(id: number, filename?: string | null | undefined, file?: FileParameter[] | undefined): Promise<ApiAttachmentInfo> {
        let url_ = this.baseUrl + "/api/Script/{id}/Attachment?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (filename !== undefined && filename !== null)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddAttachment(_response);
        });
    }

    protected processAddAttachment(response: Response): Promise<ApiAttachmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo>(null as any);
    }

    /**
     * Get attachment metadata
     * @param id The id of the script.
     * @param attachmentId The id of the attachment.
     * @return The meta information for the specified attachment.
     */
    getAttachment(id: number, attachmentId: number): Promise<ApiAttachmentInfo> {
        let url_ = this.baseUrl + "/api/Script/{id}/Attachment/{attachmentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachment(_response);
        });
    }

    protected processGetAttachment(response: Response): Promise<ApiAttachmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo>(null as any);
    }

    /**
     * Delete attachment
     * @param id The id of the script.
     * @param attachmentId The id of the attachment.
     */
    deleteAttachment(id: number, attachmentId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Script/{id}/Attachment/{attachmentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteAttachment(_response);
        });
    }

    protected processDeleteAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get attachment
     * @param id The id of the script.
     * @param attachmentId The id of the attachment.
     * @param download (optional) When true, the response contains a content-disposition header to
                force the browser to download the attachment.
     * @param token (optional) Optional OAuth token.
     * @param tenantId (optional) The ID of the tenant. Only required in multi-tenant environments.
     * @return The file content of the attachment.
     */
    getAttachmentData(id: number, attachmentId: number, download?: boolean | undefined, token?: string | null | undefined, tenantId?: number | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Script/{id}/Attachment/{attachmentId}/data?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        if (download === null)
            throw new Error("The parameter 'download' cannot be null.");
        else if (download !== undefined)
            url_ += "download=" + encodeURIComponent("" + download) + "&";
        if (token !== undefined && token !== null)
            url_ += "access_token=" + encodeURIComponent("" + token) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachmentData(_response);
        });
    }

    protected processGetAttachmentData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 307) {
            return response.text().then((_responseText) => {
            let result307: any = null;
            result307 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRedirectResult;
            return throwException("The request is redirected.", status, _responseText, _headers, result307);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get edit status
     * @param id The id of the script.
     */
    getEditStatus(id: number): Promise<ApiItemEditStatus> {
        let url_ = this.baseUrl + "/api/Script/{id}/EditStatus";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEditStatus(_response);
        });
    }

    protected processGetEditStatus(response: Response): Promise<ApiItemEditStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemEditStatus;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemEditStatus>(null as any);
    }

    /**
     * Get history
     * @param id The id of the script.
     * @return A list with all changes in chronological order.
     */
    getHistory(id: number): Promise<ApiHistoryEntry[]> {
        let url_ = this.baseUrl + "/api/Script/{id}/History";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetHistory(_response);
        });
    }

    protected processGetHistory(response: Response): Promise<ApiHistoryEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiHistoryEntry[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiHistoryEntry[]>(null as any);
    }

    /**
     * Create lock
     * @param id The id of the script to lock.
     * @param lockInfo Contains the information necessary to acquire a lock.
     */
    createLock(id: number, lockInfo: ApiLockNew): Promise<void> {
        let url_ = this.baseUrl + "/api/Script/{id}/Lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lockInfo);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateLock(_response);
        });
    }

    protected processCreateLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete lock
     * @param id The id of the script for which the lock should be released.
     */
    deleteLock(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Script/{id}/Lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteLock(_response);
        });
    }

    protected processDeleteLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get relations
     * @param id The id of the script.
     * @param depth (optional) The depth to which the relations are loaded. Depth 2 means that
                that the relations of relations are also loaded and so on. The default is 1.
     * @param maxItemsPerType (optional) The next level of relations is only loaded if at most
                this number of items of a certain type is present. Otherwise, the tree is cutoff.
                When this limit is not specified, this call might take a long time if the depth is
                greater than 1.
     * @param include (optional) Comma separated list of the data to include in the response.
                Supported includes: Relations.OtherItem.*Info to load basic info on the relation target,
                Relations.OtherItem.*Details to load the details of the relation target,
                Item.*Info to load basic info on the item for which the relations were requested,
                Item.*Details to load the details of the item for which the relations were requested.
     * @param fields (optional) The ids of the fields which should be included when details are included.
                When left empty, all fields will be included.
     * @return A list with all the relations together with some additional information.
     */
    getRelations(id: number, depth?: number | undefined, maxItemsPerType?: number | null | undefined, include?: string | null | undefined, fields?: string | null | undefined): Promise<ApiRelations> {
        let url_ = this.baseUrl + "/api/Script/{id}/Relation?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (depth === null)
            throw new Error("The parameter 'depth' cannot be null.");
        else if (depth !== undefined)
            url_ += "depth=" + encodeURIComponent("" + depth) + "&";
        if (maxItemsPerType !== undefined && maxItemsPerType !== null)
            url_ += "maxItemsPerType=" + encodeURIComponent("" + maxItemsPerType) + "&";
        if (include !== undefined && include !== null)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        if (fields !== undefined && fields !== null)
            url_ += "fields=" + encodeURIComponent("" + fields) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRelations(_response);
        });
    }

    protected processGetRelations(response: Response): Promise<ApiRelations> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelations;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelations>(null as any);
    }

    /**
     * Create relation
     * @param id The id of the script.
     * @param relation The other information necessary to create the relation.
     * @return The created relation.
     */
    createRelation(id: number, relation: ApiRelationNew): Promise<ApiRelation> {
        let url_ = this.baseUrl + "/api/Script/{id}/Relation";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(relation);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateRelation(_response);
        });
    }

    protected processCreateRelation(response: Response): Promise<ApiRelation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelation;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelation>(null as any);
    }

    /**
     * Delete relation
     * @param id The id of the script.
     * @param relationId The id of the relation.
     */
    deleteRelations(id: number, relationId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/Script/{id}/Relation/{relationId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (relationId === undefined || relationId === null)
            throw new Error("The parameter 'relationId' must be defined.");
        url_ = url_.replace("{relationId}", encodeURIComponent("" + relationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteRelations(_response);
        });
    }

    protected processDeleteRelations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get relation metadata
     * @param id The id of the script.
     * @return The metadata required to create new relations.
     */
    getRelationCreateMeta(id: number): Promise<ApiRelationCreateMeta> {
        let url_ = this.baseUrl + "/api/Script/{id}/Relation/CreateMeta";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRelationCreateMeta(_response);
        });
    }

    protected processGetRelationCreateMeta(response: Response): Promise<ApiRelationCreateMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelationCreateMeta;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelationCreateMeta>(null as any);
    }

    /**
     * Get watching users as list
     * @param id The id of the script.
     * @return List of users watching this script.
     */
    getWatchers(id: number): Promise<ApiUserInfo[]> {
        let url_ = this.baseUrl + "/api/Script/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetWatchers(_response);
        });
    }

    protected processGetWatchers(response: Response): Promise<ApiUserInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUserInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiUserInfo[]>(null as any);
    }

    /**
     * Add to watch list
     * @param id The id of the script.
     * @param newWatcher Contains id of the user to be subscribed.
     */
    addWatcher(id: number, newWatcher: ApiWatcherNew): Promise<void> {
        let url_ = this.baseUrl + "/api/Script/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newWatcher);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddWatcher(_response);
        });
    }

    protected processAddWatcher(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Updates the watch list
     * @param id The id of the script.
     * @param watchersUpdate Contains the id of the user to be (un-)subscribed.
     */
    updateWatchers(id: number, watchersUpdate: ApiWatchersUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/Script/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(watchersUpdate);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateWatchers(_response);
        });
    }

    protected processUpdateWatchers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove from watch list
     * @param id The id of the script.
     * @param userId The id of the user to be unsubscribed.
     */
    removeWatcher(id: number, userId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Script/{id}/Watchers/{userId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveWatcher(_response);
        });
    }

    protected processRemoveWatcher(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get scripts
     * @param projectId The id of the project of which the items are loaded.
     * @param folderId (optional) The id of the folder of which the items are loaded.
     * @param includeSubfolders (optional) Indicates whether items from sub folders should be included.
     * @param includeArchived (optional) Indicates whether archieved items should be included.
     * @param filter (optional) The filter syntax is as follows:
                [["Priority", "=", "High"], "and", ["DateCreatedDateTime", ">=", "2018-01-01"]]
                The field meta data can be used to check which filter operators are supported for which fields.
     * @param sorting (optional) The sorting syntax is as follows:
                [["Significane", "desc"], ["Status", "asc]]
                The field meta data can be used to check which fields support sorting.
     * @param search (optional) A fulltext search will be performed with this term and only matching
                items will be included in the result
     * @param startAt (optional) The index of the first item which should be included. Allows pagination
                of the results.
     * @param maxResults (optional) The maximum number of items to return. Allows pagination of the results.
     * @return A list of items matching the given criteria.
     */
    itemList(projectId: number, folderId?: number | undefined, includeSubfolders?: boolean | undefined, includeArchived?: boolean | undefined, filter?: string | null | undefined, sorting?: string | null | undefined, search?: string | null | undefined, startAt?: number | undefined, maxResults?: number | undefined): Promise<ApiItemListResult> {
        let url_ = this.baseUrl + "/api/Script/ItemList?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (includeSubfolders === null)
            throw new Error("The parameter 'includeSubfolders' cannot be null.");
        else if (includeSubfolders !== undefined)
            url_ += "includeSubfolders=" + encodeURIComponent("" + includeSubfolders) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processItemList(_response);
        });
    }

    protected processItemList(response: Response): Promise<ApiItemListResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemListResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemListResult>(null as any);
    }
}

export class ServerAdministratorClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get subfolders
     * @param parentFolders JSON array of requested parent folders to retrieve subfolder for. For example:
                ['5_0', '3_114'] where first number is a project id and second number is folder id (or zero for root).
     * @param includeProjects (optional) Indicate whether to return project list as well.
     * @param includeArchived (optional) Indicates whether archived items should be included.
     * @return A response object containing project list (if requested) and subfolders of all requested nodes.
     */
    getProjectTreeData(parentFolders: string | null, includeProjects?: boolean | undefined, includeArchived?: boolean | undefined): Promise<ApiProjectTreeResponse> {
        let url_ = this.baseUrl + "/api/ServerAdministrator/Tree?";
        if (parentFolders === undefined)
            throw new Error("The parameter 'parentFolders' must be defined.");
        else if(parentFolders !== null)
            url_ += "parentFolders=" + encodeURIComponent("" + parentFolders) + "&";
        if (includeProjects === null)
            throw new Error("The parameter 'includeProjects' cannot be null.");
        else if (includeProjects !== undefined)
            url_ += "includeProjects=" + encodeURIComponent("" + includeProjects) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProjectTreeData(_response);
        });
    }

    protected processGetProjectTreeData(response: Response): Promise<ApiProjectTreeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectTreeResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectTreeResponse>(null as any);
    }
}

export class SessionClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Use this to get info on current user
     * @return Returns information about the currently authenticated user.
    If the caller is not authenticated they will get a 401 Unauthorized status code.
     */
    get(): Promise<ApiMyUserInfo> {
        let url_ = this.baseUrl + "/api/Session";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ApiMyUserInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiMyUserInfo;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiMyUserInfo>(null as any);
    }

    /**
     * Logs the current user out of aqua, destroying the existing session, if any.
     */
    delete(): Promise<string> {
        let url_ = this.baseUrl + "/api/Session";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class SystemClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get predefined colors
     * @return The list of colors.
     */
    getColors(): Promise<ApiSystemGetColorsResponse> {
        let url_ = this.baseUrl + "/api/System/Colors";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetColors(_response);
        });
    }

    protected processGetColors(response: Response): Promise<ApiSystemGetColorsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiSystemGetColorsResponse;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSystemGetColorsResponse>(null as any);
    }

    /**
     * Get licenses
     * @return The list of licenses.
     */
    getLicenses(): Promise<ApiGetLicenseResponse> {
        let url_ = this.baseUrl + "/api/System/License";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetLicenses(_response);
        });
    }

    protected processGetLicenses(response: Response): Promise<ApiGetLicenseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiGetLicenseResponse;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiGetLicenseResponse>(null as any);
    }

    /**
     * Get login incidents
     * @param startAt (optional) 
     * @param maxResults (optional) 
     * @param filter (optional) 
     * @param orderBy (optional) 
     * @return List of login incidents.
     */
    getLoginIncidents(startAt?: number | undefined, maxResults?: number | undefined, filter?: string | null | undefined, orderBy?: string | null | undefined): Promise<ApiPaginatedResultOfApiLoginIncident> {
        let url_ = this.baseUrl + "/api/System/License/Incidents?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetLoginIncidents(_response);
        });
    }

    protected processGetLoginIncidents(response: Response): Promise<ApiPaginatedResultOfApiLoginIncident> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPaginatedResultOfApiLoginIncident;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPaginatedResultOfApiLoginIncident>(null as any);
    }

    /**
     * Get last user activity
     * @param startAt (optional) 
     * @param maxResults (optional) 
     * @param filter (optional) 
     * @param orderBy (optional) 
     * @return List of logins with licenses.
     */
    getLastUserActivity(startAt?: number | undefined, maxResults?: number | undefined, filter?: string | null | undefined, orderBy?: string | null | undefined): Promise<ApiPaginatedResultOfApiUserLastActivityInfo> {
        let url_ = this.baseUrl + "/api/System/License/LastUserActivity?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetLastUserActivity(_response);
        });
    }

    protected processGetLastUserActivity(response: Response): Promise<ApiPaginatedResultOfApiUserLastActivityInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPaginatedResultOfApiUserLastActivityInfo;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPaginatedResultOfApiUserLastActivityInfo>(null as any);
    }

    /**
     * Get licenses permissions
     * @param licenseProfileCode The profile code of the license.
     * @return The permissions list
                .
     */
    getLicensePermissions(licenseProfileCode: string | null): Promise<ApiGetLicensePermissionsResponse> {
        let url_ = this.baseUrl + "/api/System/License/Permissions?";
        if (licenseProfileCode === undefined)
            throw new Error("The parameter 'licenseProfileCode' must be defined.");
        else if(licenseProfileCode !== null)
            url_ += "licenseProfileCode=" + encodeURIComponent("" + licenseProfileCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetLicensePermissions(_response);
        });
    }

    protected processGetLicensePermissions(response: Response): Promise<ApiGetLicensePermissionsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiGetLicensePermissionsResponse;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiGetLicensePermissionsResponse>(null as any);
    }

    /**
     * Get long operation information
     * @param guid Unique identifier of the long operation.
     * @return Record containing information about long operation.
     */
    getLongOperationInfo(guid: string | null): Promise<ApiLongOperationInfoBase> {
        let url_ = this.baseUrl + "/api/System/LongOperation/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetLongOperationInfo(_response);
        });
    }

    protected processGetLongOperationInfo(response: Response): Promise<ApiLongOperationInfoBase> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperationInfoBase;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperationInfoBase>(null as any);
    }

    /**
     * Modify long operation
     * @param guid Unique identifier of the long operation.
     * @param modification The change to be performed (e.g. abort).
     */
    modifyLongOperation(guid: string | null, modification: ApiLongOperationPatchOperation): Promise<void> {
        let url_ = this.baseUrl + "/api/System/LongOperation/{guid}";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(modification);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyLongOperation(_response);
        });
    }

    protected processModifyLongOperation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get long operations status
     * @param guid Unique identifier of the long operation.
     * @return Status of the long operation.
     */
    getLongOperationStatus(guid: string | null): Promise<ApiLongOperationStatus> {
        let url_ = this.baseUrl + "/api/System/LongOperation/{guid}/Status";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined.");
        url_ = url_.replace("{guid}", encodeURIComponent("" + guid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetLongOperationStatus(_response);
        });
    }

    protected processGetLongOperationStatus(response: Response): Promise<ApiLongOperationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperationStatus;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperationStatus>(null as any);
    }

    /**
     * Send email notification
     * @param notification Email notification to be send.
     */
    sendNotification(notification: ApiCustomNotificationNew): Promise<void> {
        let url_ = this.baseUrl + "/api/System/NotifyUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(notification);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendNotification(_response);
        });
    }

    protected processSendNotification(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get system permissions
     * @param reload (optional) If true then forces reload of user permissions before returning the result. Default: false.
     * @return System permissions.
     */
    getPermissions(reload?: boolean | undefined): Promise<ApiSystemPermissions> {
        let url_ = this.baseUrl + "/api/System/Permissions?";
        if (reload === null)
            throw new Error("The parameter 'reload' cannot be null.");
        else if (reload !== undefined)
            url_ += "reload=" + encodeURIComponent("" + reload) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPermissions(_response);
        });
    }

    protected processGetPermissions(response: Response): Promise<ApiSystemPermissions> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiSystemPermissions;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSystemPermissions>(null as any);
    }

    /**
     * Get all system available permissions
     * @return All avaliable permissions
     */
    getAllPermissions(): Promise<GenericPermissionInfo[]> {
        let url_ = this.baseUrl + "/api/System/Permissions/All";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllPermissions(_response);
        });
    }

    protected processGetAllPermissions(response: Response): Promise<GenericPermissionInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenericPermissionInfo[];
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GenericPermissionInfo[]>(null as any);
    }

    /**
     * Validate permission dependencies
     * @return The dependencies information about the permissions.
     */
    validatePermissionDependencies(request: ApiDependenciesPermissionPatchRequest): Promise<ApiPermissionDependenciesPatchResponse> {
        let url_ = this.baseUrl + "/api/System/Permissions/Dependencies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processValidatePermissionDependencies(_response);
        });
    }

    protected processValidatePermissionDependencies(response: Response): Promise<ApiPermissionDependenciesPatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPermissionDependenciesPatchResponse;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPermissionDependenciesPatchResponse>(null as any);
    }

    /**
     * Get all projects
     * @param excludeArchived (optional) Indicates whether archived projects are excluded or not
     */
    getProjects(excludeArchived?: boolean | undefined): Promise<ApiProjectIdName[]> {
        let url_ = this.baseUrl + "/api/System/Project?";
        if (excludeArchived === null)
            throw new Error("The parameter 'excludeArchived' cannot be null.");
        else if (excludeArchived !== undefined)
            url_ += "excludeArchived=" + encodeURIComponent("" + excludeArchived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProjects(_response);
        });
    }

    protected processGetProjects(response: Response): Promise<ApiProjectIdName[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectIdName[];
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectIdName[]>(null as any);
    }

    /**
     * Get registered editors
     * @return Registered editors.
     */
    getRegisteredEditors(): Promise<ApiRegisteredFileEditorsRepository> {
        let url_ = this.baseUrl + "/api/System/RegisteredEditor";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRegisteredEditors(_response);
        });
    }

    protected processGetRegisteredEditors(response: Response): Promise<ApiRegisteredFileEditorsRepository> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRegisteredFileEditorsRepository;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRegisteredFileEditorsRepository>(null as any);
    }

    /**
     * Get roles as list
     * @return The list of roles.
     */
    getRoles(): Promise<ApiRoleIdName[]> {
        let url_ = this.baseUrl + "/api/System/Role";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: Response): Promise<ApiRoleIdName[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRoleIdName[];
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRoleIdName[]>(null as any);
    }

    /**
     * Create new role
     * @return The new role.
     */
    createRole(newRole: ApiRoleNew): Promise<ApiRoleNewResponse> {
        let url_ = this.baseUrl + "/api/System/Role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newRole);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: Response): Promise<ApiRoleNewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRoleNewResponse;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRoleNewResponse>(null as any);
    }

    /**
     * Get role
     * @return The role.
     */
    getRole(roleId: number): Promise<ApiRole> {
        let url_ = this.baseUrl + "/api/System/Role/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRole(_response);
        });
    }

    protected processGetRole(response: Response): Promise<ApiRole> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRole;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRole>(null as any);
    }

    /**
     * Update role
     * @param roleId The id of the role
     * @param update This object contains the changes which should be performed.
     */
    updateRole(roleId: number, update: ApiUpdateRole): Promise<void> {
        let url_ = this.baseUrl + "/api/System/Role/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete role
     * @param roleId The id of the role.
     */
    deleteRole(roleId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/System/Role/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteRole(_response);
        });
    }

    protected processDeleteRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Modify role
     * @param roleId The id of the role.
     * @param patchRequest Operation details.
     */
    modifyRole(roleId: number, patchRequest: ApiRolePatchRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/System/Role/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patchRequest);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyRole(_response);
        });
    }

    protected processModifyRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get system settings
     */
    getSettings(): Promise<ApiSystemSettings> {
        let url_ = this.baseUrl + "/api/System/Settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSettings(_response);
        });
    }

    protected processGetSettings(response: Response): Promise<ApiSystemSettings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiSystemSettings;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSystemSettings>(null as any);
    }

    /**
     * Get shell automation profiles
     * @return An array of registered shell automation profiles.
     */
    getShellAutomationProfiles(): Promise<string> {
        let url_ = this.baseUrl + "/api/System/ShellAutomationProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetShellAutomationProfiles(_response);
        });
    }

    protected processGetShellAutomationProfiles(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get all users
     */
    getUsers(): Promise<ApiUserMinimalInfo[]> {
        let url_ = this.baseUrl + "/api/System/User";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: Response): Promise<ApiUserMinimalInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUserMinimalInfo[];
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiUserMinimalInfo[]>(null as any);
    }

    /**
     * Create user
     * @param newUser The data for the new user which should be created.
     * @param sendNotification (optional) This parameter allows to disable notifications to the user.
     * @return Id of the created user.
     */
    createUser(newUser: ApiUserNew, sendNotification?: boolean | undefined): Promise<ApiUserNewReponse> {
        let url_ = this.baseUrl + "/api/System/User?";
        if (sendNotification === null)
            throw new Error("The parameter 'sendNotification' cannot be null.");
        else if (sendNotification !== undefined)
            url_ += "sendNotification=" + encodeURIComponent("" + sendNotification) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newUser);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<ApiUserNewReponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUserNewReponse;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiUserNewReponse>(null as any);
    }

    /**
     * Get user
     * @param userId The id of the user
     * @param includeProjects (optional) Indicates whether projects are included or not.
     * @param includeLicenses (optional) Indicates whether licenses are included or not.
     */
    getUserInformation(userId: number, includeProjects?: boolean | undefined, includeLicenses?: boolean | undefined): Promise<ApiUser> {
        let url_ = this.baseUrl + "/api/System/User/{userId}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (includeProjects === null)
            throw new Error("The parameter 'includeProjects' cannot be null.");
        else if (includeProjects !== undefined)
            url_ += "includeProjects=" + encodeURIComponent("" + includeProjects) + "&";
        if (includeLicenses === null)
            throw new Error("The parameter 'includeLicenses' cannot be null.");
        else if (includeLicenses !== undefined)
            url_ += "includeLicenses=" + encodeURIComponent("" + includeLicenses) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserInformation(_response);
        });
    }

    protected processGetUserInformation(response: Response): Promise<ApiUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUser;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiUser>(null as any);
    }

    /**
     * Delete user
     * @param userId The id of the user.
     */
    deleteUser(userId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/System/User/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update user
     * @param userId The id of the user
     * @param update This object contains the changes which should be performed.
     */
    updateUser(userId: number, update: ApiUpdateUser): Promise<void> {
        let url_ = this.baseUrl + "/api/System/User/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Modify user
     * @param userId The id of the user.
     * @param patchRequest Operation details.
     */
    modifyUser(userId: number, patchRequest: ApiUserPatchRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/System/User/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patchRequest);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyUser(_response);
        });
    }

    protected processModifyUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Assigne license
     * @param userId The id of the user
     * @param licenseAssignment License information
     */
    assigneLicense(userId: number, licenseAssignment: ApiUserLicenseAssignment): Promise<void> {
        let url_ = this.baseUrl + "/api/System/User/{userId}/License";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(licenseAssignment);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAssigneLicense(_response);
        });
    }

    protected processAssigneLicense(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Modify license
     * @param userId The id of the user.
     * @param licenseCode The code of the license.
     * @param update The necessary information to modify the license assignment.
     */
    modifyLicense(userId: number, licenseCode: string | null, update: ApiUserLicenseAssignmentPatchRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/System/User/{userId}/License/{licenseCode}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (licenseCode === undefined || licenseCode === null)
            throw new Error("The parameter 'licenseCode' must be defined.");
        url_ = url_.replace("{licenseCode}", encodeURIComponent("" + licenseCode));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyLicense(_response);
        });
    }

    protected processModifyLicense(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete license assignment
     * @param userId The id of the user.
     * @param licenseCode The code of the license.
     */
    deleteLicense(userId: number, licenseCode: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/System/User/{userId}/License/{licenseCode}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (licenseCode === undefined || licenseCode === null)
            throw new Error("The parameter 'licenseCode' must be defined.");
        url_ = url_.replace("{licenseCode}", encodeURIComponent("" + licenseCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteLicense(_response);
        });
    }

    protected processDeleteLicense(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Upload user picture
     * @param userId The id of the user.
     * @param file (optional) 
     */
    changeUserPhoto(userId: number, file?: FileParameter[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/System/User/{userId}/Photo";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processChangeUserPhoto(_response);
        });
    }

    protected processChangeUserPhoto(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TestCaseClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Create test case
     * @param newItem The data for the new test case which should be created.
     * @param applyDefaultValues (optional) Indicates whether default values should be applied for fields which are not included in the request.
     * @return Basic information on the new test case.
     */
    create(newItem: ApiItemNewWithTestDataAndTestSteps, applyDefaultValues?: boolean | undefined): Promise<ApiItemInfo> {
        let url_ = this.baseUrl + "/api/TestCase?";
        if (applyDefaultValues === null)
            throw new Error("The parameter 'applyDefaultValues' cannot be null.");
        else if (applyDefaultValues !== undefined)
            url_ += "applyDefaultValues=" + encodeURIComponent("" + applyDefaultValues) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newItem);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ApiItemInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemInfo>(null as any);
    }

    /**
     * Modify test case collection
     * @param patchRequest Operation details.
     * @return Guid of the batch operation. 
    Status of the the operation can be retrieved using GET api/System/LongOperation/{guid}/Status or GET api/System/LongOperation/{guid}.
    In case of this batch operation the data retrieved from 'GET api/System/LongOperation/{guid}' contains additional information 
    as defined in ApiItemLongOperationInfo (FailedItems).
    Additionally, you SignalR (group "LongOperation_{customerId}_{guid}") can be used to receive information when operation finishes.
     */
    modifyItems(patchRequest: ApiItemsPatchRequest): Promise<ApiLongOperationOfBoolean> {
        let url_ = this.baseUrl + "/api/TestCase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patchRequest);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyItems(_response);
        });
    }

    protected processModifyItems(response: Response): Promise<ApiLongOperationOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperationOfBoolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperationOfBoolean>(null as any);
    }

    /**
     * Get test case
     * @param id The id of the test case as integer (without TC).
     * @param withEditableInfo (optional) Indicates whether information about the
                edit lock should be included.
     * @param withEditLayout (optional) Indicates whether information about the edit layout should be included.
                Edit layout is a superset of view layout (you don't have to specify withViewLayout) and contains all information 
                required to display and edit the item.
     * @param withViewLayout (optional) Indicates whether information about the
                view layout should be included. The view layout is a subset of edit layout and 
                contains all information required to display the item.
     * @return The requested test case.
     */
    get(id: number, withEditableInfo?: boolean | undefined, withEditLayout?: boolean | undefined, withViewLayout?: boolean | undefined): Promise<ApiTestCase> {
        let url_ = this.baseUrl + "/api/TestCase/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (withEditableInfo === null)
            throw new Error("The parameter 'withEditableInfo' cannot be null.");
        else if (withEditableInfo !== undefined)
            url_ += "withEditableInfo=" + encodeURIComponent("" + withEditableInfo) + "&";
        if (withEditLayout === null)
            throw new Error("The parameter 'withEditLayout' cannot be null.");
        else if (withEditLayout !== undefined)
            url_ += "withEditLayout=" + encodeURIComponent("" + withEditLayout) + "&";
        if (withViewLayout === null)
            throw new Error("The parameter 'withViewLayout' cannot be null.");
        else if (withViewLayout !== undefined)
            url_ += "withViewLayout=" + encodeURIComponent("" + withViewLayout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ApiTestCase> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestCase;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestCase>(null as any);
    }

    /**
     * Update test case
     * @param id The id of the test case to modify.
     * @param update This object contains the changes which should be performed.
     * @param explicitLock (optional) Indicates that the test case has been explicitly locked before this request.
     * @param applyDefaultValues (optional) Indicates whether default values should be applied for fields which are not included in the request.
     */
    update(id: number, update: ApiItemUpdateWithTestDataAndTestSteps, explicitLock?: boolean | undefined, applyDefaultValues?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (explicitLock === null)
            throw new Error("The parameter 'explicitLock' cannot be null.");
        else if (explicitLock !== undefined)
            url_ += "explicitLock=" + encodeURIComponent("" + explicitLock) + "&";
        if (applyDefaultValues === null)
            throw new Error("The parameter 'applyDefaultValues' cannot be null.");
        else if (applyDefaultValues !== undefined)
            url_ += "applyDefaultValues=" + encodeURIComponent("" + applyDefaultValues) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete test case
     * @param id The id of the test case.
     */
    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get attachments metadata as list
     * @param id The id of the test case.
     * @return A list with meta information on all the attachments of this test case.
     */
    getAttachments(id: number): Promise<ApiAttachmentInfo[]> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Attachment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachments(_response);
        });
    }

    protected processGetAttachments(response: Response): Promise<ApiAttachmentInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo[]>(null as any);
    }

    /**
     * Create attachment
     * @param id The id of the test case.
     * @param filename (optional) The filename of the attachment. This parameter is optional. If it
                is not specified, the file name from the multi part form data will be used.
     * @param file (optional) 
     * @return The metadata of the created attachment.
     */
    addAttachment(id: number, filename?: string | null | undefined, file?: FileParameter[] | undefined): Promise<ApiAttachmentInfo> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Attachment?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (filename !== undefined && filename !== null)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddAttachment(_response);
        });
    }

    protected processAddAttachment(response: Response): Promise<ApiAttachmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo>(null as any);
    }

    /**
     * Get attachment metadata
     * @param id The id of the test case.
     * @param attachmentId The id of the attachment.
     * @return The meta information for the specified attachment.
     */
    getAttachment(id: number, attachmentId: number): Promise<ApiAttachmentInfo> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Attachment/{attachmentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachment(_response);
        });
    }

    protected processGetAttachment(response: Response): Promise<ApiAttachmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo>(null as any);
    }

    /**
     * Delete attachment
     * @param id The id of the test case.
     * @param attachmentId The id of the attachment.
     */
    deleteAttachment(id: number, attachmentId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Attachment/{attachmentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteAttachment(_response);
        });
    }

    protected processDeleteAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get attachment
     * @param id The id of the test case.
     * @param attachmentId The id of the attachment.
     * @param download (optional) When true, the response contains a content-disposition header to
                force the browser to download the attachment.
     * @param token (optional) Optional OAuth token.
     * @param tenantId (optional) The ID of the tenant. Only required in multi-tenant environments.
     * @return The file content of the attachment.
     */
    getAttachmentData(id: number, attachmentId: number, download?: boolean | undefined, token?: string | null | undefined, tenantId?: number | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Attachment/{attachmentId}/data?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        if (download === null)
            throw new Error("The parameter 'download' cannot be null.");
        else if (download !== undefined)
            url_ += "download=" + encodeURIComponent("" + download) + "&";
        if (token !== undefined && token !== null)
            url_ += "access_token=" + encodeURIComponent("" + token) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachmentData(_response);
        });
    }

    protected processGetAttachmentData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 307) {
            return response.text().then((_responseText) => {
            let result307: any = null;
            result307 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRedirectResult;
            return throwException("The request is redirected.", status, _responseText, _headers, result307);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Start automated test case execution
     * @param id The id of the test case.
     * @param executionInfo Contains the information necessary to start the test case execution.
     */
    executeAutomated(id: number, executionInfo: ApiAutomatedTestCaseExecution): Promise<number> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/AutomatedExecution";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(executionInfo);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExecuteAutomated(_response);
        });
    }

    protected processExecuteAutomated(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get fields edit meta
     * @param id The id of the test case for which the edit meta is requested.
     * @param statusTo The id of the status we are switching to.
     * @return Basic information on the fields of the test case.
     */
    editMeta(id: number, statusTo: number): Promise<ApiTestCaseEditMeta> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/EditMeta?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (statusTo === undefined || statusTo === null)
            throw new Error("The parameter 'statusTo' must be defined and cannot be null.");
        else
            url_ += "statusTo=" + encodeURIComponent("" + statusTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEditMeta(_response);
        });
    }

    protected processEditMeta(response: Response): Promise<ApiTestCaseEditMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestCaseEditMeta;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestCaseEditMeta>(null as any);
    }

    /**
     * Get edit status
     * @param id The id of the test case.
     */
    getEditStatus(id: number): Promise<ApiItemEditStatus> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/EditStatus";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEditStatus(_response);
        });
    }

    protected processGetEditStatus(response: Response): Promise<ApiItemEditStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemEditStatus;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemEditStatus>(null as any);
    }

    /**
     * Get test case executions as list
     * @param id The id of the test case.
     * @param filter (optional) The filter syntax is as follows:
                [ExecutionDate]=#2022-01-21# and [Version]!=12 and [TestedVersion]='v1'
     * @param startAt (optional) Number of results to skip when the results are fetched.
                Can be used for pagination.
     * @param maxResults (optional) Maximum number of results which are fetched.
                Can be used for pagination.
     * @param orderBy (optional) Comma-separated list of properties which should be used to order
                the result list. ASC or DESC can be appended to indicate the sort order. Ascending sort
                order is assumed by default.
     */
    getTestExecutions(id: number, filter?: string | null | undefined, startAt?: number | undefined, maxResults?: number | undefined, orderBy?: string | null | undefined): Promise<ApiPaginatedResultOfApiTestExecutionInfo> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Execution?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestExecutions(_response);
        });
    }

    protected processGetTestExecutions(response: Response): Promise<ApiPaginatedResultOfApiTestExecutionInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPaginatedResultOfApiTestExecutionInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPaginatedResultOfApiTestExecutionInfo>(null as any);
    }

    /**
     * Create test case execution preview
     * @param id The id of the test case.
     * @param tePreviewModel List of values which will be considered in the preview.
     * @param richTextFormatToInclude (optional) This enum determinates wich information should be included in the richtext.
     */
    previewTestExecution(id: number, tePreviewModel: ApiTestCaseExecutionPreviewRequest, richTextFormatToInclude?: ApiRichTextIncludeType | undefined): Promise<ApiTestCaseExecutionPreviewResponse> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Execution/Preview?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (richTextFormatToInclude === null)
            throw new Error("The parameter 'richTextFormatToInclude' cannot be null.");
        else if (richTextFormatToInclude !== undefined)
            url_ += "richTextFormatToInclude=" + encodeURIComponent("" + richTextFormatToInclude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tePreviewModel);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPreviewTestExecution(_response);
        });
    }

    protected processPreviewTestExecution(response: Response): Promise<ApiTestCaseExecutionPreviewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestCaseExecutionPreviewResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestCaseExecutionPreviewResponse>(null as any);
    }

    /**
     * Update test case execution defaults
     * @param id The id of the test case.
     * @param update This object contains the changes which should be performed.
     */
    updateExecutionDefaults(id: number, update: ApiTestCaseExecutionDefaultsUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/ExecutionDefaults";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateExecutionDefaults(_response);
        });
    }

    protected processUpdateExecutionDefaults(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get test case executions as list
     * @param id The id of the test case.
     * @param max Maximum number of executions to return. Default is 100.
     * @param excludeIrrelevantExecutions (optional) If set, executions which are marked as irrelevant will be excluded. Default is false.
     * @deprecated
     */
    getTestJobExecutions(id: number, max: number, excludeIrrelevantExecutions?: boolean | undefined): Promise<ApiTestExecutionInfo[]> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Executions/{max}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (max === undefined || max === null)
            throw new Error("The parameter 'max' must be defined.");
        url_ = url_.replace("{max}", encodeURIComponent("" + max));
        if (excludeIrrelevantExecutions === null)
            throw new Error("The parameter 'excludeIrrelevantExecutions' cannot be null.");
        else if (excludeIrrelevantExecutions !== undefined)
            url_ += "excludeIrrelevantExecutions=" + encodeURIComponent("" + excludeIrrelevantExecutions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestJobExecutions(_response);
        });
    }

    protected processGetTestJobExecutions(response: Response): Promise<ApiTestExecutionInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestExecutionInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestExecutionInfo[]>(null as any);
    }

    /**
     * Get history
     * @param id The id of the test case.
     * @return A list with all changes in chronological order.
     */
    getHistory(id: number): Promise<ApiHistoryEntryTestCase[]> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/History";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetHistory(_response);
        });
    }

    protected processGetHistory(response: Response): Promise<ApiHistoryEntryTestCase[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiHistoryEntryTestCase[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiHistoryEntryTestCase[]>(null as any);
    }

    /**
     * Create lock
     * @param id The id of the test case to lock.
     * @param lockInfo Contains the information necessary to acquire a lock.
     */
    createLock(id: number, lockInfo: ApiLockNew): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lockInfo);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateLock(_response);
        });
    }

    protected processCreateLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete lock
     * @param id The id of the test case for which the lock should be released.
     */
    deleteLock(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteLock(_response);
        });
    }

    protected processDeleteLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get posts
     * @param id The id of the testcase.
     * @param firstResult (optional) The first result wich should be fetched. The default value is 0.
     * @param maxResults (optional) The maximal number of results wich should be fetched. The default value is 100.
     * @param ascending (optional) The sorting order of the result. If true sorted ascending otherwise descending. The default value is true.
     * @return A list of paginated posts associated with the given testcase and the total count of all posts for this testcase.
     */
    getPosts(id: number, firstResult?: number | undefined, maxResults?: number | undefined, ascending?: boolean | undefined): Promise<ApiPostPaginated> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Post?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (firstResult === null)
            throw new Error("The parameter 'firstResult' cannot be null.");
        else if (firstResult !== undefined)
            url_ += "firstResult=" + encodeURIComponent("" + firstResult) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (ascending === null)
            throw new Error("The parameter 'ascending' cannot be null.");
        else if (ascending !== undefined)
            url_ += "ascending=" + encodeURIComponent("" + ascending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPosts(_response);
        });
    }

    protected processGetPosts(response: Response): Promise<ApiPostPaginated> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostPaginated;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostPaginated>(null as any);
    }

    /**
     * Create post
     * @param id The id of the testcase in which the new post should be created.
     * @param content The content of the new post. The content must be provided in exactly one format.
     * @return The meta information of the new post.
     */
    createPost(id: number, content: ApiRichText): Promise<ApiPostInfo> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Post";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreatePost(_response);
        });
    }

    protected processCreatePost(response: Response): Promise<ApiPostInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostInfo>(null as any);
    }

    /**
     * Get post
     * @param id The id of the testcase.
     * @param postId The id of the post.
     * @return The requested post.
     */
    getPost(id: number, postId: number): Promise<ApiPost> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Post/{postId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPost(_response);
        });
    }

    protected processGetPost(response: Response): Promise<ApiPost> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPost;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPost>(null as any);
    }

    /**
     * Replace post
     * @param id The id of the testcase.
     * @param postId The id of the post which should be replaced.
     * @param content The new content of the post. The content must be provided in exactly one format.
     * @return The meta information of the replaced post.
     */
    updatePost(id: number, postId: number, content: ApiRichText): Promise<ApiPostInfo> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Post/{postId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePost(_response);
        });
    }

    protected processUpdatePost(response: Response): Promise<ApiPostInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostInfo>(null as any);
    }

    /**
     * Delete post
     * @param id The id of the testcase.
     * @param postId The id of the post which should be deleted.
     * @return The meta information of the deleted post.
     */
    deletePost(id: number, postId: number): Promise<ApiPostInfo> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Post/{postId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeletePost(_response);
        });
    }

    protected processDeletePost(response: Response): Promise<ApiPostInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostInfo;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostInfo>(null as any);
    }

    /**
     * Get relations
     * @param id The id of the test case.
     * @param depth (optional) The depth to which the relations are loaded. Depth 2 means that
                that the relations of relations are also loaded and so on. The default is 1.
     * @param maxItemsPerType (optional) The next level of relations is only loaded if at most
                this number of items of a certain type is present. Otherwise, the tree is cutoff.
                When this limit is not specified, this call might take a long time if the depth is
                greater than 1.
     * @param include (optional) Comma separated list of the data to include in the response.
                Supported includes: Relations.OtherItem.*Info to load basic info on the relation target,
                Relations.OtherItem.*Details to load the details of the relation target,
                Item.*Info to load basic info on the item for which the relations were requested,
                Item.*Details to load the details of the item for which the relations were requested.
     * @param fields (optional) The ids of the fields which should be included when details are included.
                When left empty, all fields will be included.
     * @return A list with all the relations together with some additional information.
     */
    getRelations(id: number, depth?: number | undefined, maxItemsPerType?: number | null | undefined, include?: string | null | undefined, fields?: string | null | undefined): Promise<ApiRelations> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Relation?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (depth === null)
            throw new Error("The parameter 'depth' cannot be null.");
        else if (depth !== undefined)
            url_ += "depth=" + encodeURIComponent("" + depth) + "&";
        if (maxItemsPerType !== undefined && maxItemsPerType !== null)
            url_ += "maxItemsPerType=" + encodeURIComponent("" + maxItemsPerType) + "&";
        if (include !== undefined && include !== null)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        if (fields !== undefined && fields !== null)
            url_ += "fields=" + encodeURIComponent("" + fields) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRelations(_response);
        });
    }

    protected processGetRelations(response: Response): Promise<ApiRelations> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelations;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelations>(null as any);
    }

    /**
     * Create relation
     * @param id The id of the test case.
     * @param relation The other information necessary to create the relation.
     * @return The created relation.
     */
    createRelation(id: number, relation: ApiRelationNew): Promise<ApiRelation> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Relation";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(relation);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateRelation(_response);
        });
    }

    protected processCreateRelation(response: Response): Promise<ApiRelation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelation;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelation>(null as any);
    }

    /**
     * Delete relation
     * @param id The id of the test case.
     * @param relationId The id of the relation.
     */
    deleteRelations(id: number, relationId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Relation/{relationId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (relationId === undefined || relationId === null)
            throw new Error("The parameter 'relationId' must be defined.");
        url_ = url_.replace("{relationId}", encodeURIComponent("" + relationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteRelations(_response);
        });
    }

    protected processDeleteRelations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get relation metadata
     * @param id The id of the test case.
     * @return The metadata required to create new relations.
     */
    getRelationCreateMeta(id: number): Promise<ApiRelationCreateMeta> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Relation/CreateMeta";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRelationCreateMeta(_response);
        });
    }

    protected processGetRelationCreateMeta(response: Response): Promise<ApiRelationCreateMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelationCreateMeta;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelationCreateMeta>(null as any);
    }

    /**
     * Create new value set (in test data)
     * @param id The id of the test case.
     * @param valueSet Value set to be saved.
     */
    addTestDataValueSet(id: number, valueSet: ApiTestDataValueSetNew): Promise<string> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestData";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(valueSet);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddTestDataValueSet(_response);
        });
    }

    protected processAddTestDataValueSet(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Update test data (of a test case)
     * @param id The id of the test case.
     * @param testData Updated test data.
     */
    updateTestData(id: number, testData: ApiTestDataUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestData";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(testData);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateTestData(_response);
        });
    }

    protected processUpdateTestData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get test data
     * @param id The id of the test case.
     * @param include (optional) Controls the amount of data to load. The comma-separated list
                can contain the following values: ValueSets, Variables, Values, IsReferenced, Fields. The default is
                ValueSets.
     * @param resolveFormulas (optional) If true all formulas are resolved and returned as text (default: false).
     */
    getTestData(id: number, include?: string | null | undefined, resolveFormulas?: boolean | undefined): Promise<ApiTestData> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestData?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (include !== undefined && include !== null)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        if (resolveFormulas === null)
            throw new Error("The parameter 'resolveFormulas' cannot be null.");
        else if (resolveFormulas !== undefined)
            url_ += "resolveFormulas=" + encodeURIComponent("" + resolveFormulas) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestData(_response);
        });
    }

    protected processGetTestData(response: Response): Promise<ApiTestData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestData;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestData>(null as any);
    }

    /**
     * Delete value set
     * @param id The id of the test case.
     * @param valueSetGuid The guid of the value set.
     */
    deleteTestDataValueSet(id: number, valueSetGuid: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestData/{valueSetGuid}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (valueSetGuid === undefined || valueSetGuid === null)
            throw new Error("The parameter 'valueSetGuid' must be defined.");
        url_ = url_.replace("{valueSetGuid}", encodeURIComponent("" + valueSetGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteTestDataValueSet(_response);
        });
    }

    protected processDeleteTestDataValueSet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update a given value set
     * @param id The id of the test case.
     * @param valueSetGuid The guid of the value set.
     * @param valueSet Value set data.
     */
    updateTestDataValueSet(id: number, valueSetGuid: string | null, valueSet: ApiTestDataValueSetUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestData/{valueSetGuid}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (valueSetGuid === undefined || valueSetGuid === null)
            throw new Error("The parameter 'valueSetGuid' must be defined.");
        url_ = url_.replace("{valueSetGuid}", encodeURIComponent("" + valueSetGuid));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(valueSet);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateTestDataValueSet(_response);
        });
    }

    protected processUpdateTestDataValueSet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get value set
     * @param id The id of the test case.
     * @param valueSetGuid The GUID of the value set.
     * @param resolveFormulas (optional) If true all formulas are resolved and returned as text (default: false).
     */
    getValueSet(id: number, valueSetGuid: string | null, resolveFormulas?: boolean | undefined): Promise<ApiTestDataValueSet> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestData/{valueSetGuid}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (valueSetGuid === undefined || valueSetGuid === null)
            throw new Error("The parameter 'valueSetGuid' must be defined.");
        url_ = url_.replace("{valueSetGuid}", encodeURIComponent("" + valueSetGuid));
        if (resolveFormulas === null)
            throw new Error("The parameter 'resolveFormulas' cannot be null.");
        else if (resolveFormulas !== undefined)
            url_ += "resolveFormulas=" + encodeURIComponent("" + resolveFormulas) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetValueSet(_response);
        });
    }

    protected processGetValueSet(response: Response): Promise<ApiTestDataValueSet> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestDataValueSet;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestDataValueSet>(null as any);
    }

    /**
     * Export test data
     * @param id The id of the testcase.
     * @param fileFormat (optional) The file format in which the testdata should be exported
     * @return The exported test data in the requested file format.
     */
    exportTestData(id: number, fileFormat?: ApiTestDataFileFormat | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestData/Transfer?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileFormat !== undefined && fileFormat !== null)
            url_ += "fileFormat=" + encodeURIComponent("" + fileFormat) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExportTestData(_response);
        });
    }

    protected processExportTestData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Import test data
     * @param id The id of the test case.
     * @param fileName (optional) The name of the file to import. This parameter is optional.
                The file name must be specified either here or as part of the multipart form data. 
                The name must include the file extension otherwise the request will be rejected.
     * @param convertDateTime (optional) A flag to convert DateTime fields in xls and xlsx to String on import.
     * @param file (optional) 
     */
    importTestData(id: number, fileName?: string | null | undefined, convertDateTime?: boolean | undefined, file?: FileParameter[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestData/Transfer?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (convertDateTime === null)
            throw new Error("The parameter 'convertDateTime' cannot be null.");
        else if (convertDateTime !== undefined)
            url_ += "convertDateTime=" + encodeURIComponent("" + convertDateTime) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImportTestData(_response);
        });
    }

    protected processImportTestData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Import test data preview
     * @param id The id of the test case.
     * @param fileName (optional) The name of the file to import. This parameter is optional.
                The file name must be specified either here or as part of the multipart form data. 
                The name must include the file extension otherwise the request will be rejected.
     * @param convertDateTime (optional) A flag to convert DateTime fields in xls and xlsx to String on import.
     * @param file (optional) 
     */
    importTestDataWithoutSave(id: number, fileName?: string | null | undefined, convertDateTime?: boolean | undefined, file?: FileParameter[] | undefined): Promise<ApiTestData> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestData/Transfer/NoSave?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (convertDateTime === null)
            throw new Error("The parameter 'convertDateTime' cannot be null.");
        else if (convertDateTime !== undefined)
            url_ += "convertDateTime=" + encodeURIComponent("" + convertDateTime) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImportTestDataWithoutSave(_response);
        });
    }

    protected processImportTestDataWithoutSave(response: Response): Promise<ApiTestData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestData;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestData>(null as any);
    }

    /**
     * Get test steps as list
     * @param id The id of the test case.
     * @param includeAutomation (optional) If true, then automation (if any) is returned as part of step data. Default is true.
     */
    getTestSteps(id: number, includeAutomation?: boolean | undefined): Promise<ApiTestStep[]> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestStep?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includeAutomation === null)
            throw new Error("The parameter 'includeAutomation' cannot be null.");
        else if (includeAutomation !== undefined)
            url_ += "includeAutomation=" + encodeURIComponent("" + includeAutomation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestSteps(_response);
        });
    }

    protected processGetTestSteps(response: Response): Promise<ApiTestStep[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestStep[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestStep[]>(null as any);
    }

    /**
     * Create test step
     * @param id The id of the test case.
     * @param newStep New step data.
     */
    createTestStep(id: number, newStep: ApiTestStepNew): Promise<ApiAddSingleTestStepResponse> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestStep";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newStep);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateTestStep(_response);
        });
    }

    protected processCreateTestStep(response: Response): Promise<ApiAddSingleTestStepResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAddSingleTestStepResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAddSingleTestStepResponse>(null as any);
    }

    /**
     * Get test step
     * @param id The id of the test case.
     * @param stepId The id of the step.
     * @param includeAutomation (optional) If true, then automation (if any) is returned as part of step data. Default is true.
     */
    getTestStep(id: number, stepId: number, includeAutomation?: boolean | undefined): Promise<ApiTestStep[]> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestStep/{stepId}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId));
        if (includeAutomation === null)
            throw new Error("The parameter 'includeAutomation' cannot be null.");
        else if (includeAutomation !== undefined)
            url_ += "includeAutomation=" + encodeURIComponent("" + includeAutomation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestStep(_response);
        });
    }

    protected processGetTestStep(response: Response): Promise<ApiTestStep[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestStep[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestStep[]>(null as any);
    }

    /**
     * Update test step
     * @param id The id of the test case.
     * @param stepId The id of the step.
     * @param update Updated step data.
     */
    updateTestStep(id: number, stepId: number, update: ApiTestStepUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestStep/{stepId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateTestStep(_response);
        });
    }

    protected processUpdateTestStep(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete test step
     * @param id The id of the test case.
     * @param stepId The id of the step.
     */
    deleteTestStep(id: number, stepId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestStep/{stepId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteTestStep(_response);
        });
    }

    protected processDeleteTestStep(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get automation script
     * @param id The id of the test case.
     * @param stepId The id of the test step.
     * @param attachmentScriptFileId The id of the attached file.
     * @param download (optional) When true, the response contains a content-disposition header to
                force the browser to download the attachment.
     * @param token (optional) Optional OAuth token.
     * @return The file content of the attached file.
     */
    getTestCaseAttachedScriptFileData(id: number, stepId: number, attachmentScriptFileId: number, download?: boolean | undefined, token?: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestStep/{stepId}/AttachedScriptFile/{attachmentScriptFileId}/data?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId));
        if (attachmentScriptFileId === undefined || attachmentScriptFileId === null)
            throw new Error("The parameter 'attachmentScriptFileId' must be defined.");
        url_ = url_.replace("{attachmentScriptFileId}", encodeURIComponent("" + attachmentScriptFileId));
        if (download === null)
            throw new Error("The parameter 'download' cannot be null.");
        else if (download !== undefined)
            url_ += "download=" + encodeURIComponent("" + download) + "&";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestCaseAttachedScriptFileData(_response);
        });
    }

    protected processGetTestCaseAttachedScriptFileData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get test step automation
     * @param id The id of the test case.
     * @param stepId The id of the step.
     */
    getTestStepAutomation(id: number, stepId: number): Promise<ApiTestStep[]> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/TestStep/{stepId}/Automation";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (stepId === undefined || stepId === null)
            throw new Error("The parameter 'stepId' must be defined.");
        url_ = url_.replace("{stepId}", encodeURIComponent("" + stepId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestStepAutomation(_response);
        });
    }

    protected processGetTestStepAutomation(response: Response): Promise<ApiTestStep[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestStep[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestStep[]>(null as any);
    }

    /**
     * Get watching users as list
     * @param id The id of the test case.
     * @return List of users watching this test case.
     */
    getWatchers(id: number): Promise<ApiUserInfo[]> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetWatchers(_response);
        });
    }

    protected processGetWatchers(response: Response): Promise<ApiUserInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUserInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiUserInfo[]>(null as any);
    }

    /**
     * Add to watch list
     * @param id The id of the test case.
     * @param newWatcher Contains id of the user to be subscribed.
     */
    addWatcher(id: number, newWatcher: ApiWatcherNew): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newWatcher);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddWatcher(_response);
        });
    }

    protected processAddWatcher(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Updates the watch list
     * @param id The id of the test case.
     * @param watchersUpdate Contains the id of the user to be (un-)subscribed.
     */
    updateWatchers(id: number, watchersUpdate: ApiWatchersUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(watchersUpdate);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateWatchers(_response);
        });
    }

    protected processUpdateWatchers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove from watch list
     * @param id The id of the test case.
     * @param userId The id of the user to be unsubscribed.
     */
    removeWatcher(id: number, userId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{id}/Watchers/{userId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveWatcher(_response);
        });
    }

    protected processRemoveWatcher(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return or
     */
    connectByExternalId(testCaseId: number, data: any): Promise<void> {
        let url_ = this.baseUrl + "/api/TestCase/{testCaseId}/ExternalRef";
        if (testCaseId === undefined || testCaseId === null)
            throw new Error("The parameter 'testCaseId' must be defined.");
        url_ = url_.replace("{testCaseId}", encodeURIComponent("" + testCaseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConnectByExternalId(_response);
        });
    }

    protected processConnectByExternalId(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get fields metadata
     * @param projectId The id of the project.
     * @param folderId The id of the folder where the test case will be created (0 means root level).
     * @param statusTo (optional) The id of status with which the new item will be saved. Workflow
                restrictions might depend on this status and hence the meta data might change depending
                on the selected status. If no status id is provided, the default value for the status
                is assumed.
     * @return Basic information on the fields of a new test case created in given project and folder.
     */
    createMeta(projectId: number, folderId: number, statusTo?: number | null | undefined): Promise<ApiTestCaseCreateMeta> {
        let url_ = this.baseUrl + "/api/TestCase/CreateMeta?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined and cannot be null.");
        else
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (statusTo !== undefined && statusTo !== null)
            url_ += "statusTo=" + encodeURIComponent("" + statusTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMeta(_response);
        });
    }

    protected processCreateMeta(response: Response): Promise<ApiTestCaseCreateMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestCaseCreateMeta;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestCaseCreateMeta>(null as any);
    }

    fetchByExternalId(integrationTypeStr: string | null, externalId: string | null): Promise<ApiExternalInfo[]> {
        let url_ = this.baseUrl + "/api/TestCase/ExternalRef/{integrationTypeStr}/{externalId}";
        if (integrationTypeStr === undefined || integrationTypeStr === null)
            throw new Error("The parameter 'integrationTypeStr' must be defined.");
        url_ = url_.replace("{integrationTypeStr}", encodeURIComponent("" + integrationTypeStr));
        if (externalId === undefined || externalId === null)
            throw new Error("The parameter 'externalId' must be defined.");
        url_ = url_.replace("{externalId}", encodeURIComponent("" + externalId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processFetchByExternalId(_response);
        });
    }

    protected processFetchByExternalId(response: Response): Promise<ApiExternalInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiExternalInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiExternalInfo[]>(null as any);
    }

    /**
     * For each test case check if there are steps
     * @param testCaseIds The array of test case Ids
     * @return A boolean indicating for each test case if there are test steps or not
     */
    testCasesHaveSteps(testCaseIds: number[]): Promise<ApiTestCasesHaveStepsResponse> {
        let url_ = this.baseUrl + "/api/TestCase/HaveSteps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(testCaseIds);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTestCasesHaveSteps(_response);
        });
    }

    protected processTestCasesHaveSteps(response: Response): Promise<ApiTestCasesHaveStepsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestCasesHaveStepsResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestCasesHaveStepsResponse>(null as any);
    }

    /**
     * Get test cases
     * @param projectId The id of the project of which the items are loaded.
     * @param folderId (optional) The id of the folder of which the items are loaded.
     * @param includeSubfolders (optional) Indicates whether items from sub folders should be included.
     * @param includeArchived (optional) Indicates whether archieved items should be included.
     * @param filter (optional) The filter syntax is as follows:
                [["Priority", "=", "High"], "and", ["DateCreatedDateTime", ">=", "2018-01-01"]]
                The field meta data can be used to check which filter operators are supported for which fields.
     * @param sorting (optional) The sorting syntax is as follows:
                [["Significane", "desc"], ["Status", "asc]]
                The field meta data can be used to check which fields support sorting.
     * @param search (optional) A fulltext search will be performed with this term and only matching
                items will be included in the result
     * @param startAt (optional) The index of the first item which should be included. Allows pagination
                of the results.
     * @param maxResults (optional) The maximum number of items to return. Allows pagination of the results.
     * @return A list of items matching the given criteria.
     */
    getItemList(projectId: number, folderId?: number | undefined, includeSubfolders?: boolean | undefined, includeArchived?: boolean | undefined, filter?: string | null | undefined, sorting?: string | null | undefined, search?: string | null | undefined, startAt?: number | undefined, maxResults?: number | undefined): Promise<ApiItemListResult> {
        let url_ = this.baseUrl + "/api/TestCase/ItemList?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (includeSubfolders === null)
            throw new Error("The parameter 'includeSubfolders' cannot be null.");
        else if (includeSubfolders !== undefined)
            url_ += "includeSubfolders=" + encodeURIComponent("" + includeSubfolders) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetItemList(_response);
        });
    }

    protected processGetItemList(response: Response): Promise<ApiItemListResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemListResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemListResult>(null as any);
    }

    getTestDataPlaceholders(projectId: number): Promise<ApiFieldPlaceholders> {
        let url_ = this.baseUrl + "/api/TestCase/TestData/Placeholder?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestDataPlaceholders(_response);
        });
    }

    protected processGetTestDataPlaceholders(response: Response): Promise<ApiFieldPlaceholders> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiFieldPlaceholders;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiFieldPlaceholders>(null as any);
    }

    /**
     * Create test data preview
     * @param data Matrix of test data (doesn't have to be saved - it is just a matrix of strings).
     * @return Converted test data.
     */
    previewTestData(data: ApiTestDataPreview): Promise<ApiTestDataPreview> {
        let url_ = this.baseUrl + "/api/TestCase/TestData/Preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPreviewTestData(_response);
        });
    }

    protected processPreviewTestData(response: Response): Promise<ApiTestDataPreview> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestDataPreview;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestDataPreview>(null as any);
    }
}

export class TestExecutionClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Create manual test executions
     * @param apiExecutions The list of test executions to create.
     * @return A list with basic information regarding the created test executions.
     */
    create(apiExecutions: ApiTestExecutionNew[]): Promise<ApiTestExecutionNewResponse> {
        let url_ = this.baseUrl + "/api/TestExecution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiExecutions);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ApiTestExecutionNewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestExecutionNewResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestExecutionNewResponse>(null as any);
    }

    /**
     * Update manual test executions
     * @param apiExecutions The list of test executions to update.
     * @param explicitLock (optional) Indicates that all test executions has been explicitly locked before this request.
     */
    update2(apiExecutions: ApiTestExecutionUpdate[], explicitLock?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/TestExecution?";
        if (explicitLock === null)
            throw new Error("The parameter 'explicitLock' cannot be null.");
        else if (explicitLock !== undefined)
            url_ += "explicitLock=" + encodeURIComponent("" + explicitLock) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiExecutions);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate2(_response);
        });
    }

    protected processUpdate2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Modify test executions
     * @return The guid of the long running task if the operation was cancel otherwise nothing.
     */
    modifyExecutionsRelevance(request: ApiTestExecutionPatchRequest): Promise<ApiTestExecutionPatchResponse> {
        let url_ = this.baseUrl + "/api/TestExecution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyExecutionsRelevance(_response);
        });
    }

    protected processModifyExecutionsRelevance(response: Response): Promise<ApiTestExecutionPatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestExecutionPatchResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestExecutionPatchResponse>(null as any);
    }

    /**
     * Get test execution
     * @param id The id of the test execution to retrive.
     * @param richTextFormatToInclude (optional) This enum determinates wich information should be included in the richtext.
     * @return Test execution object
     */
    getTestExecution(id: number, richTextFormatToInclude?: ApiRichTextIncludeType | undefined): Promise<ApiTestExecution> {
        let url_ = this.baseUrl + "/api/TestExecution/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (richTextFormatToInclude === null)
            throw new Error("The parameter 'richTextFormatToInclude' cannot be null.");
        else if (richTextFormatToInclude !== undefined)
            url_ += "richTextFormatToInclude=" + encodeURIComponent("" + richTextFormatToInclude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestExecution(_response);
        });
    }

    protected processGetTestExecution(response: Response): Promise<ApiTestExecution> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestExecution;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestExecution>(null as any);
    }

    /**
     * Update manual test execution
     * @param id The id of test execution to update.
     * @param apiExecution The test execution to update.
     * @param explicitLock (optional) Indicates that all test executions has been explicitly locked before this request.
     */
    update(id: number, apiExecution: ApiTestExecutionUpdate, explicitLock?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/TestExecution/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (explicitLock === null)
            throw new Error("The parameter 'explicitLock' cannot be null.");
        else if (explicitLock !== undefined)
            url_ += "explicitLock=" + encodeURIComponent("" + explicitLock) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiExecution);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Add attachment
     * @param id The id of the test execution.
     * @param fileName (optional) The filename of the attachment. This parameter is optional. If it
                is not specified, the file name from the multi part form data will be used.
     * @param file (optional) 
     * @return The short information about the created attachment.
     */
    addAttachment(id: number, fileName?: string | null | undefined, file?: FileParameter[] | undefined): Promise<ApiAttachmentInfo> {
        let url_ = this.baseUrl + "/api/TestExecution/{id}/Attachment?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddAttachment(_response);
        });
    }

    protected processAddAttachment(response: Response): Promise<ApiAttachmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo>(null as any);
    }

    /**
     * Delete attachment
     * @param id The id of the test execution.
     * @param attachmentId The id of the attachment.
     */
    deleteAttachment(id: number, attachmentId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TestExecution/{id}/Attachment/{attachmentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteAttachment(_response);
        });
    }

    protected processDeleteAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get attachment
     * @param id The id of the execution.
     * @param attachmentId The id of the attachment.
     * @param download (optional) When true, the response contains a content-disposition header to
                force the browser to download the attachment.
     * @param token (optional) Optional OAuth token.
     * @param tenantId (optional) The ID of the tenant. Only required in multi-tenant environments.
     * @return The file content of the attachment.
     */
    getAttachmentData(id: number, attachmentId: number, download?: boolean | undefined, token?: string | null | undefined, tenantId?: number | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TestExecution/{id}/Attachment/{attachmentId}/data?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        if (download === null)
            throw new Error("The parameter 'download' cannot be null.");
        else if (download !== undefined)
            url_ += "download=" + encodeURIComponent("" + download) + "&";
        if (token !== undefined && token !== null)
            url_ += "access_token=" + encodeURIComponent("" + token) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachmentData(_response);
        });
    }

    protected processGetAttachmentData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 307) {
            return response.text().then((_responseText) => {
            let result307: any = null;
            result307 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRedirectResult;
            return throwException("The request is redirected.", status, _responseText, _headers, result307);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get edit status
     * @param id The id of the test execution.
     */
    getTestExecutionEditStatus(id: number): Promise<ApiEditStatus> {
        let url_ = this.baseUrl + "/api/TestExecution/{id}/EditStatus";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestExecutionEditStatus(_response);
        });
    }

    protected processGetTestExecutionEditStatus(response: Response): Promise<ApiEditStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiEditStatus;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiEditStatus>(null as any);
    }

    /**
     * Create lock
     * @param id The id of the test execution to lock.
     * @param lockInfo Contains the information necessary to acquire a lock.
     */
    createLock(id: number, lockInfo: ApiLockNew): Promise<void> {
        let url_ = this.baseUrl + "/api/TestExecution/{id}/Lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lockInfo);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateLock(_response);
        });
    }

    protected processCreateLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete lock
     * @param id The id of the test execution for which the lock should be released.
     */
    deleteLock(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TestExecution/{id}/Lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteLock(_response);
        });
    }

    protected processDeleteLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get test execution relations
     * @param id The id of the execution.
     * @param depth (optional) The depth to which the relations are loaded. Depth 2 means that
                that the relations of relations are also loaded and so on. The default is 1.
     * @param maxItemsPerType (optional) The next level of relations is only loaded if at most
                this number of items of a certain type is present. Otherwise, the tree is cutoff.
                When this limit is not specified, this call might take a long time if the depth is
                greater than 1.
     * @param include (optional) Comma separated list of the data to include in the response.
                Supported includes: 
                `Relations.OtherItem.*Info` to load basic info on the relation target,
                `Relations.OtherItem.*Details` to load the details of the relation target,
                `Item.*Info` to load basic info on the item for which the relations were requested,
                `Item.*Details` to load the details of the item for which the relations were requested.
     * @param fields (optional) The ids of the fields which should be included when details are included.
                When left empty, all fields will be included.
     * @return A list with all the relations together with some additional information.
     */
    getRelations(id: number, depth?: number | undefined, maxItemsPerType?: number | null | undefined, include?: string | null | undefined, fields?: string | null | undefined): Promise<ApiRelations> {
        let url_ = this.baseUrl + "/api/TestExecution/{id}/Relation?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (depth === null)
            throw new Error("The parameter 'depth' cannot be null.");
        else if (depth !== undefined)
            url_ += "depth=" + encodeURIComponent("" + depth) + "&";
        if (maxItemsPerType !== undefined && maxItemsPerType !== null)
            url_ += "maxItemsPerType=" + encodeURIComponent("" + maxItemsPerType) + "&";
        if (include !== undefined && include !== null)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        if (fields !== undefined && fields !== null)
            url_ += "fields=" + encodeURIComponent("" + fields) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRelations(_response);
        });
    }

    protected processGetRelations(response: Response): Promise<ApiRelations> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelations;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelations>(null as any);
    }

    /**
     * Create relation
     * @param id The id of the test execution.
     * @param relation The other information necessary to create the relation.
     * @return The created relation.
     */
    createRelation(id: number, relation: ApiRelationNew): Promise<ApiRelation> {
        let url_ = this.baseUrl + "/api/TestExecution/{id}/Relation";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(relation);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateRelation(_response);
        });
    }

    protected processCreateRelation(response: Response): Promise<ApiRelation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelation;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelation>(null as any);
    }

    /**
     * Get relation metadata
     * @param id The id of the execution.
     * @return The metadata required to create new relations
     */
    getRelationCreateMeta(id: number): Promise<ApiRelationCreateMeta> {
        let url_ = this.baseUrl + "/api/TestExecution/{id}/Relation/CreateMeta";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRelationCreateMeta(_response);
        });
    }

    protected processGetRelationCreateMeta(response: Response): Promise<ApiRelationCreateMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelationCreateMeta;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelationCreateMeta>(null as any);
    }

    /**
     * Update test execution step
     * @param id The id of test execution.
     * @param testStepId The id of test step to update.
     * @param apiStep The test execution to update.
     */
    updateStep(id: number, testStepId: number, apiStep: ApiTestStepExecutionUpdateSingleStep): Promise<void> {
        let url_ = this.baseUrl + "/api/TestExecution/{id}/testStep/{testStepId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (testStepId === undefined || testStepId === null)
            throw new Error("The parameter 'testStepId' must be defined.");
        url_ = url_.replace("{testStepId}", encodeURIComponent("" + testStepId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiStep);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateStep(_response);
        });
    }

    protected processUpdateStep(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Continue test executions
     * @param testExecutionId The id of the test execution to retrive.
     * @param richTextFormatToInclude (optional) This enum determinates wich information should be included in the richtext.
     * @return Test execution object
     */
    continueTestExecution(testExecutionId: number, richTextFormatToInclude?: ApiRichTextIncludeType | undefined): Promise<ApiTestExecutionContinueResponse> {
        let url_ = this.baseUrl + "/api/TestExecution/{testExecutionId}/Continue?";
        if (testExecutionId === undefined || testExecutionId === null)
            throw new Error("The parameter 'testExecutionId' must be defined.");
        url_ = url_.replace("{testExecutionId}", encodeURIComponent("" + testExecutionId));
        if (richTextFormatToInclude === null)
            throw new Error("The parameter 'richTextFormatToInclude' cannot be null.");
        else if (richTextFormatToInclude !== undefined)
            url_ += "richTextFormatToInclude=" + encodeURIComponent("" + richTextFormatToInclude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processContinueTestExecution(_response);
        });
    }

    protected processContinueTestExecution(response: Response): Promise<ApiTestExecutionContinueResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestExecutionContinueResponse;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestExecutionContinueResponse>(null as any);
    }

    /**
     * Execute test cases
     * @param request Operation details.
     * @return Guid of the batch operation. 
    Status of the the operation can be retrieved using GET api/System/LongOperation/{guid}/Status or GET api/System/LongOperation/{guid}.
    In case of this batch operation the data retrieved from 'GET api/System/LongOperation/{guid}' contains additional information 
    as defined in ApiItemLongOperationInfo (FailedItems).
    Additionally, SignalR (group "LongOperation_{customerId}_{guid}") can be used to receive information when operation finishes.
     */
    bulkExecutions(request: ApiBulkExecutionsRequest): Promise<ApiLongOperationOfBoolean> {
        let url_ = this.baseUrl + "/api/TestExecution/BulkExecutions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkExecutions(_response);
        });
    }

    protected processBulkExecutions(response: Response): Promise<ApiLongOperationOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperationOfBoolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperationOfBoolean>(null as any);
    }

    getCreateMeta(projectId: number): Promise<ApiTestExecutionCreateMeta> {
        let url_ = this.baseUrl + "/api/TestExecution/CreateMeta?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCreateMeta(_response);
        });
    }

    protected processGetCreateMeta(response: Response): Promise<ApiTestExecutionCreateMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestExecutionCreateMeta;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestExecutionCreateMeta>(null as any);
    }

    /**
     * Get list of basic test executions
     * @param testExecutionIds List of ids of the test executions to retrive.
     * @param richTextFormatToInclude (optional) This enum determinates wich information should be included in the richtext.
     */
    getTestExecutionAll(testExecutionIds: number[], richTextFormatToInclude?: ApiRichTextIncludeType | undefined): Promise<ApiTestExecutionExtendedInfo[]> {
        let url_ = this.baseUrl + "/api/TestExecution/ItemList?";
        if (richTextFormatToInclude === null)
            throw new Error("The parameter 'richTextFormatToInclude' cannot be null.");
        else if (richTextFormatToInclude !== undefined)
            url_ += "richTextFormatToInclude=" + encodeURIComponent("" + richTextFormatToInclude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(testExecutionIds);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestExecutionAll(_response);
        });
    }

    protected processGetTestExecutionAll(response: Response): Promise<ApiTestExecutionExtendedInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestExecutionExtendedInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestExecutionExtendedInfo[]>(null as any);
    }

    /**
     * Create locks
     * @param itemsToLock The list of test execution ids with necessary information for creating an lock
     */
    createLocks(itemsToLock: ApiTestExecutionCreateLock[]): Promise<void> {
        let url_ = this.baseUrl + "/api/TestExecution/Lock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(itemsToLock);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateLocks(_response);
        });
    }

    protected processCreateLocks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create execution log entry
     * @param testJobExecutionId The id of the test execution
     * @param testStepExecutionId The id of the test step execution
     * @param newLogEntry The log entry to create
     */
    createExecutionLog(testJobExecutionId: number, testStepExecutionId: number, newLogEntry: ApiTestExecutionLogUserEntryNew): Promise<void> {
        let url_ = this.baseUrl + "/api/TestExecution/Log/{testJobExecutionId}/{testStepExecutionId}";
        if (testJobExecutionId === undefined || testJobExecutionId === null)
            throw new Error("The parameter 'testJobExecutionId' must be defined.");
        url_ = url_.replace("{testJobExecutionId}", encodeURIComponent("" + testJobExecutionId));
        if (testStepExecutionId === undefined || testStepExecutionId === null)
            throw new Error("The parameter 'testStepExecutionId' must be defined.");
        url_ = url_.replace("{testStepExecutionId}", encodeURIComponent("" + testStepExecutionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newLogEntry);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateExecutionLog(_response);
        });
    }

    protected processCreateExecutionLog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete locks
     * @param ids The ids of the test execution for which the lock should be released.
     */
    deleteLocks(ids: number[]): Promise<void> {
        let url_ = this.baseUrl + "/api/TestExecution/Unlock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteLocks(_response);
        });
    }

    protected processDeleteLocks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TestScenarioClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Create test scenario
     * @param newItem The data for the new test scenario which should be created.
     * @param applyDefaultValues (optional) Indicates whether default values should be applied for fields which are not included in the request.
     * @return Basic information on the new test scenario.
     */
    create(newItem: ApiItemNewWithTestJobs, applyDefaultValues?: boolean | undefined): Promise<ApiItemInfo> {
        let url_ = this.baseUrl + "/api/TestScenario?";
        if (applyDefaultValues === null)
            throw new Error("The parameter 'applyDefaultValues' cannot be null.");
        else if (applyDefaultValues !== undefined)
            url_ += "applyDefaultValues=" + encodeURIComponent("" + applyDefaultValues) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newItem);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ApiItemInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemInfo>(null as any);
    }

    /**
     * Modify test scenario collection
     * @param patchRequest Operation details.
     * @return Guid of the batch operation. 
    Status of the the operation can be retrieved using GET api/System/LongOperation/{guid}/Status or GET api/System/LongOperation/{guid}.
    In case of this batch operation the data retrieved from 'GET api/System/LongOperation/{guid}' contains additional information 
    as defined in ApiItemLongOperationInfo (FailedItems).
    Additionally, you SignalR (group "LongOperation_{customerId}_{guid}") can be used to receive information when operation finishes.
     */
    modifyItems(patchRequest: ApiItemsPatchRequest): Promise<ApiLongOperationOfBoolean> {
        let url_ = this.baseUrl + "/api/TestScenario";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patchRequest);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processModifyItems(_response);
        });
    }

    protected processModifyItems(response: Response): Promise<ApiLongOperationOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiLongOperationOfBoolean;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiLongOperationOfBoolean>(null as any);
    }

    /**
     * Get test scenario
     * @param id The id of the test scenario as integer (without TS).
     * @param withEditableInfo (optional) Indicates whether information about the
                edit lock should be included.
     * @param withEditLayout (optional) Indicates whether information about the edit layout should be included.
                Edit layout is a superset of view layout (you don't have to specify withViewLayout) and contains all information 
                required to display and edit the item.
     * @param withViewLayout (optional) Indicates whether information about the
                view layout should be included. The view layout is a subset of edit layout and 
                contains all information required to display the item.
     * @return The requested test scenario.
     */
    get(id: number, withEditableInfo?: boolean | undefined, withEditLayout?: boolean | undefined, withViewLayout?: boolean | undefined): Promise<ApiTestScenario> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (withEditableInfo === null)
            throw new Error("The parameter 'withEditableInfo' cannot be null.");
        else if (withEditableInfo !== undefined)
            url_ += "withEditableInfo=" + encodeURIComponent("" + withEditableInfo) + "&";
        if (withEditLayout === null)
            throw new Error("The parameter 'withEditLayout' cannot be null.");
        else if (withEditLayout !== undefined)
            url_ += "withEditLayout=" + encodeURIComponent("" + withEditLayout) + "&";
        if (withViewLayout === null)
            throw new Error("The parameter 'withViewLayout' cannot be null.");
        else if (withViewLayout !== undefined)
            url_ += "withViewLayout=" + encodeURIComponent("" + withViewLayout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ApiTestScenario> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestScenario;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestScenario>(null as any);
    }

    /**
     * Update test scenario
     * @param id The id of the test scenario to modify.
     * @param update This object contains the changes which should be performed.
     * @param explicitLock (optional) Indicates that the test scenario has been explicitly locked before this request.
     * @param applyDefaultValues (optional) Indicates whether default values should be applied for fields which are not included in the request.
     */
    update(id: number, update: ApiItemUpdateWithTestJobs, explicitLock?: boolean | undefined, applyDefaultValues?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (explicitLock === null)
            throw new Error("The parameter 'explicitLock' cannot be null.");
        else if (explicitLock !== undefined)
            url_ += "explicitLock=" + encodeURIComponent("" + explicitLock) + "&";
        if (applyDefaultValues === null)
            throw new Error("The parameter 'applyDefaultValues' cannot be null.");
        else if (applyDefaultValues !== undefined)
            url_ += "applyDefaultValues=" + encodeURIComponent("" + applyDefaultValues) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete test scenario
     * @param id The id of the test scenario.
     */
    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get attachments metadata as list
     * @param id The id of the test scenario.
     * @return A list with meta information on all the attachments of this test scenario.
     */
    getAttachments(id: number): Promise<ApiAttachmentInfo[]> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Attachment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachments(_response);
        });
    }

    protected processGetAttachments(response: Response): Promise<ApiAttachmentInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo[]>(null as any);
    }

    /**
     * Create attachment
     * @param id The id of the test scenario.
     * @param filename (optional) The filename of the attachment. This parameter is optional. If it
                is not specified, the file name from the multi part form data will be used.
     * @param file (optional) 
     * @return The metadata of the created attachment.
     */
    addAttachment(id: number, filename?: string | null | undefined, file?: FileParameter[] | undefined): Promise<ApiAttachmentInfo> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Attachment?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (filename !== undefined && filename !== null)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddAttachment(_response);
        });
    }

    protected processAddAttachment(response: Response): Promise<ApiAttachmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo>(null as any);
    }

    /**
     * Get attachment metadata
     * @param id The id of the test scenario.
     * @param attachmentId The id of the attachment.
     * @return The meta information for the specified attachment.
     */
    getAttachment(id: number, attachmentId: number): Promise<ApiAttachmentInfo> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Attachment/{attachmentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachment(_response);
        });
    }

    protected processGetAttachment(response: Response): Promise<ApiAttachmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAttachmentInfo;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAttachmentInfo>(null as any);
    }

    /**
     * Delete attachment
     * @param id The id of the test scenario.
     * @param attachmentId The id of the attachment.
     */
    deleteAttachment(id: number, attachmentId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Attachment/{attachmentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteAttachment(_response);
        });
    }

    protected processDeleteAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get attachment
     * @param id The id of the test scenario.
     * @param attachmentId The id of the attachment.
     * @param download (optional) When true, the response contains a content-disposition header to
                force the browser to download the attachment.
     * @param token (optional) Optional OAuth token.
     * @param tenantId (optional) The ID of the tenant. Only required in multi-tenant environments.
     * @return The file content of the attachment.
     */
    getAttachmentData(id: number, attachmentId: number, download?: boolean | undefined, token?: string | null | undefined, tenantId?: number | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Attachment/{attachmentId}/data?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        if (download === null)
            throw new Error("The parameter 'download' cannot be null.");
        else if (download !== undefined)
            url_ += "download=" + encodeURIComponent("" + download) + "&";
        if (token !== undefined && token !== null)
            url_ += "access_token=" + encodeURIComponent("" + token) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAttachmentData(_response);
        });
    }

    protected processGetAttachmentData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 307) {
            return response.text().then((_responseText) => {
            let result307: any = null;
            result307 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRedirectResult;
            return throwException("The request is redirected.", status, _responseText, _headers, result307);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Start automated test scenario execution
     * @param id The id of the test scenario.
     * @param executionInfo Contains the information necessary to start the test scenario execution.
     */
    executeAutomated(id: number, executionInfo: ApiAutomatedTestScenarioExecutionRequest): Promise<ApiAutomatedTestScenarioExecutionResponse> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/AutomatedExecution";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(executionInfo);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExecuteAutomated(_response);
        });
    }

    protected processExecuteAutomated(response: Response): Promise<ApiAutomatedTestScenarioExecutionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAutomatedTestScenarioExecutionResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAutomatedTestScenarioExecutionResponse>(null as any);
    }

    /**
     * Get fields edit meta
     * @param id The id of the test scenario for which the edit meta is requested.
     * @param statusTo The id of the status we are switching to.
     * @return Basic information on the fields of the test scenario.
     */
    editMeta(id: number, statusTo: number): Promise<ApiItemEditMeta> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/EditMeta?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (statusTo === undefined || statusTo === null)
            throw new Error("The parameter 'statusTo' must be defined and cannot be null.");
        else
            url_ += "statusTo=" + encodeURIComponent("" + statusTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEditMeta(_response);
        });
    }

    protected processEditMeta(response: Response): Promise<ApiItemEditMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemEditMeta;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemEditMeta>(null as any);
    }

    /**
     * Get edit status
     * @param id The id of the test scenario.
     */
    getEditStatus(id: number): Promise<ApiItemEditStatus> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/EditStatus";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEditStatus(_response);
        });
    }

    protected processGetEditStatus(response: Response): Promise<ApiItemEditStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemEditStatus;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemEditStatus>(null as any);
    }

    /**
     * Get test scenario executions as list
     * @param id The id of the test scenario.
     * @param filter (optional) The filter syntax is as follows:
                [ExecutionDate]=#2022-01-21# and [Version]!=12 and [TestedVersion]='v1'
     * @param startAt (optional) Number of results to skip when the results are fetched.
                Can be used for pagination.
     * @param maxResults (optional) Maximum number of results which are fetched.
                Can be used for pagination.
     * @param orderBy (optional) Comma-separated list of properties which should be used to order
                the result list. ASC or DESC can be appended to indicate the sort order. Ascending sort
                order is assumed by default.
     * @param includeStatistics (optional) Include test case execution status statistics in the test scenario execution.
     */
    getTestExecutions(id: number, filter?: string | null | undefined, startAt?: number | undefined, maxResults?: number | undefined, orderBy?: string | null | undefined, includeStatistics?: boolean | undefined): Promise<ApiPaginatedResultOfApiTestExecutionInfo> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Execution?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (includeStatistics === null)
            throw new Error("The parameter 'includeStatistics' cannot be null.");
        else if (includeStatistics !== undefined)
            url_ += "includeStatistics=" + encodeURIComponent("" + includeStatistics) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestExecutions(_response);
        });
    }

    protected processGetTestExecutions(response: Response): Promise<ApiPaginatedResultOfApiTestExecutionInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPaginatedResultOfApiTestExecutionInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPaginatedResultOfApiTestExecutionInfo>(null as any);
    }

    /**
     * Create test scenario execution preview
     * @param id The id of the test scenario.
     * @param tePreviewModel List of values which will be considered in the preview.
     * @param richTextFormatToInclude (optional) This enum determinates wich information should be included in the richtext.
     */
    previewTestExecution(id: number, tePreviewModel: ApiTestScenarioExecutionPreviewRequest, richTextFormatToInclude?: ApiRichTextIncludeType | undefined): Promise<ApiTestScenarioExecutionPreviewResponse> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Execution/Preview?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (richTextFormatToInclude === null)
            throw new Error("The parameter 'richTextFormatToInclude' cannot be null.");
        else if (richTextFormatToInclude !== undefined)
            url_ += "richTextFormatToInclude=" + encodeURIComponent("" + richTextFormatToInclude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tePreviewModel);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPreviewTestExecution(_response);
        });
    }

    protected processPreviewTestExecution(response: Response): Promise<ApiTestScenarioExecutionPreviewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestScenarioExecutionPreviewResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestScenarioExecutionPreviewResponse>(null as any);
    }

    /**
     * Get history
     * @param id The id of the test scenario.
     * @return A list with all changes in chronological order.
     */
    getHistory(id: number): Promise<ApiHistoryEntryTestScenario[]> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/History";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetHistory(_response);
        });
    }

    protected processGetHistory(response: Response): Promise<ApiHistoryEntryTestScenario[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiHistoryEntryTestScenario[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiHistoryEntryTestScenario[]>(null as any);
    }

    /**
     * Create lock
     * @param id The id of the test scenario to lock.
     * @param lockInfo Contains the information necessary to acquire a lock.
     */
    createLock(id: number, lockInfo: ApiLockNew): Promise<void> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lockInfo);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateLock(_response);
        });
    }

    protected processCreateLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete lock
     * @param id The id of the test scenario for which the lock should be released.
     */
    deleteLock(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteLock(_response);
        });
    }

    protected processDeleteLock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get posts
     * @param id The id of the testscenario.
     * @param firstResult (optional) The first result wich should be fetched. The default value is 0.
     * @param maxResults (optional) The maximal number of results wich should be fetched. The default value is 100.
     * @param ascending (optional) The sorting order of the result. If true sorted ascending otherwise descending. The default value is true.
     * @return A list of paginated posts associated with the given testscenario and the total count of all posts for this testscenario.
     */
    getPosts(id: number, firstResult?: number | undefined, maxResults?: number | undefined, ascending?: boolean | undefined): Promise<ApiPostPaginated> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Post?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (firstResult === null)
            throw new Error("The parameter 'firstResult' cannot be null.");
        else if (firstResult !== undefined)
            url_ += "firstResult=" + encodeURIComponent("" + firstResult) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (ascending === null)
            throw new Error("The parameter 'ascending' cannot be null.");
        else if (ascending !== undefined)
            url_ += "ascending=" + encodeURIComponent("" + ascending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPosts(_response);
        });
    }

    protected processGetPosts(response: Response): Promise<ApiPostPaginated> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostPaginated;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostPaginated>(null as any);
    }

    /**
     * Create post
     * @param id The id of the testscenario in which the new post should be created.
     * @param content The content of the new post. The content must be provided in exactly one format.
     * @return The meta information of the new post.
     */
    createPost(id: number, content: ApiRichText): Promise<ApiPostInfo> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Post";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreatePost(_response);
        });
    }

    protected processCreatePost(response: Response): Promise<ApiPostInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostInfo>(null as any);
    }

    /**
     * Get post
     * @param id The id of the testscenario.
     * @param postId The id of the post.
     * @return The requested post.
     */
    getPost(id: number, postId: number): Promise<ApiPost> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Post/{postId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPost(_response);
        });
    }

    protected processGetPost(response: Response): Promise<ApiPost> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPost;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPost>(null as any);
    }

    /**
     * Replace post
     * @param id The id of the testscenario.
     * @param postId The id of the post which should be replaced.
     * @param content The new content of the post. The content must be provided in exactly one format.
     * @return The meta information of the replaced post.
     */
    updatePost(id: number, postId: number, content: ApiRichText): Promise<ApiPostInfo> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Post/{postId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePost(_response);
        });
    }

    protected processUpdatePost(response: Response): Promise<ApiPostInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostInfo;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostInfo>(null as any);
    }

    /**
     * Delete post
     * @param id The id of the testscenario.
     * @param postId The id of the post which should be deleted.
     * @return The meta information of the deleted post.
     */
    deletePost(id: number, postId: number): Promise<ApiPostInfo> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Post/{postId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeletePost(_response);
        });
    }

    protected processDeletePost(response: Response): Promise<ApiPostInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiPostInfo;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiPostInfo>(null as any);
    }

    /**
     * Get relations
     * @param id The id of the test scenario.
     * @param depth (optional) The depth to which the relations are loaded. Depth 2 means that
                that the relations of relations are also loaded and so on. The default is 1.
     * @param maxItemsPerType (optional) The next level of relations is only loaded if at most
                this number of items of a certain type is present. Otherwise, the tree is cutoff.
                When this limit is not specified, this call might take a long time if the depth is
                greater than 1.
     * @param include (optional) Comma separated list of the data to include in the response.
                Supported includes: Relations.OtherItem.*Info to load basic info on the relation target,
                Relations.OtherItem.*Details to load the details of the relation target,
                Item.*Info to load basic info on the item for which the relations were requested,
                Item.*Details to load the details of the item for which the relations were requested.
     * @param fields (optional) The ids of the fields which should be included when details are included.
                When left empty, all fields will be included.
     * @return A list with all the relations together with some additional information.
     */
    getRelations(id: number, depth?: number | undefined, maxItemsPerType?: number | null | undefined, include?: string | null | undefined, fields?: string | null | undefined): Promise<ApiRelations> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Relation?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (depth === null)
            throw new Error("The parameter 'depth' cannot be null.");
        else if (depth !== undefined)
            url_ += "depth=" + encodeURIComponent("" + depth) + "&";
        if (maxItemsPerType !== undefined && maxItemsPerType !== null)
            url_ += "maxItemsPerType=" + encodeURIComponent("" + maxItemsPerType) + "&";
        if (include !== undefined && include !== null)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        if (fields !== undefined && fields !== null)
            url_ += "fields=" + encodeURIComponent("" + fields) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRelations(_response);
        });
    }

    protected processGetRelations(response: Response): Promise<ApiRelations> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelations;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelations>(null as any);
    }

    /**
     * Create relation
     * @param id The id of the test scenario.
     * @param relation The other information necessary to create the relation.
     * @return The created relation.
     */
    createRelation(id: number, relation: ApiRelationNew): Promise<ApiRelation> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Relation";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(relation);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateRelation(_response);
        });
    }

    protected processCreateRelation(response: Response): Promise<ApiRelation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelation;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelation>(null as any);
    }

    /**
     * Delete relation
     * @param id The id of the test scenario.
     * @param relationId The id of the relation.
     */
    deleteRelations(id: number, relationId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Relation/{relationId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (relationId === undefined || relationId === null)
            throw new Error("The parameter 'relationId' must be defined.");
        url_ = url_.replace("{relationId}", encodeURIComponent("" + relationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteRelations(_response);
        });
    }

    protected processDeleteRelations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get relation metadata
     * @param id The id of the test scenario.
     * @return The metadata required to create new relations.
     */
    getRelationCreateMeta(id: number): Promise<ApiRelationCreateMeta> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Relation/CreateMeta";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRelationCreateMeta(_response);
        });
    }

    protected processGetRelationCreateMeta(response: Response): Promise<ApiRelationCreateMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiRelationCreateMeta;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiRelationCreateMeta>(null as any);
    }

    /**
     * Add test job
     * @param id The id of the test scenario.
     * @param testJob Test job data to be added.
     */
    addTestJob(id: number, testJob: ApiTestJobNew): Promise<ApiAddSingleTestJobResponse> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/TestJob";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(testJob);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddTestJob(_response);
        });
    }

    protected processAddTestJob(response: Response): Promise<ApiAddSingleTestJobResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiAddSingleTestJobResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiAddSingleTestJobResponse>(null as any);
    }

    /**
     * Get test jobs as list
     * @param id The id of the test scenario.
     */
    getTestJobs(id: number): Promise<ApiTestJob[]> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/TestJob";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestJobs(_response);
        });
    }

    protected processGetTestJobs(response: Response): Promise<ApiTestJob[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestJob[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestJob[]>(null as any);
    }

    /**
     * Update test job
     * @param id The id of the test scenario.
     * @param testJobId The id of the test job.
     * @param testJob Test job data to be updated.
     */
    updateTestJob(id: number, testJobId: number, testJob: ApiTestJobUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/TestJob/{testJobId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (testJobId === undefined || testJobId === null)
            throw new Error("The parameter 'testJobId' must be defined.");
        url_ = url_.replace("{testJobId}", encodeURIComponent("" + testJobId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(testJob);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateTestJob(_response);
        });
    }

    protected processUpdateTestJob(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete test job
     * @param id The id of the test scenario.
     * @param testJobId The id of the test job.
     */
    deleteTestJob(id: number, testJobId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/TestJob/{testJobId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (testJobId === undefined || testJobId === null)
            throw new Error("The parameter 'testJobId' must be defined.");
        url_ = url_.replace("{testJobId}", encodeURIComponent("" + testJobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteTestJob(_response);
        });
    }

    protected processDeleteTestJob(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get test job
     * @param id The id of the test scenario.
     * @param testJobId The id of the test job.
     */
    getTestJob(id: number, testJobId: number): Promise<ApiTestJob> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/TestJob/{testJobId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (testJobId === undefined || testJobId === null)
            throw new Error("The parameter 'testJobId' must be defined.");
        url_ = url_.replace("{testJobId}", encodeURIComponent("" + testJobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestJob(_response);
        });
    }

    protected processGetTestJob(response: Response): Promise<ApiTestJob> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestJob;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestJob>(null as any);
    }

    /**
     * Get watching users as list
     * @param id The id of the test scenario.
     * @return List of users watching this test scenario.
     */
    getWatchers(id: number): Promise<ApiUserInfo[]> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetWatchers(_response);
        });
    }

    protected processGetWatchers(response: Response): Promise<ApiUserInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUserInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiUserInfo[]>(null as any);
    }

    /**
     * Add to watch list
     * @param id The id of the test scenario.
     * @param newWatcher Contains id of the user to be subscribed.
     */
    addWatcher(id: number, newWatcher: ApiWatcherNew): Promise<void> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newWatcher);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddWatcher(_response);
        });
    }

    protected processAddWatcher(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Updates the watch list
     * @param id The id of the test scenario.
     * @param watchersUpdate Contains the id of the user to be (un-)subscribed.
     */
    updateWatchers(id: number, watchersUpdate: ApiWatchersUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Watchers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(watchersUpdate);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateWatchers(_response);
        });
    }

    protected processUpdateWatchers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove from watch list
     * @param id The id of the test scenario.
     * @param userId The id of the user to be unsubscribed.
     */
    removeWatcher(id: number, userId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TestScenario/{id}/Watchers/{userId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveWatcher(_response);
        });
    }

    protected processRemoveWatcher(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return or
     */
    connectByExternalId(testScenarioId: number, data: any): Promise<void> {
        let url_ = this.baseUrl + "/api/TestScenario/{testScenarioId}/ExternalRef";
        if (testScenarioId === undefined || testScenarioId === null)
            throw new Error("The parameter 'testScenarioId' must be defined.");
        url_ = url_.replace("{testScenarioId}", encodeURIComponent("" + testScenarioId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConnectByExternalId(_response);
        });
    }

    protected processConnectByExternalId(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get fields metadata
     * @param projectId The id of the project.
     * @param folderId The id of the folder where the item is to be created (0 means root level).
     * @param statusTo (optional) The id of status with which the new item will be saved. Workflow
                restrictions might depend on this status and hence the meta data might change depending
                on the selected status. If no status id is provided, the default value for the status
                is assumed.
     * @return Basic information on the fields of a new test scenario created in given project and folder.
     */
    createMeta(projectId: number, folderId: number, statusTo?: number | null | undefined): Promise<ApiItemCreateMeta> {
        let url_ = this.baseUrl + "/api/TestScenario/CreateMeta?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined and cannot be null.");
        else
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (statusTo !== undefined && statusTo !== null)
            url_ += "statusTo=" + encodeURIComponent("" + statusTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateMeta(_response);
        });
    }

    protected processCreateMeta(response: Response): Promise<ApiItemCreateMeta> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemCreateMeta;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemCreateMeta>(null as any);
    }

    fetchByExternalId(integrationTypeStr: string | null, externalId: string | null): Promise<ApiExternalInfo[]> {
        let url_ = this.baseUrl + "/api/TestScenario/ExternalRef/{integrationTypeStr}/{externalId}";
        if (integrationTypeStr === undefined || integrationTypeStr === null)
            throw new Error("The parameter 'integrationTypeStr' must be defined.");
        url_ = url_.replace("{integrationTypeStr}", encodeURIComponent("" + integrationTypeStr));
        if (externalId === undefined || externalId === null)
            throw new Error("The parameter 'externalId' must be defined.");
        url_ = url_.replace("{externalId}", encodeURIComponent("" + externalId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processFetchByExternalId(_response);
        });
    }

    protected processFetchByExternalId(response: Response): Promise<ApiExternalInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiExternalInfo[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiExternalInfo[]>(null as any);
    }

    /**
     * Get test scenarios
     * @param projectId The id of the project of which the items are loaded.
     * @param folderId (optional) The id of the folder of which the items are loaded.
     * @param includeSubfolders (optional) Indicates whether items from sub folders should be included.
     * @param includeArchived (optional) Indicates whether archieved items should be included.
     * @param filter (optional) The filter syntax is as follows:
                [["Priority", "=", "High"], "and", ["DateCreatedDateTime", ">=", "2018-01-01"]]
                The field meta data can be used to check which filter operators are supported for which fields.
     * @param sorting (optional) The sorting syntax is as follows:
                [["Significane", "desc"], ["Status", "asc]]
                The field meta data can be used to check which fields support sorting.
     * @param search (optional) A fulltext search will be performed with this term and only matching
                items will be included in the result
     * @param startAt (optional) The index of the first item which should be included. Allows pagination
                of the results.
     * @param maxResults (optional) The maximum number of items to return. Allows pagination of the results.
     * @return A list of items matching the given criteria.
     */
    getItemList(projectId: number, folderId?: number | undefined, includeSubfolders?: boolean | undefined, includeArchived?: boolean | undefined, filter?: string | null | undefined, sorting?: string | null | undefined, search?: string | null | undefined, startAt?: number | undefined, maxResults?: number | undefined): Promise<ApiItemListResult> {
        let url_ = this.baseUrl + "/api/TestScenario/ItemList?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (folderId === null)
            throw new Error("The parameter 'folderId' cannot be null.");
        else if (folderId !== undefined)
            url_ += "folderId=" + encodeURIComponent("" + folderId) + "&";
        if (includeSubfolders === null)
            throw new Error("The parameter 'includeSubfolders' cannot be null.");
        else if (includeSubfolders !== undefined)
            url_ += "includeSubfolders=" + encodeURIComponent("" + includeSubfolders) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetItemList(_response);
        });
    }

    protected processGetItemList(response: Response): Promise<ApiItemListResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiItemListResult;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiItemListResult>(null as any);
    }

    /**
     * Get preview of test jobs
     * @param testCaseIds Ids of the test cases for which the preview should be generated.
     * @return The preview of the test jobs.
     */
    getTestJobPreview(testCaseIds: number[]): Promise<ApiTestJobPreviewResponse> {
        let url_ = this.baseUrl + "/api/TestScenario/TestJobPreview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(testCaseIds);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTestJobPreview(_response);
        });
    }

    protected processGetTestJobPreview(response: Response): Promise<ApiTestJobPreviewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiTestJobPreviewResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiTestJobPreviewResponse>(null as any);
    }
}

export class UserClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get folder favourites
     */
    getProjectFolderFavourites(): Promise<ApiProjectFolderFavourite[]> {
        let url_ = this.baseUrl + "/api/User/FolderFavourite";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProjectFolderFavourites(_response);
        });
    }

    protected processGetProjectFolderFavourites(response: Response): Promise<ApiProjectFolderFavourite[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectFolderFavourite[];
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectFolderFavourite[]>(null as any);
    }

    /**
     * Create folder favourite
     */
    createProjectFolderFavourite(newFavourite: ApiProjectFolderFavouriteNew): Promise<ApiProjectFolderFavourite> {
        let url_ = this.baseUrl + "/api/User/FolderFavourite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newFavourite);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateProjectFolderFavourite(_response);
        });
    }

    protected processCreateProjectFolderFavourite(response: Response): Promise<ApiProjectFolderFavourite> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiProjectFolderFavourite;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiProjectFolderFavourite>(null as any);
    }

    /**
     * Delete folder favourite
     * @param id The id of the folder favourite
     */
    deleteProjectFolderFavourite(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/User/FolderFavourite/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProjectFolderFavourite(_response);
        });
    }

    protected processDeleteProjectFolderFavourite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update folder favourite
     * @param id The if of the Folder.
     * @param patch Update details.
     */
    patchProjectFolderFavourite(id: number, patch: ApiProjectFolderFavouritePatch): Promise<void> {
        let url_ = this.baseUrl + "/api/User/FolderFavourite/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patch);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPatchProjectFolderFavourite(_response);
        });
    }

    protected processPatchProjectFolderFavourite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update folder notification rules
     * @param projectId The id of the project.
     * @param patchRequests Contains information about the patch request (many rules can be modified at once).
     */
    updateFolderNotificationRule(projectId: number, patchRequests: ApiFolderNotificationRulePatchRequest[]): Promise<void> {
        let url_ = this.baseUrl + "/api/User/FolderNotificationRule/Project/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patchRequests);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateFolderNotificationRule(_response);
        });
    }

    protected processUpdateFolderNotificationRule(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get folder notification rules
     * @param projectId The id of the project.
     * @param folderId The id of the folder.
     */
    getFolderNotificationRule(projectId: number, folderId: number): Promise<ApiFolderNotificationRuleResponse[]> {
        let url_ = this.baseUrl + "/api/User/FolderNotificationRule/Project/{projectId}/Folder/{folderId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (folderId === undefined || folderId === null)
            throw new Error("The parameter 'folderId' must be defined.");
        url_ = url_.replace("{folderId}", encodeURIComponent("" + folderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFolderNotificationRule(_response);
        });
    }

    protected processGetFolderNotificationRule(response: Response): Promise<ApiFolderNotificationRuleResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiFolderNotificationRuleResponse[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiFolderNotificationRuleResponse[]>(null as any);
    }

    /**
     * Get grid config
     * @param projectId The id of the project for which the grid
                config should be loaded
     * @param itemType The item type for which the grid config
                should be loaded.
     * @return The grid config
     */
    getGridConfig(projectId: number, itemType: ApiItemType): Promise<ApiGridConfig> {
        let url_ = this.baseUrl + "/api/User/GridConfig/Project/{projectId}/{itemType}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined.");
        url_ = url_.replace("{itemType}", encodeURIComponent("" + itemType));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGridConfig(_response);
        });
    }

    protected processGetGridConfig(response: Response): Promise<ApiGridConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiGridConfig;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiGridConfig>(null as any);
    }

    /**
     * Replace grid config
     * @param projectId The id of the project for which the grid config is
                saved.
     * @param itemType The item type for which the grid config is saved
     * @param gridConfig The grid config to save
     */
    updateGridConfig(projectId: number, itemType: ApiItemType, gridConfig: ApiGridConfig): Promise<void> {
        let url_ = this.baseUrl + "/api/User/GridConfig/Project/{projectId}/{itemType}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined.");
        url_ = url_.replace("{itemType}", encodeURIComponent("" + itemType));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(gridConfig);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateGridConfig(_response);
        });
    }

    protected processUpdateGridConfig(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete grid config
     * @param projectId The id of the project for which the grid config is
                saved.
     * @param itemType The item type for which the grid config is saved
     */
    deleteGridConfig(projectId: number, itemType: ApiItemType): Promise<void> {
        let url_ = this.baseUrl + "/api/User/GridConfig/Project/{projectId}/{itemType}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined.");
        url_ = url_.replace("{itemType}", encodeURIComponent("" + itemType));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteGridConfig(_response);
        });
    }

    protected processDeleteGridConfig(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Upload picture
     * @param file (optional) 
     */
    changeUserPhoto(file?: FileParameter[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/Photo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processChangeUserPhoto(_response);
        });
    }

    protected processChangeUserPhoto(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Add favourite
     * @param projectId The id of the project to add to favourite
     */
    addProjectFavourite(projectId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/User/ProjectFavourite/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddProjectFavourite(_response);
        });
    }

    protected processAddProjectFavourite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove favourite
     * @param projectId The id of the project to remove from favourites
     */
    removeProjectFavourite(projectId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/User/ProjectFavourite/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveProjectFavourite(_response);
        });
    }

    protected processRemoveProjectFavourite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UserImageClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get a user's profile pricture
     * @param userId The ID of the user who's profile picture should be returned
     * @param initials (optional) Defines if the complete intials or only one letter will be returned.
                If there is no picture for the user available.
     * @return The image data
     */
    getProfilPicture(userId: number, initials?: ApiIntialType | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/UserImage/{userId}/picture?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (initials === null)
            throw new Error("The parameter 'initials' cannot be null.");
        else if (initials !== undefined)
            url_ += "initials=" + encodeURIComponent("" + initials) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProfilPicture(_response);
        });
    }

    protected processGetProfilPicture(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get user image
     * @param initialLetters The intial letters of the user if available, if not 2 letters from firstname or surname if not available 2 letters from username.
     * @return The metadata of the image
     */
    getImageData(initialLetters: string | null): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/UserImage/Data?";
        if (initialLetters === undefined)
            throw new Error("The parameter 'initialLetters' must be defined.");
        else if(initialLetters !== null)
            url_ += "initialLetters=" + encodeURIComponent("" + initialLetters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetImageData(_response);
        });
    }

    protected processGetImageData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class UserViewClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Create user view
     * @param newUserView The data for the new user view which should be created.
     * @return Id of the view
     */
    create(newUserView: ApiUserViewNew): Promise<ApiUserViewNewResponse> {
        let url_ = this.baseUrl + "/api/UserView";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newUserView);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ApiUserViewNewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUserViewNewResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiUserViewNewResponse>(null as any);
    }

    /**
     * Modify the collection of user views
     * @param update The necessary information to modify the user view collection.
     */
    updateCollection(update: ApiUserViewPatchCollectionOperation): Promise<ApiUserViewPatchCollectionResponse> {
        let url_ = this.baseUrl + "/api/UserView";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateCollection(_response);
        });
    }

    protected processUpdateCollection(response: Response): Promise<ApiUserViewPatchCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUserViewPatchCollectionResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiUserViewPatchCollectionResponse>(null as any);
    }

    /**
     * Update user view
     * @param userViewId The id of the view
     * @param update The data for the user view which should be updated.
     */
    update(userViewId: number, update: ApiUserViewUpdate): Promise<void> {
        let url_ = this.baseUrl + "/api/UserView/{userViewId}";
        if (userViewId === undefined || userViewId === null)
            throw new Error("The parameter 'userViewId' must be defined.");
        url_ = url_.replace("{userViewId}", encodeURIComponent("" + userViewId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete user view
     * @param userViewId The id of the view
     */
    deleteView(userViewId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/UserView/{userViewId}";
        if (userViewId === undefined || userViewId === null)
            throw new Error("The parameter 'userViewId' must be defined.");
        url_ = url_.replace("{userViewId}", encodeURIComponent("" + userViewId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteView(_response);
        });
    }

    protected processDeleteView(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get user view
     * @param userViewId The id of the view
     * @param itemType (optional) The item type for which the field-specific information
                of the user view should be included. When not specified, the user view will not
                contains any field-specific information.
                If true, then permissions are included as well (default: true)
     * @param includePermissions (optional) 
     */
    getView(userViewId: number, itemType?: ApiItemType | null | undefined, includePermissions?: boolean | undefined): Promise<ApiUserView> {
        let url_ = this.baseUrl + "/api/UserView/{userViewId}?";
        if (userViewId === undefined || userViewId === null)
            throw new Error("The parameter 'userViewId' must be defined.");
        url_ = url_.replace("{userViewId}", encodeURIComponent("" + userViewId));
        if (itemType !== undefined && itemType !== null)
            url_ += "itemType=" + encodeURIComponent("" + itemType) + "&";
        if (includePermissions === null)
            throw new Error("The parameter 'includePermissions' cannot be null.");
        else if (includePermissions !== undefined)
            url_ += "includePermissions=" + encodeURIComponent("" + includePermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetView(_response);
        });
    }

    protected processGetView(response: Response): Promise<ApiUserView> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUserView;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiUserView>(null as any);
    }

    /**
     * Mark user view as favourite
     * @param userViewId The id of the user view to mark as favourite.
     */
    markUserViewAsFavourite(userViewId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/UserView/{userViewId}/Favourite";
        if (userViewId === undefined || userViewId === null)
            throw new Error("The parameter 'userViewId' must be defined.");
        url_ = url_.replace("{userViewId}", encodeURIComponent("" + userViewId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMarkUserViewAsFavourite(_response);
        });
    }

    protected processMarkUserViewAsFavourite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Un-mark user view as favourite
     * @param userViewId The id of the user view to un-mark as favourite.
     */
    unMarkUserViewFavourite(userViewId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/UserView/{userViewId}/Favourite";
        if (userViewId === undefined || userViewId === null)
            throw new Error("The parameter 'userViewId' must be defined.");
        url_ = url_.replace("{userViewId}", encodeURIComponent("" + userViewId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUnMarkUserViewFavourite(_response);
        });
    }

    protected processUnMarkUserViewFavourite(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class WorkflowClient extends AquaRestBaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://app.aqua-cloud.io/aquaWebNG";
    }

    /**
     * Get workflow
     * @param projectId Id of project
     * @param itemType Type of the item
     * @return The requested workflow
     */
    getWorkflow(projectId: number, itemType: ApiItemType): Promise<ApiWorkflow> {
        let url_ = this.baseUrl + "/api/Workflow/{itemType}/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (itemType === undefined || itemType === null)
            throw new Error("The parameter 'itemType' must be defined.");
        url_ = url_.replace("{itemType}", encodeURIComponent("" + itemType));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetWorkflow(_response);
        });
    }

    protected processGetWorkflow(response: Response): Promise<ApiWorkflow> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiWorkflow;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiArgumentError;
            return throwException("Invalid request. Check the error for additional information", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiForbiddenError;
            return throwException("Not allowed to perform the requested operation. Check the error for more information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiNotFoundError;
            return throwException("The entity was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiUnauthorizedError;
            return throwException("No valid authentication.", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiInternalError;
            return throwException("Something went wrong in the REST API. Ask your administrator to check the logs.", status, _responseText, _headers, result500);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            let result503: any = null;
            result503 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiBackendNotAvailableError;
            return throwException("aqua backend is not available. Please try again later or contact your administrator", status, _responseText, _headers, result503);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiWorkflow>(null as any);
    }
}

/** Encapsulates basic information about currently executing task on an agent. */
export interface ApiCurrentlyExecutedStepInfo {
    /** The id of the project where the execution is performed */
    ProjectId: number;
    /** The id of the step execution */
    TestStepExecutionId: number;
    /** The id of the execution */
    TestJobExecutionId: number;
    /** The id of related test case. */
    TestCaseId: number;
    /** The id of related test scenario (or 0 if none). */
    TestScenarioId: number;
    /** If the user can view the testscenario for the testjobexecution */
    CanViewTestScenario: ApiPermissionResult | undefined;
    /** If the user can view the testscenario for the testjobexecution */
    CanViewTestCase: ApiPermissionResult;
    /** If the user can view the testjobexecution itself */
    CanViewTestJobExecution: ApiPermissionResult;
}

/** Defined possible results of a permission check. This enum has the following values:  - `Denied` The given permission is deined, although is included in the license.  - `Granted` The given permission is granted.  - `NotLicensed` The given permission is not even licensed (so denied). */
export enum ApiPermissionResult {
    Denied = "Denied",
    NotLicensed = "NotLicensed",
    Granted = "Granted",
}

/** Contains information about an error which occurred during an API call. */
export interface ApiError {
    /** A human-readable description of the error. */
    Message: string;
    /** The error code to be used for tracking the error a the server side. */
    Code: string;
    /** Further information about the error as unstructured text. This text is
not localized. */
    FurtherInfo: string | undefined;
    /** Additional data about the error (if any). Depends on actual error type. */
    ErrorData: any | undefined;
    Type: string;
}

/** The request requires a valid authentication. Please authenticate first and make sure to include the Authorization header in your request. */
export interface ApiUnauthorizedError extends ApiError {
}

/** The request data is invalid. */
export interface ApiArgumentError extends ApiError {
    /** The reason why the request data is invalid. */
    ArgumentErrorType: ApiArgumentErrorType;
}

/** Identifies the type of "argument error" which occurred. Arument error is a situation when information received from the caller is invalid (e.g. does not fit into expected limits, is of invalid type etc.) or does not correspond to system state (e.g. trying to update a locked item). Argument errors are not system errors, but rather client errors. This enum has the following values:  - `ActualResultsMissing` The actual results are not specified but are required.  - `AgentNotFound` The agent does not exist.  - `ArchiveJobAlreadyStarted` Archive job is already running, cannot start new one.  - `AssignmentDeleteFailed` Delete the user assignment failed.  - `AttachmentMaxSizeExceeded` Attachment size exceeds maximum size.  - `AttachmentMaxTransferSizeExceeded` Attachments size exceeds maximum transfer size for one upload.  - `AttachmentNotFound` Attachment does not exist.  - `AutomationInTestStepNotPresentOrInvalid` Automation in given step was not present or was invalid (not as expected).  - `AutomationScriptUnsupportedTechnologySave` The save for automation script technology is not supported.  - `CalculatedFieldModified` The request tries to set the value of a field which is set to a calculated value by the workflow. Such a field cannot be modified by the end user.  - `CannotModifyAutomaticDependencies` Automatic dependencies cannot be deleted or modified  - `CannotUpdateReferencedTestData` It is not possible update test data which is referenced. Please update it in the other test case (owner of test data).  - `CustomFilterAcceptedStatusesNotRecognized` Custom filter accepted statuses contains unrecognized value.  - `CustomFilterOptionsNotEmpty` Custom filter options are not empty.  - `DefaultEntriesUserIdNotAllowed` Default configuration data (global or project) must not contain a user id.  - `DictionaryEntryNotFound` The dictionary entry with the given id was not found.  - `DuplicateAgentCode` The agent code must be unique in the project.  - `DuplicateAgentName` An agent name must be unique in the project.  - `DuplicateDictionary` The name or id of a dictionary is not unique.  - `DuplicateDictionaryEntry` The name or id of a dictionary entry is not unique.  - `DuplicateProjectFolderFavourite` There is already a project folder favourite for given project & folder  - `DuplicateProjectName` The name of the project is not unique.  - `DuplicateReportParameter` Duplicate report parameter.  - `DuplicateRoleName` The name of a role is not unique.  - `DuplicateSprintName` The name of a sprint entry is not unique.  - `DuplicateUserName` The name of a user entry is not unique.  - `EmptyAgentName` Agent name is empty.  - `EmptyDashboardTitle` The dashboard title must be set.  - `EmptyItemName` The name of the item in the request is empty.  - `EmptyListNotAllowed` The list of elements is expected to be non empty.  - `EmptySprintName` The sprint name is empty.  - `EnclosureNotFound` The enclosure with the given id does not exist.  - `ExecutableFilesUploadBlocked` The upload of executable files is blocked..  - `ExecuteAllWithTestJobIds` If a automated execution for all Testjobs in a Testscenario is to be started and also a List of Testjobids is provided. Only one of both can be used.  - `ExecutionDependencyViolation` The provided execution dependencies are violated.  - `ExecutionNotForSingleTestScenario` The test executions to save do not belong to a single test scenario.  - `ExpectedLockMissing` The specified item is expected to be locked for exclusive editing by the current user but the edit lock is missing.  - `ExpectedResultsMissing` The expected results are not specified but are required.  - `ExpectedResultsNotAllowedForCondition` A condition step must not have an expected result.  - `FieldIsNotCustomField` A field which is not a custom field is modified using the mechanism for custom fields.  - `FieldNotSupported` A field specified in the request is not supported for this request.  - `FieldRulesCycle` The requested would create a cyclic rule for the field rules.  - `FieldRuleValueChangedNotSupported` A field rule specifies a value change for field for which changing the value by a field rule is not supported.  - `FieldValueDuplicatedName` A field specified in the request has duplicated field value name.  - `FieldValueDuplicatedPosition` A field specified in the request has duplicated field value position.  - `FieldValueEmptyName` A field specified in the request has empty field value name.  - `FieldValueReservedName` A field specified in the request has reserved field value name.  - `FieldValueTooLongName` A field specified in the request has too long field value name.  - `FileExtensionInvalid` The provided file extension for the uploaded file is invalid. Please make sure that file extension is not null or empty.  - `FileInvalid` The uploaded file is invalid and cannot be processed. Either the request is not correctly constructed or the file content is incorrect.  - `FileNameInvalid` The provided file name for the uploaded file is invalid. Please make sure that file name is not null or empty.  - `FileNameUsedWithMultipart` The file name for the file is provided while multipart form data is used. Please make sure that file name is null or empty.  - `FileNotFound` File does not exist.  - `FileUploadAlreadyUploaded` The file was already uploaded. Each upload URL can only be used once.  - `FileUploadSizeMismatch` The size uploaded file content does not match the provided file size.  - `FileUploadWrongAzureBlobType` The blob type of the uploaded file is incorrect. Check the documentation regarding uploading to Azure Blob Storage  - `FilterClauseFieldInvalid` The field part of a filter clause is invalid.  - `FilterClauseFieldNotSupported` A field in the filter expression does not support filtering.  - `FilterClauseIncorrectNumberOfValues` A filter clause contains an incorrect number of values for the given operator.  - `FilterClauseInvalid` A clause in the filter expression is malformed.  - `FilterClauseOperatorInvalid` A filter operator in a filter clause is invalid.  - `FilterClauseOperatorNotSupported` A filter operator is not supported for field with which it is used.  - `FilterClauseUnknownField` A field in the filter expression does not exist.  - `FilterClauseValueInvalid` A value in a filter clause is invalid.  - `FilterGroupInvalid` A group in the filtere expression is malformed.  - `FilterGroupOperatorInvalid` A group in the filter expression contains an invalid group operator.  - `FilterGroupOperatorsMixed` A group in the filter expression contains several different group operators. Each group in a filter expression must contain only a single type of group operator.  - `FilterInvalid` The filter expression is malformed.  - `FolderCycle` Cycle detected in folder path.  - `FolderNameEmpty` Folder name is empty.  - `FolderNameNotUnique` Folder name is not unique (there already exists a folder with same name).  - `FolderNotEmpty` Folder is not empty.  - `FolderNotFound` The folder does not exist.  - `FolderNotificationRuleNotEmpty` Folder notification rule is not empty.  - `ImageFormatInvalid` Image file format is invalid.  - `ImageMaxSizeExceeded` Image size exceeds maximum size.  - `InvalidAgent` The provided agent is not set or cant execute the item.  - `InvalidAgentTypeForCopy` Only single agent supports copy operation.  - `InvalidApiImportErrorType` Import is reporting an import error with no equivalent in ApiImportErrorType  - `InvalidApiImportPhase` Import is reporting an import phase with no equivalent in ApiImportPhase  - `InvalidApiItemTypeToObjectTypeMask` The type of the item is not valid for this operation.  - `InvalidApiPermission` The permission is not valid.  - `InvalidApplicableItemTypes` The applicable item types are not suitable for the user view.  - `InvalidArgument` Represents generic "argument error" in situation when it is not possible to provide more detailed information about the problem.  - `InvalidBodyValue` The request contains a body value which is invalid. Most likely, there is a datatype mismatch or the value is empty.  - `InvalidColor` The color does not match any of the predefined colors.  - `InvalidDependencyDependentOnItSelf` The item cannot be dependent on itself.  - `InvalidEmail` The email is not valid.  - `InvalidFieldValue` The request contains a field value which is invalid. Most likely, there is a datatype mismatch or the value specified for a dictionary field does not exist at all.  - `InvalidFolderIdMultiProjectReport` Multi project report only possible on root folder.  - `InvalidIntialLetters` The intial letters are invalid.  - `InvalidItemPath` The item type does not match the path.  - `InvalidLicenseAssignmentAlreadyAssigned` The license is already assigned to the user.  - `InvalidLicenseAssignmentNotAssigned` The license is not assigned to the user.  - `InvalidLicenseCode` The license with the give code does not exist.  - `InvalidNestedTestCaseId` Invalid nested test case id.  - `InvalidParameterValue` The provided parameter value is invalid.  - `InvalidPatchType` The type of the patch request is not valid.  - `InvalidProjectAssignment` The permission elevation is not allowed.  - `InvalidProjectTreeParentFolder` The value for the parameter ParentFolder is invalid.  - `InvalidReorderWidgets` The reorder of widgets is invalid.  - `InvalidReportDefinitionFile` The file is not valid for report definitions.  - `InvalidReportParameterValue` The provided value for a report parameter is invalid. Please check that the provided value fits to the type of the parameter.  - `InvalidStepType` Invalid test step type.  - `InvalidTestData` Invalid test data e.g. syntax error in formula  - `InvalidTestDataLength` The requested test data has not equal length between values and valuesets or values and variables.  - `InvalidTestJobId` The provided test job id is invalid.  - `InvalidTestJobIndex` The provided test job index is not valid.  - `InvalidTestJobRunDependencyIndex` The provided test job run dependency index is not valid.  - `InvalidTestStepExecutionStatusType` Invalid test step execution status type.  - `InvalidTestStepId` Invalid test step id.  - `InvalidTestStepIndex` The provided test step index is not valid.  - `InvalidUsername` The user name is not valid.  - `InvalidValueSet` The provided value set is invalid.  - `InvalidVersionOfProjectConfigFile` Trying to import project config of incompatible version  - `ItemNotFound` The item does not exist.  - `ItemTypeNotSupported` Indicates that the given item type is not supported for the given request.  - `ItemTypeNotSupportedInDashboards` The ItemType is not supported in dashboards  - `LicenseTypeNotChanged` The license has already this type.  - `LockByAnotherUser` The item is currently locked for exclusive editing. The item is locked by another user.  - `Locked` The item is currently locked for exclusive editing. The item might be locked by another user or by the same user.  - `LowPasswordComplexity` The user password has low complexity.  - `ManualExecutionsWithStatusAndWithout` Mixed executions with and without arbitrary status.  - `ManualTestExecution` The manual test execution type is not supported.  - `MultiChoiceFieldValueExceededMaxLength` The value of the MultiChoiceField has exceeded the maximum length.  - `MultiPartNotOneFile` Your request body does not contain exactly one file in the multipart form data. Exactly one file must be provided in the multipart form data.  - `MultipleDefaultEntries` Multiple default entries have been defined. There must be only one default entry.  - `NestedTestCaseLoop` The nested test case creates an Infinite loop.  - `NoExecutions` The list of executions is empty.  - `NoFreeLicenses` There are no free licenses for the given type.  - `None` Represents void argument error.  - `NoTestData` No test data is defined.  - `NoTestSteps` Test steps must be defined to execute a test case.  - `NotificationTemplateInvalidLanguage` The language for the notification template is invalid.  - `NotificationTemplateMixedLanguage` The language for the item event templates in the notification template is not unique.  - `NotManualTestExecution` Test execution is not of the manual type (only manual test execution supported).  - `NotOwnerOfProjectTemplate` You are not allowed to perform the requested operation with the template of the specified project as the project template is shared and the current project is not the owner of the template.  - `NotSupported` Represents generic error type in situation when the feature is not supported.  - `NoValueSetSelected` The specified test case is parameterized but no value set has been selected.  - `OperationBlockedByOtherTask` The batch operation cannot be started because there is already running other task that prevents new one from starting (running on the same domain of items).  - `OutdatedVersion` Your request included an item version which is not identical to the version of the item currently stored in the database. Most likely, the item was modified in between.  - `ProjectConfigImportFailed` The import of the provided project configuration was not possible with the current import settings. Please check the provided list of errors.  - `ProjectFolderUserIsAlreadyAssigned` The project and/or folder has already an user assignment.  - `ProjectMaximumNumberReached` The maximum number of project is reached.  - `ProjectNotFound` The project does not exist.  - `ProjectRoleNotFound` The project role not found.  - `ProjectRoleUpdateDuplicateEntry` The project update contains duplicated entries.  - `ProjectRoleUpdateInvalidEntry` The project update contains invalid entries.  - `ProjectTemplateDuplicateFieldOperations` The request contains duplicate operations for one or more fields.  - `ProjectTemplateFieldIsActivated` The project template field is already activated. Hence the request operation is not possible.  - `ProjectTemplateFieldIsDeactivated` The project template field is already deactivated. Hence the request operation is not possible.  - `ProjectTemplateFieldOperationNotAllowed` The project template field does not allow the operation e.g. (FixedTitle can't be deactivated).  - `ProjectTemplateNotIntendedLayoutChange` The last configuration of this project has been saved in desktop client. Saving in web client will work but causes significant changes to layout in desktop client accordingly. If this is intended, please provide the necessary parameter otherwise please change your configuration in desktop client.  - `ProjectUserNotAssigned` The user is not assigned to the folder.  - `ReportDefinitionNotFound` Report definition does not exist.  - `ReportPluginNotRecognized` Report plugin has not been recognized. Is it deployed properly?  - `ReportScriptingNotAllowed` Scripting in reports is not allowed  - `RichtextInvalidImageUrl` The provided rich text contains invalid images. All images are expected to be uploaded to aqua before including them in the rich text. Please check the API documentation.  - `RichtextMultipleFormatsProvided` The current request contains rich text in multiple formats at the same time. When saving rich text, the request must contain the rich text only in one format.  - `RoleNotFound` The role with the given id does not exist.  - `RunDependenciesMissing` Run dependencies are missing. When executing a test scenario, all run dependencies must be included in the execution as well.  - `SharedDictionaryNotAllowed` The operation does not support shared dictionaries.  - `SharedFieldValueDuplicatedName` A shared field specified in the request has duplicated field value name.  - `SharedFieldValueDuplicatedPosition` A shared field specified in the request has duplicated field value position.  - `SharedFieldValueEmptyName` A shared field specified in the request has empty field value name.  - `SharedFieldValueSetDuplicatedName` A shared field specified in the request has duplicated field name.  - `SharedFieldValueSetEmptyName` A shared field specified in the request has empty field name.  - `SharedFieldValueSetTooLongName` A shared field specified in the request has too long field name.  - `SharedFieldValueTooLongName` A shared field specified in the request has too long field value name.  - `SortClauseDirectionInvalid` The direction specified in a sorting/grouping clause is invalid  - `SortClauseFieldInvalid` The field part in a sorting/grouping is invalid.  - `SortClauseFieldNotSupported` A field specified in a sorting/grouping clause does not support sorting or grouping.  - `SortClauseInvalid` A clause in the sorting or grouping expression is invalid.  - `SortClauseUnknownField` A field specified in a sorting/grouping clause does not exist.  - `SortInvalid` The sorting or grouping expression is invalid.  - `SprintStillContainsItems` There are still some items included in the sprint. Can not delete sprint.  - `SubrequirementsCircleFound` The requested operation would create a circle in the sub requirement tree structure.  - `SubrequirementsInconsistent` The sub requirement tree structure is inconsistent. Please make, sure that all child indexes are correct.  - `SubrequirementsOtherLocked` The requested operation must also update other sub requirements in the sub requirement tree structure but at least one of them is already locked for exclusive editing.  - `SubrequirementsOtherNotPermitted` The requested operation must also update other sub requirements in the sub requirement tree structure but the current user is not permitted to modify all of them.  - `SupportOnlyAutomatedItem` The provided item is not valid for automated run.  - `SystemFieldModified` The request tries to set the value of a field which is handled by the system and cannot be modified by the end user.  - `TestCaseNotFound` One or more executions do refer to invalid test cases. The test case might not exist or not be accessible.  - `TestDataExportTooManyVariablesForFileFormat` The requested file format does not support the number of variables contained in the test data.  - `TestDataFileFormatNotSupported` The requested file format is not supported for the export or import of test data.  - `TestDataImportFailed` The import of the test data failed.  - `TestDataImportInvalidFile` The file import format is not the same as in the filename.  - `TestDataImportInvalidXml` The XML to import is invalid.  - `TestDataImportNoSheet` The file to import does not contain any work sheets.  - `TestDataImportNoValueSets` The file to import does not contain any value sets.  - `TestDataImportNoVariables` The file to import does not contain any variables.  - `TestDataImportXmlMissingVariableName` A variable is missing in one of the value sets to import.  - `TestDataImportXmlValueSetNotFound` A value set was not found when importing from XML.  - `TestDataImportXmlVariableNotFound` A variable was not found when importing from XML.  - `TestDataMisMatchVariablesNamesOrLength` The variables names or the number of variables are not the same  - `TestDataNoValueSets` The test data does not contain any value sets.  - `TestDataNumberOfValuesMisMatchToValueSets` The number of values does not match the number of valuesets  - `TestDataNumberOfValuesMisMatchToVariables` The number of values does not match the number of variables  - `TestDataRemoteTCAlreadyReferences` The other test case already references another test case, so it is not possible to reference test data from that test case.  - `TestDataRemoteTCDeleted` The other test case is deleted so it is not possible to reference test data from that test case.  - `TestDataRemoteTCNotAccessible` The other test case is not accessible so it is not possible to reference test data from that test case.  - `TestDataRemoteTCNoTestData` The other test case has no test data so it is not possible to reference test data from that test case.  - `TestDataTooManyValues` The test data contains too many values. The number of variables and/or value sets needs to be reduced.  - `TestDataValueSetNameInvalid` The name of a value set is invalid.  - `TestDataValueSetNameNotUnique` A variable name is not unique.  - `TestDataValueSetNameTooLong` A value set name is too long.  - `TestDataValueSetNotFound` The test data value set for a specific guid not found.  - `TestDataValueTooLong` A value is too long.  - `TestDataVariableNameInvalid` A variable name is invalid.  - `TestDataVariableNameNotUnique` A variable name is not unique.  - `TestDataVariableNameTooLong` A variable name is too long.  - `TestExecutionFinalized` Cannot update finalized test execution.  - `TestExecutionNotFound` Test execution does not exist.  - `TestJobAgentNotFound` The agent specified in a test job cannot be found. Most likely the agent has been deleted.  - `TestJobAgentNotSelected` The Agent for the test job is not selected.  - `TestJobDisallowAgent` The non-automated test job forbids setting the agent.  - `TestJobNotFound` The Testjob with the given id does not exist.  - `TestScenarioNotFound` The test scenario with the given id does not exist.  - `TestStepEmptyNestedTestCase` The test step of type NestedTestCase contains empty NastedCase.  - `TestStepMandatoryExpectedResultIsEmpty` The test step contains empty mandatory expected result.  - `TestStepNotEmptyNestedTestCase` The test step of type Condition or Step contains NestedTestCase.  - `TestStepNotFound` The Teststep with the given id does not exist.  - `TestStepOfTypeConditionContainsExpectedResult` The test step of type condition contains expected result.  - `TestStepOfTypeNestedTestCaseNotEmptyValues` The test step of type NestedTestCase contains description and/or expected result.  - `TooManyTestJobs` The current test scenario or test scenario execution contains too many test jobs.  - `UnknownField` The request specifies a field or contains data for a field which does not exist.  - `UnknownReportParameter` No report parameter with the specified name was found.  - `UpdateOncePerTestExecution` Test execution already updated in this request.  - `UserEntriesCannotBeLocked` User-level configuration data cannot be marked as Locked.  - `UserEntriesMustHaveUserId` User-level configuration data must contain the id of the current user.  - `UserNotFound` User not found.  - `ValueTooBig` The provided value is too big for the argument.  - `ViolatedPermissionDependencies` The permission dependencies are violated.  - `WorkflowTransitionNotAllowed` The requested status transition is not allowed by the workflow.  - `WorkflowViolated` The given value for a field violates the workflow.  - `WrongDictionary` The dictionary in the request does not belong to the current field.  - `WrongFieldType` The field specified in the requested is of the wrong type. Most likely, the current endpoint is not meant to be used with fields of this type.  - `WrongPatchType` Wrong patch operation type is used. */
export enum ApiArgumentErrorType {
    None = "None",
    InvalidArgument = "InvalidArgument",
    NotSupported = "NotSupported",
    Locked = "Locked",
    LockByAnotherUser = "LockByAnotherUser",
    OutdatedVersion = "OutdatedVersion",
    ExpectedLockMissing = "ExpectedLockMissing",
    UnknownField = "UnknownField",
    InvalidFieldValue = "InvalidFieldValue",
    InvalidBodyValue = "InvalidBodyValue",
    SystemFieldModified = "SystemFieldModified",
    WorkflowViolated = "WorkflowViolated",
    FieldNotSupported = "FieldNotSupported",
    FieldIsNotCustomField = "FieldIsNotCustomField",
    FieldValueEmptyName = "FieldValueEmptyName",
    FieldValueDuplicatedName = "FieldValueDuplicatedName",
    FieldValueTooLongName = "FieldValueTooLongName",
    FieldValueDuplicatedPosition = "FieldValueDuplicatedPosition",
    FieldValueReservedName = "FieldValueReservedName",
    SharedFieldValueSetEmptyName = "SharedFieldValueSetEmptyName",
    SharedFieldValueSetDuplicatedName = "SharedFieldValueSetDuplicatedName",
    SharedFieldValueSetTooLongName = "SharedFieldValueSetTooLongName",
    SharedFieldValueEmptyName = "SharedFieldValueEmptyName",
    SharedFieldValueDuplicatedName = "SharedFieldValueDuplicatedName",
    SharedFieldValueTooLongName = "SharedFieldValueTooLongName",
    SharedFieldValueDuplicatedPosition = "SharedFieldValueDuplicatedPosition",
    WrongFieldType = "WrongFieldType",
    FileInvalid = "FileInvalid",
    FileNameInvalid = "FileNameInvalid",
    FileNameUsedWithMultipart = "FileNameUsedWithMultipart",
    FileExtensionInvalid = "FileExtensionInvalid",
    FileUploadAlreadyUploaded = "FileUploadAlreadyUploaded",
    FileUploadSizeMismatch = "FileUploadSizeMismatch",
    FileUploadWrongAzureBlobType = "FileUploadWrongAzureBlobType",
    MultiPartNotOneFile = "MultiPartNotOneFile",
    NotOwnerOfProjectTemplate = "NotOwnerOfProjectTemplate",
    SubrequirementsOtherLocked = "SubrequirementsOtherLocked",
    SubrequirementsOtherNotPermitted = "SubrequirementsOtherNotPermitted",
    SubrequirementsCircleFound = "SubrequirementsCircleFound",
    SubrequirementsInconsistent = "SubrequirementsInconsistent",
    RichtextMultipleFormatsProvided = "RichtextMultipleFormatsProvided",
    RichtextInvalidImageUrl = "RichtextInvalidImageUrl",
    ProjectConfigImportFailed = "ProjectConfigImportFailed",
    FieldRulesCycle = "FieldRulesCycle",
    FieldRuleValueChangedNotSupported = "FieldRuleValueChangedNotSupported",
    EnclosureNotFound = "EnclosureNotFound",
    InvalidParameterValue = "InvalidParameterValue",
    CalculatedFieldModified = "CalculatedFieldModified",
    SupportOnlyAutomatedItem = "SupportOnlyAutomatedItem",
    InvalidAgent = "InvalidAgent",
    AgentNotFound = "AgentNotFound",
    TestJobDisallowAgent = "TestJobDisallowAgent",
    ExecutionDependencyViolation = "ExecutionDependencyViolation",
    InvalidValueSet = "InvalidValueSet",
    NoValueSetSelected = "NoValueSetSelected",
    InvalidTestJobIndex = "InvalidTestJobIndex",
    TestJobNotFound = "TestJobNotFound",
    TestJobAgentNotFound = "TestJobAgentNotFound",
    TestJobAgentNotSelected = "TestJobAgentNotSelected",
    InvalidTestJobRunDependencyIndex = "InvalidTestJobRunDependencyIndex",
    WorkflowTransitionNotAllowed = "WorkflowTransitionNotAllowed",
    NestedTestCaseLoop = "NestedTestCaseLoop",
    NoTestData = "NoTestData",
    TestDataTooManyValues = "TestDataTooManyValues",
    TestDataValueSetNotFound = "TestDataValueSetNotFound",
    TestDataNumberOfValuesMisMatchToVariables = "TestDataNumberOfValuesMisMatchToVariables",
    TestDataMisMatchVariablesNamesOrLength = "TestDataMisMatchVariablesNamesOrLength",
    TestDataNumberOfValuesMisMatchToValueSets = "TestDataNumberOfValuesMisMatchToValueSets",
    TestDataVariableNameTooLong = "TestDataVariableNameTooLong",
    TestDataVariableNameNotUnique = "TestDataVariableNameNotUnique",
    TestDataVariableNameInvalid = "TestDataVariableNameInvalid",
    TestDataValueSetNameTooLong = "TestDataValueSetNameTooLong",
    TestDataValueSetNameNotUnique = "TestDataValueSetNameNotUnique",
    TestDataValueSetNameInvalid = "TestDataValueSetNameInvalid",
    TestDataValueTooLong = "TestDataValueTooLong",
    TestDataImportNoSheet = "TestDataImportNoSheet",
    TestDataImportNoVariables = "TestDataImportNoVariables",
    TestDataImportNoValueSets = "TestDataImportNoValueSets",
    TestDataNoValueSets = "TestDataNoValueSets",
    TestDataImportInvalidXml = "TestDataImportInvalidXml",
    TestDataImportInvalidFile = "TestDataImportInvalidFile",
    TestDataImportXmlMissingVariableName = "TestDataImportXmlMissingVariableName",
    TestDataImportXmlValueSetNotFound = "TestDataImportXmlValueSetNotFound",
    TestDataImportXmlVariableNotFound = "TestDataImportXmlVariableNotFound",
    TestDataImportFailed = "TestDataImportFailed",
    TestDataExportTooManyVariablesForFileFormat = "TestDataExportTooManyVariablesForFileFormat",
    TestDataFileFormatNotSupported = "TestDataFileFormatNotSupported",
    InvalidTestDataLength = "InvalidTestDataLength",
    ValueTooBig = "ValueTooBig",
    TestDataRemoteTCNotAccessible = "TestDataRemoteTCNotAccessible",
    TestDataRemoteTCDeleted = "TestDataRemoteTCDeleted",
    TestDataRemoteTCAlreadyReferences = "TestDataRemoteTCAlreadyReferences",
    TestDataRemoteTCNoTestData = "TestDataRemoteTCNoTestData",
    CannotUpdateReferencedTestData = "CannotUpdateReferencedTestData",
    InvalidTestStepIndex = "InvalidTestStepIndex",
    TestStepNotFound = "TestStepNotFound",
    TestScenarioNotFound = "TestScenarioNotFound",
    TestStepOfTypeConditionContainsExpectedResult = "TestStepOfTypeConditionContainsExpectedResult",
    TestStepMandatoryExpectedResultIsEmpty = "TestStepMandatoryExpectedResultIsEmpty",
    TestStepEmptyNestedTestCase = "TestStepEmptyNestedTestCase",
    TestStepOfTypeNestedTestCaseNotEmptyValues = "TestStepOfTypeNestedTestCaseNotEmptyValues",
    TestStepNotEmptyNestedTestCase = "TestStepNotEmptyNestedTestCase",
    InvalidNestedTestCaseId = "InvalidNestedTestCaseId",
    ExecutionNotForSingleTestScenario = "ExecutionNotForSingleTestScenario",
    TestCaseNotFound = "TestCaseNotFound",
    InvalidTestJobId = "InvalidTestJobId",
    NoTestSteps = "NoTestSteps",
    ExpectedResultsMissing = "ExpectedResultsMissing",
    ExpectedResultsNotAllowedForCondition = "ExpectedResultsNotAllowedForCondition",
    ActualResultsMissing = "ActualResultsMissing",
    RunDependenciesMissing = "RunDependenciesMissing",
    TooManyTestJobs = "TooManyTestJobs",
    NoExecutions = "NoExecutions",
    UserNotFound = "UserNotFound",
    ProjectUserNotAssigned = "ProjectUserNotAssigned",
    ProjectFolderUserIsAlreadyAssigned = "ProjectFolderUserIsAlreadyAssigned",
    AssignmentDeleteFailed = "AssignmentDeleteFailed",
    ProjectRoleNotFound = "ProjectRoleNotFound",
    ProjectRoleUpdateDuplicateEntry = "ProjectRoleUpdateDuplicateEntry",
    ProjectRoleUpdateInvalidEntry = "ProjectRoleUpdateInvalidEntry",
    FolderNotFound = "FolderNotFound",
    ItemNotFound = "ItemNotFound",
    ProjectNotFound = "ProjectNotFound",
    DuplicateProjectName = "DuplicateProjectName",
    ProjectMaximumNumberReached = "ProjectMaximumNumberReached",
    DuplicateDictionary = "DuplicateDictionary",
    DuplicateDictionaryEntry = "DuplicateDictionaryEntry",
    MultipleDefaultEntries = "MultipleDefaultEntries",
    DictionaryEntryNotFound = "DictionaryEntryNotFound",
    WrongDictionary = "WrongDictionary",
    EmptyItemName = "EmptyItemName",
    AutomationInTestStepNotPresentOrInvalid = "AutomationInTestStepNotPresentOrInvalid",
    NotManualTestExecution = "NotManualTestExecution",
    ManualTestExecution = "ManualTestExecution",
    AttachmentNotFound = "AttachmentNotFound",
    AttachmentMaxSizeExceeded = "AttachmentMaxSizeExceeded",
    ImageMaxSizeExceeded = "ImageMaxSizeExceeded",
    ImageFormatInvalid = "ImageFormatInvalid",
    AttachmentMaxTransferSizeExceeded = "AttachmentMaxTransferSizeExceeded",
    FileNotFound = "FileNotFound",
    TestExecutionNotFound = "TestExecutionNotFound",
    TestExecutionFinalized = "TestExecutionFinalized",
    InvalidTestStepId = "InvalidTestStepId",
    ManualExecutionsWithStatusAndWithout = "ManualExecutionsWithStatusAndWithout",
    ArchiveJobAlreadyStarted = "ArchiveJobAlreadyStarted",
    UpdateOncePerTestExecution = "UpdateOncePerTestExecution",
    EmptyListNotAllowed = "EmptyListNotAllowed",
    AutomationScriptUnsupportedTechnologySave = "AutomationScriptUnsupportedTechnologySave",
    InvalidTestData = "InvalidTestData",
    UserEntriesCannotBeLocked = "UserEntriesCannotBeLocked",
    UserEntriesMustHaveUserId = "UserEntriesMustHaveUserId",
    DefaultEntriesUserIdNotAllowed = "DefaultEntriesUserIdNotAllowed",
    FolderNameNotUnique = "FolderNameNotUnique",
    FolderCycle = "FolderCycle",
    FolderNameEmpty = "FolderNameEmpty",
    FolderNotEmpty = "FolderNotEmpty",
    DuplicateSprintName = "DuplicateSprintName",
    EmptySprintName = "EmptySprintName",
    InvalidStepType = "InvalidStepType",
    InvalidTestStepExecutionStatusType = "InvalidTestStepExecutionStatusType",
    FolderNotificationRuleNotEmpty = "FolderNotificationRuleNotEmpty",
    CustomFilterAcceptedStatusesNotRecognized = "CustomFilterAcceptedStatusesNotRecognized",
    CustomFilterOptionsNotEmpty = "CustomFilterOptionsNotEmpty",
    FilterInvalid = "FilterInvalid",
    FilterGroupInvalid = "FilterGroupInvalid",
    FilterGroupOperatorInvalid = "FilterGroupOperatorInvalid",
    FilterGroupOperatorsMixed = "FilterGroupOperatorsMixed",
    FilterClauseInvalid = "FilterClauseInvalid",
    FilterClauseFieldInvalid = "FilterClauseFieldInvalid",
    FilterClauseUnknownField = "FilterClauseUnknownField",
    FilterClauseFieldNotSupported = "FilterClauseFieldNotSupported",
    FilterClauseOperatorInvalid = "FilterClauseOperatorInvalid",
    FilterClauseOperatorNotSupported = "FilterClauseOperatorNotSupported",
    FilterClauseValueInvalid = "FilterClauseValueInvalid",
    FilterClauseIncorrectNumberOfValues = "FilterClauseIncorrectNumberOfValues",
    SortInvalid = "SortInvalid",
    SortClauseInvalid = "SortClauseInvalid",
    SortClauseFieldInvalid = "SortClauseFieldInvalid",
    SortClauseUnknownField = "SortClauseUnknownField",
    SortClauseFieldNotSupported = "SortClauseFieldNotSupported",
    SortClauseDirectionInvalid = "SortClauseDirectionInvalid",
    ReportDefinitionNotFound = "ReportDefinitionNotFound",
    InvalidReportDefinitionFile = "InvalidReportDefinitionFile",
    ReportScriptingNotAllowed = "ReportScriptingNotAllowed",
    ReportPluginNotRecognized = "ReportPluginNotRecognized",
    InvalidPatchType = "InvalidPatchType",
    WrongPatchType = "WrongPatchType",
    ExecuteAllWithTestJobIds = "ExecuteAllWithTestJobIds",
    DuplicateAgentName = "DuplicateAgentName",
    DuplicateAgentCode = "DuplicateAgentCode",
    EmptyAgentName = "EmptyAgentName",
    InvalidAgentTypeForCopy = "InvalidAgentTypeForCopy",
    InvalidApiItemTypeToObjectTypeMask = "InvalidApiItemTypeToObjectTypeMask",
    InvalidItemPath = "InvalidItemPath",
    DuplicateReportParameter = "DuplicateReportParameter",
    InvalidFolderIdMultiProjectReport = "InvalidFolderIdMultiProjectReport",
    InvalidColor = "InvalidColor",
    InvalidApplicableItemTypes = "InvalidApplicableItemTypes",
    InvalidVersionOfProjectConfigFile = "InvalidVersionOfProjectConfigFile",
    OperationBlockedByOtherTask = "OperationBlockedByOtherTask",
    ItemTypeNotSupported = "ItemTypeNotSupported",
    EmptyDashboardTitle = "EmptyDashboardTitle",
    InvalidReorderWidgets = "InvalidReorderWidgets",
    DuplicateProjectFolderFavourite = "DuplicateProjectFolderFavourite",
    SprintStillContainsItems = "SprintStillContainsItems",
    InvalidIntialLetters = "InvalidIntialLetters",
    InvalidProjectTreeParentFolder = "InvalidProjectTreeParentFolder",
    InvalidDependencyDependentOnItSelf = "InvalidDependencyDependentOnItSelf",
    CannotModifyAutomaticDependencies = "CannotModifyAutomaticDependencies",
    MultiChoiceFieldValueExceededMaxLength = "MultiChoiceFieldValueExceededMaxLength",
    NotificationTemplateInvalidLanguage = "NotificationTemplateInvalidLanguage",
    InvalidReportParameterValue = "InvalidReportParameterValue",
    UnknownReportParameter = "UnknownReportParameter",
    InvalidApiImportPhase = "InvalidApiImportPhase",
    InvalidApiImportErrorType = "InvalidApiImportErrorType",
    SharedDictionaryNotAllowed = "SharedDictionaryNotAllowed",
    NotificationTemplateMixedLanguage = "NotificationTemplateMixedLanguage",
    ExecutableFilesUploadBlocked = "ExecutableFilesUploadBlocked",
    ItemTypeNotSupportedInDashboards = "ItemTypeNotSupportedInDashboards",
    InvalidUsername = "InvalidUsername",
    DuplicateUserName = "DuplicateUserName",
    InvalidEmail = "InvalidEmail",
    LowPasswordComplexity = "LowPasswordComplexity",
    InvalidLicenseCode = "InvalidLicenseCode",
    NoFreeLicenses = "NoFreeLicenses",
    InvalidLicenseAssignmentAlreadyAssigned = "InvalidLicenseAssignmentAlreadyAssigned",
    InvalidLicenseAssignmentNotAssigned = "InvalidLicenseAssignmentNotAssigned",
    LicenseTypeNotChanged = "LicenseTypeNotChanged",
    InvalidApiPermission = "InvalidApiPermission",
    ViolatedPermissionDependencies = "ViolatedPermissionDependencies",
    DuplicateRoleName = "DuplicateRoleName",
    RoleNotFound = "RoleNotFound",
    InvalidProjectAssignment = "InvalidProjectAssignment",
    ProjectTemplateFieldIsActivated = "ProjectTemplateFieldIsActivated",
    ProjectTemplateFieldIsDeactivated = "ProjectTemplateFieldIsDeactivated",
    ProjectTemplateDuplicateFieldOperations = "ProjectTemplateDuplicateFieldOperations",
    ProjectTemplateNotIntendedLayoutChange = "ProjectTemplateNotIntendedLayoutChange",
    ProjectTemplateFieldOperationNotAllowed = "ProjectTemplateFieldOperationNotAllowed",
}

/** This error is returned when the aqua backend is not available. You can wait a couple of minutes and check if the backend is available again. If not, you might want to contact your aqua administrator. */
export interface ApiBackendNotAvailableError extends ApiError {
}

/** This error is returned when the current user is not allowed to perform the requested operation. */
export interface ApiForbiddenError extends ApiError {
    /** The reason why the current user is not allowed to perform the requested
operation. */
    ForbiddenErrorType: ApiForbiddenErrorType;
}

/** The different reasons why a Forbidden error might occur. This enum has the following values:  - `NotLicensed` The current user's license does not allow to perform the requested operation.  - `NotPermitted` The current user does not have permission to perform the requested operation. */
export enum ApiForbiddenErrorType {
    NotLicensed = "NotLicensed",
    NotPermitted = "NotPermitted",
}

/** An internal error occurred in the REST API. Please ask your administrator to check the aqua server logs. */
export interface ApiInternalError extends ApiError {
}

/** This error is returned when media type of the request is not supported. Unless files are uploaded, only the media type application/json is supported. */
export interface ApiMediaTypeNotSupportedError extends ApiError {
}

/** This error is returned when the endpoint does not support the requested HTTP method. Please refer to the REST API documentation for the supported HTTP methods. */
export interface ApiMethodNotAllowedError extends ApiError {
}

/** This error is returned when the specified entity or endpoint does not exist. */
export interface ApiNotFoundError extends ApiError {
}

/** An automation agent or pool (configured in a project). */
export interface ApiAgentBase {
    /** The id of the agent. */
    Id: number;
    /** The name of the agent. */
    Name: string;
    /** The id of the project the agent is created in. */
    ProjectId: number;
    /** The code of the agent. */
    Code: string;
    /** Status of the agent. */
    Status: ApiAgentSimpleStatus;
    /** The technologies supported by this agent.  */
    SupportedTechnologies: ApiAutomationTechnology[];
    AgentType: string;
}

/** Represents current status of an automation agent This enum has the following values:  - `Available`  - `BlockedOrNoAgents`  - `NoResponseYet`  - `PartiallyAvailable`  - `Unavailable` */
export enum ApiAgentSimpleStatus {
    BlockedOrNoAgents = "BlockedOrNoAgents",
    Available = "Available",
    PartiallyAvailable = "PartiallyAvailable",
    Unavailable = "Unavailable",
    NoResponseYet = "NoResponseYet",
}

/** Represents the different test automation technologies supported by aqua. This enum has the following values:  - `Database` aqua's database automation technology allows to execute SQL instructions against various database management systems.  - `Jenkins` Integration with the Jenkins CI and CD server. Allows to trigger jobs on the Jenkins server.  - `JMeter` Integration of the load and performance test tool Apache JMeter.  - `None` No test automation technology is used.  - `PowerShell` aqua's Powershell integration allows to execute arbitrary Powershell scripts.  - `QTP` HP QuickTest Professional integration  - `Ranorex` Ranorex integration  - `SoapUI` SoapUI integration  - `UFT` MicroFocus Unified Functional Testing integration  - `UnixShell` aqua's UnixShell integration allows to execute arbitrary unix shell scripts in various languages. */
export enum ApiAutomationTechnology {
    None = "None",
    Database = "Database",
    Jenkins = "Jenkins",
    JMeter = "JMeter",
    PowerShell = "PowerShell",
    QTP = "QTP",
    Ranorex = "Ranorex",
    SoapUI = "SoapUI",
    UFT = "UFT",
    UnixShell = "UnixShell",
}

/** Represents a pool of automation agents. */
export interface ApiPool extends ApiAgentBase {
    /** List of agent ids included in this pool. */
    Agents: ApiAgentIdAndName[];
}

/** Some minimal identifying information for an agent. */
export interface ApiAgentIdAndName {
    /** The id of the agent. When the id is not provided, the agent
has been deleted. */
    Id: number | undefined;
    /** The name of the agent. */
    Name: string;
}

/** Represents an automation agent (configured in a project). */
export interface ApiSingleAgent extends ApiAgentBase {
    /** Execution status of the agent. */
    ExecutionStatus: ApiAgentExecutionStatus;
}

/** Represents current execution status of an automation agent This enum has the following values:  - `Executing`  - `Idle`  - `Offline` */
export enum ApiAgentExecutionStatus {
    Idle = "Idle",
    Executing = "Executing",
    Offline = "Offline",
}

/** Represents data required to execute single agent - create operation. */
export interface ApiAgentCreateOperation {
    CreateOperation: string;
}

/** Create single agent operation. */
export interface ApiAgentCreateSingleAgent extends ApiAgentCreateOperation {
    /** The id of the project the agent is created in. */
    ProjectId: number;
    /** The name of the agent. */
    Name: string;
}

/** Create single agent as copy operation. */
export interface ApiAgentCreateCopySingleAgent extends ApiAgentCreateOperation {
    /** The id of the project the agent is copied to. */
    ProjectId: number;
    /** The name of the copied agent. */
    Name: string | undefined;
    /** The id of the agent wich should be copied.  */
    AgentIdToCopy: number;
}

/** Create single agent as copy operation. */
export interface ApiAgentCreatePool extends ApiAgentCreateOperation {
    /** The id of the project the agent is created in. */
    ProjectId: number;
    /** The name of the agent pool. */
    Name: string;
    /** A list of agent ids included in this pool. */
    Agents: number[] | undefined;
}

/** Represents data required to execute modify operation. */
export interface ApiAgentPatchOperation {
    PatchOperation: string;
}

/** Rename project operation. */
export interface ApiAgentPatchUpdatePool extends ApiAgentPatchOperation {
    /** New name of the pool.  */
    NewName: string | undefined;
    /** A list of agent ids included in this pool. */
    Agents: number[] | undefined;
}

/** Rename project operation. */
export interface ApiAgentPatchUpdateSingleAgent extends ApiAgentPatchOperation {
    /** New name of the single agent.  */
    NewName: string;
}

/** Contains information about created sprint. */
export interface ApiSprintNewResponse {
    /** The id of the sprint. */
    SprintId: number;
}

/** Contains necessery information to create a new sprint. */
export interface ApiSprintNew {
    /** The name of the sprint. */
    Name: string | undefined;
    /** The project id. */
    ProjectId: number;
    /** The number of story points per sprint. */
    AvailableStoryPoints: number;
    /** The date of the sprint start. */
    Start: Date | undefined;
    /** The date of the sprint end. */
    End: Date | undefined;
    /** Indicates that the sprint ist active. */
    Active: boolean;
    /** Sprint tags. */
    Tags: string | undefined;
    /** The description of the sprint. */
    Description: string | undefined;
}

/** A persistent sprint. */
export interface ApiSprint {
    /** The id of the sprint. */
    Id: number;
    /** The name of the sprint. */
    Name: string | undefined;
    /** The project id. */
    ProjectId: number;
    /** The number of story points per sprint. */
    AvailableStoryPoints: number;
    /** The date of the sprint start. */
    Start: Date | undefined;
    /** The date of the sprint end. */
    End: Date | undefined;
    /** Indicates that the sprint ist active. */
    Active: boolean;
    /** Sprint tags. */
    Tags: string | undefined;
    /** The description of the sprint. */
    Description: string | undefined;
    /** Count of the assigned items, by the item type. */
    Statistics: ApiSprintStatistic | undefined;
}

/** Contains statistics, count of the assigned items, by the item type. */
export interface ApiSprintStatistic {
    /** Count of assigned defects. */
    CountDefects: number;
    /** Count of assigned requirements. */
    CountRequirements: number;
    /** Count of assigned test cases. */
    CountTestCases: number;
    /** Count of assigned test scenarios. */
    CountTestScenarios: number;
    /** Count of assigned scripts. */
    CountScripts: number;
}

/** Contains information to update a new sprint. */
export interface ApiSprintUpdate {
    /** The name of the sprint. */
    Name: string | undefined;
    /** The number of story points per sprint. */
    AvailableStoryPoints: number | undefined;
    /** The date of the sprint start. */
    Start: Date | undefined;
    /** The date of the sprint end. */
    End: Date | undefined;
    /** Indicates that the sprint ist active. */
    Active: boolean | undefined;
    /** Sprint tags. */
    Tags: string | undefined;
    /** The description of the sprint. */
    Description: string | undefined;
}

/** Wraps a list of items together with some meta data */
export interface ApiItemListResult {
    /** The list of items. */
    Items: ApiItem[] | undefined;
    /** The number of items which were skipped in the list of results.
This value is provided during the request. */
    StartAt: number;
    /** The maximum number of items which should be included in the result. */
    MaxResults: number;
    /** The overall number of items which are available. When using pagination,
this number is higher than the number of items which are included in the result. */
    Count: number;
}

export interface ApiItemIdentifier {
    /** The id of the item */
    Id: number;
    /** A nicely formatted version of the id which
contains the item type identifier and the numerical
id padded to six digits. E.g.: RQ004242.
This id is only for presentation. You must use the
numerical id for all requests. */
    FormattedId: string | undefined;
    /** The type of the item */
    Type: ApiItemType;
}

/** Contains only the basic information of a specific item. */
export interface ApiItemInfo extends ApiItemIdentifier {
    /** The name of the item */
    Name: string | undefined;
    /** The version information for the item. */
    Version: ApiItemVersion | undefined;
    /** The archived flag of the item. */
    Archived: boolean;
    /** The location (project and folder) of the item */
    Location: ApiItemLocation | undefined;
    /** The last modification date of the item. */
    LastModified: ApiFieldValueDateTime | undefined;
    /** Contains information whether the item is editable by
the current user or not. When the item is locked, this
info also contains the locking user. */
    EditableInfo: ApiEditableInfo | undefined;
    /** Specifies permissions of current user in regard to operations available for this item. 
Please note that proper subclass is returned basing on the item type:

TestCase: ApiTestCasePermissions,
Requirement: ApiRequirementPermissions,
Defect: ApiDefectPermissions,

Please also note that Permissions might be empty (null) what means they haven't been initialized 
for the particular call (due to optimalizations). In this case you have to retrive the item separatelly 
to get permissions information.  */
    Permissions: ApiItemPermissions | undefined;
    /** True if item has any dependency.  */
    HasDependency: boolean;
    /** True if item has any attachments.  */
    HasFiles: boolean;
    SyncStatus: ApiSyncItemStatus | undefined;
}

/** Represents an item. */
export interface ApiItem extends ApiItemInfo {
    /** Contains all the different fields specified for this item type */
    Details: ApiFieldWithValue[] | undefined;
    /** Contains information about fields layout (i.e. how to layout fields in the edit mask). */
    EditLayout: ApiEditLayout | undefined;
}

/** Contains meta information for a specific field of an item. */
export interface ApiField {
    /** The id of the field. The field id is identical to the internal property name. Therefore, it is
only unique in scope of the same project and item type. */
    Id: string | undefined;
    /** The title for the field which should be shown in the user interface. */
    Title: string | undefined;
    /** The type of the field. */
    FieldType: ApiFieldType;
    /** The metadata required for editing the field. */
    EditMeta: ApiFieldEditMeta | undefined;
}

/** The field of an aqua item including its value. */
export interface ApiFieldWithValue extends ApiField {
    /** The value of the field. The data structure can be different depending
on the field type but will always contain a human-readable text representation
of the value. */
    Value: ApiFieldValue | undefined;
}

export interface ApiFieldValue {
    /** A human-readable representation of the field value. */
    Text: string | undefined;
    FieldValueType: string;
}

export interface ApiFieldValueDateTime extends ApiFieldValue {
    Value: Date | undefined;
}

export interface ApiFieldValueDecimal extends ApiFieldValue {
    Value: number;
}

export interface ApiFieldValueDictionary extends ApiFieldValue {
    Id: number;
}

/** The value of a multi choice dictionary field. Contains the value both as list of ids and list of names. */
export interface ApiFieldValueDictionaryMultiChoice extends ApiFieldValue {
    /** The list of field value ids. */
    Ids: number[] | undefined;
    /** The list of field value names. */
    Values: string[] | undefined;
}

export interface ApiFieldValueExecutionHistory extends ApiFieldValue {
    Value: ApiTestCaseExecutionHistory | undefined;
}

/** Historic information regarding the last executions of a test case or test job. */
export interface ApiTestCaseExecutionHistory {
    /** The maximum number of entries the history can have. The history can
have less entries when the test case or test job has not been executed
that often yet. */
    MaxNumberOfEntries: number;
    /** The list of history entries. */
    Entries: ApiTestCaseExecutionHistoryEntry[] | undefined;
}

/** Contains history information for a single test execution. */
export interface ApiTestCaseExecutionHistoryEntry {
    /** The status of execution. */
    ExecutionStatus: ApiTestCaseRunStatus;
    /** The date of execution. */
    ExecutionDate: ApiFieldValueDateTime | undefined;
    /** The id of test scenario. */
    TestScenarioId: number | undefined;
}

/** Identifies the status of an execution of a test case. This enum has the following values:  - `Blocked` Execution has been blocked  - `Failed` Execution has failed  - `NotApplicable` Execution status is not applicable to result  - `NotCompleted` Execution has started but not completed yet  - `NotRun` Never executed  - `Passed` Execution has passed */
export enum ApiTestCaseRunStatus {
    NotRun = "NotRun",
    NotCompleted = "NotCompleted",
    Failed = "Failed",
    Passed = "Passed",
    Blocked = "Blocked",
    NotApplicable = "NotApplicable",
}

export interface ApiFieldValueFlag extends ApiFieldValue {
    Value: boolean;
}

export interface ApiFieldValueId extends ApiFieldValue {
    Value: number;
}

export interface ApiFieldValueRichText extends ApiFieldValue {
    /** The rich text contained in the field as HTML. The HTML includes
pictures as img tags. */
    Html: string | undefined;
}

export interface ApiFieldValueSprint extends ApiFieldValue {
    /** The Id of the Sprint */
    Id: number;
}

export interface ApiFieldValueString extends ApiFieldValue {
}

export interface ApiFieldValueTestJobStatistics extends ApiFieldValue {
    Value: ApiTestJobStatisticsEntry[] | undefined;
}

/** Holds statistical information for test jobs with a single last execution status. */
export interface ApiTestJobStatisticsEntry {
    /** The last execution status to which this statistical
information applies. */
    Status: ApiTestCaseRunStatus;
    /** The title of the execution status. */
    Title: string | undefined;
    /** The number of test jobs which reached this status
during their last execution. */
    Count: number;
    /** The percentage of test jobs which reached this status
during their last execution. */
    Percentage: number;
}

export interface ApiFieldValueTestScenarios extends ApiFieldValue {
    Value: number[] | undefined;
}

/** A time span which consists of a value and a unit. */
export interface ApiFieldValueTimeSpan extends ApiFieldValue {
    /** The value of the given time span. The base unit is
given separately. */
    Value: number;
    /** The unit which is used for the given time span. */
    Unit: TimeUnit;
}

/** This enum has the following values:  - `Day`  - `Hour`  - `Minute`  - `Month`  - `Second`  - `Week` */
export enum TimeUnit {
    Day = "Day",
    Minute = "Minute",
    Hour = "Hour",
    Second = "Second",
    Week = "Week",
    Month = "Month",
}

export interface ApiFieldValueUser extends ApiFieldValue {
    /** The id of the user. */
    Id: number;
    /** Further information regarding the user. This might be null. */
    UserInfo: ApiUserInfo | undefined;
}

/** The user information */
export interface ApiUserInfo {
    /** The id of the user */
    Id: number;
    /** The username of the user */
    UserName: string | undefined;
    /** The first name of the user */
    FirstName: string | undefined;
    /** The surname / last name of the user */
    Surname: string | undefined;
    /** The full name of the user. This string is correctly formatted and
should be used when displaying a user e.g. in a list. */
    Fullname: string | undefined;
    /** The email address of the user */
    Email: string | undefined;
    /** The phone number of the user */
    Phone: string | undefined;
    /** The position of the user in the company */
    Position: string | undefined;
    /** The absolute url of the user's picture. Might be null, if
the user does not have a picture assigned. */
    PictureUrl: string | undefined;
}

export interface ApiFieldValueUserMultiChoice extends ApiFieldValue {
    /** The list of user ids */
    Ids: number[] | undefined;
    /** The list of users. Contains more information on each user. */
    Values: ApiUserInfo[] | undefined;
}

/** The value of a multi choice dictionary field. Contains the value both as list of ids and list of names. */
export interface ApiFieldValueStringList extends ApiFieldValue {
    /** The list of field value names. */
    Values: string[] | undefined;
}

export interface ApiFieldValueJson extends ApiFieldValue {
    Value: string | undefined;
}

/** Identifies the type of a field in aqua. This enum has the following values:  - `DateTime`  - `Decimal`  - `Dictionary`  - `DictionaryMultiChoice`  - `ExecutionHistory`  - `Flag`  - `Id`  - `Json`  - `Sprint`  - `String`  - `StringAutoComplete`  - `StringList`  - `TestJobStatistics`  - `TestScenarios`  - `Text`  - `TimeSpan`  - `User`  - `UserMultiChoice` */
export enum ApiFieldType {
    DateTime = "DateTime",
    Decimal = "Decimal",
    Dictionary = "Dictionary",
    DictionaryMultiChoice = "DictionaryMultiChoice",
    Sprint = "Sprint",
    String = "String",
    Text = "Text",
    TimeSpan = "TimeSpan",
    User = "User",
    UserMultiChoice = "UserMultiChoice",
    StringAutoComplete = "StringAutoComplete",
    Id = "Id",
    Flag = "Flag",
    ExecutionHistory = "ExecutionHistory",
    TestScenarios = "TestScenarios",
    TestJobStatistics = "TestJobStatistics",
    StringList = "StringList",
    Json = "Json",
}

/** Contains the information for a specific field of an item including the field's value. */
export interface ApiFieldEditMeta {
    /** The list of values which are allowed for this field. The list contains
different types of values depending on the field type. Null means that
all values which fit the field type are allowed.
This list of values is based on the project template and on the workflow.
These values might be restricted further by the Rules which are included
in this editmeta as well. */
    PossibleValues: any[] | undefined;
    /** Indicates whether the field allows ohter values which are not included in the
PossibleValues as long as they are fit the field type. */
    AllowOtherValues: boolean;
    /** Indicates that the field is required which means that it must
have a nonempty value. */
    Required: boolean;
    /** Indicates that the field is readonly and cannot be modified
by the user. */
    Readonly: boolean;
    /** The default value for the field. It might be mandatory to use the default
value which means that the field is fixed to the default value. */
    DefaultValue: ApiFieldDefaultValue | undefined;
    /** A list with additional rules which apply to this field. The client is responsible
for evaluating these rules as necessary when fields change. These rules might
further restrict the list of possible values. */
    Rules: ApiFieldRule[] | undefined;
    /** This field contains the minimal and maximal value. */
    Range: ApiFieldRange | undefined;
    /** Contains formatting information for a specific field.  */
    FieldMask: string | undefined;
    /** Indicates whether the item should be visible in a UI. The visibility
of the field might depend on the item's status when a workflow is active.
In this case, the field will still have valid index. */
    Visible: boolean;
    /** Indicates that the field should be highlighted in the UI. */
    Highlight: boolean;
}

/** Contains the default value for certain field. */
export interface ApiFieldDefaultValue {
    /** The field value that should be used. The exact structure of the
field value depends on the field type. */
    Value: ApiFieldValue | undefined;
    /** Indicates that the field must be set to the default value. The field
is fixed to this exact value. */
    Mandatory: boolean;
}

/** Represents a single rule for a field. */
export interface ApiFieldRule {
    /** The unique id of the field rule. */
    Guid: string;
    /** The id of the field to which the rule applies. */
    FieldId: string;
    RuleType: string;
}

/** This field rule allows to specify actions which are performed when a dictionary field is changed to a certain value. */
export interface ApiFieldRuleWorkflow extends ApiFieldRule {
    /** The list of transitions which this rule defines. Each transition
specifies a list of actions which should be performed when the
field is changed to the specified value. */
    Transitions: ApiFieldRuleWorkflowTransition[];
}

/** Contains all the actions which should be performed when the dictionary field is changed to the specified value. */
export interface ApiFieldRuleWorkflowTransition {
    /** The field value to which this transition applies. */
    Value: ApiFieldValue;
    /** The list of actions which are executed when the value of the
dictionary field is changed to the specified value. */
    Actions: ApiFieldRuleWorkflowActions[];
}

/** Contains the actions which should be performed for one specific field. */
export interface ApiFieldRuleWorkflowActions {
    /** This action is applied to the field with this id. */
    FieldId: string;
    /** Indicates whether the field should be readonly. */
    Readonly: boolean;
    /** Indicates whether the field should be required. */
    Required: boolean;
    /** Indicates whether the field should be visible. */
    Visible: boolean;
    /** Indicates whether the field should be highlighted. */
    Highlight: boolean;
    /** Indicates whether the value of the field should be changed. */
    ChangeValue: boolean;
    /** The value to which the field should be set. The type depends
on the field type. */
    Value: ApiFieldValue | undefined;
}

/** A field rule which defines a dependency between to dictionary fields. Values of the field with the id FieldId are only allowed for certain values in the field with the id OtherFieldId. */
export interface ApiFieldRuleDependentValues extends ApiFieldRule {
    /** The id of the other field on which the field to which this rule applies depends. */
    OtherFieldId: string;
    /** The list with the restrictions for the value of the field. */
    Restrictions: ApiFieldValueRestriction[];
}

/** The restriction for certain field value. */
export interface ApiFieldValueRestriction {
    /** The field value to which this restriction applies. */
    Value: ApiFieldValue;
    /** The values of the other field for which the specified
value is allowed. */
    AllowedFor: ApiFieldValue[];
}

export interface ApiFieldRange {
    /** If the field has the type decimal, this field contains the minimal value. */
    Min: number | undefined;
    /** If the field has the type decimal, this field contains the maximal value. */
    Max: number | undefined;
}

export interface ApiEditLayout {
    Entries: ApiEditLayoutEntry[] | undefined;
}

/** Edit layout entry. Depending on type different properties are available (see subclasses). */
export interface ApiEditLayoutEntry {
    EntryType: string;
}

/** Edit layout entry describing a single field. */
export interface ApiEditLayoutEntryField extends ApiEditLayoutEntry {
    /** Id of the field. */
    FieldId: string | undefined;
    /** The number of columns this field should span in the UI layout.
A three-column layout is assumed. */
    ColSpan: number;
    /** Indicates whether this field should be placed on a new line in
the UI layout. */
    StartsNewLine: boolean;
}

/** Edit layout entry describing a group. */
export interface ApiEditLayoutEntryGroup extends ApiEditLayoutEntry {
    /** Group's caption. */
    Caption: string | undefined;
    /** Indicates whether group should be initially expanded.  */
    Expanded: boolean;
    /** Members of this group */
    GroupMembers: ApiEditLayoutEntry[] | undefined;
}

/** Version information for an item. */
export interface ApiItemVersion {
    /** The version of the item. This version field is incremented each time
the item is modified. */
    Version: number;
    /** This field is incremented when the item itself was not modified
but the information in some system-managed fields changed. */
    OperationNumber: number;
    /** The same as OperationNumber but for changes which are
less important and do not increment the operation number. */
    SubOperationNumber: number;
}

/** Specifies the location (project and folder) of an item */
export interface ApiItemLocation {
    /** The id of the project */
    ProjectId: number | undefined;
    /** The name of the project */
    ProjectName: string | undefined;
    /** The id of the folder */
    FolderId: number | undefined;
    /** The human readable path as text. The path consists of the project name and
the folder names separated by slashes */
    Text: string | undefined;
    /** Provides a list of folders with the complete path. The order of items corresponds to the path. The project itself is not contained. */
    Path: ApiProjectFolder[] | undefined;
    /** Indicates whether the project is archived. */
    IsProjectArchived: boolean;
}

export interface ApiProjectFolder {
    /** Id of folder */
    Id: number;
    /** Name of folder */
    Name: string | undefined;
    /** Folder Id of Parent, '0' means it is a root folder of the given project */
    ParentFolderId: number;
    /** Permissions of folder-level operations. 
Note: this property is included conditionally, 
so null means it has not been initialized.  */
    FolderPermissions: ApiProjectFolderPermissions | undefined;
}

/** Represents permissions in a project. */
export interface ApiProjectFolderPermissions {
    /** Requirement permissions. */
    Requirement: ApiProjectFolderItemTypePermissions | undefined;
    /** Defect permissions. */
    Defect: ApiProjectFolderItemTypePermissions | undefined;
    /** Test case permissions. */
    TestCase: ApiProjectFolderItemTypePermissions | undefined;
    /** Test scenario permissions. */
    TestScenario: ApiProjectFolderItemTypePermissions | undefined;
    /** Script permissions. */
    Script: ApiProjectFolderItemTypePermissions | undefined;
    /** Indicates whether the user is able to manage the folder tree (create/edit/delete folders). */
    CanManageTree: ApiPermissionResult;
    /** Indicates whether the user is able to import items to the folder. */
    CanImportItems: ApiPermissionResult;
    /** Indicates whether the user is able to export items from the folder. */
    CanExportItems: ApiPermissionResult;
}

/** Represents item-type related permissions in a project folder. */
export interface ApiProjectFolderItemTypePermissions {
    /** Indicates whether user is able to see items in this folder. */
    CanViewItem: ApiPermissionResult;
    /** Indicates whether user is able to create item in this folder. */
    CanCreateItem: ApiPermissionResult;
    /** Indicates whether user is able to view items in any of the subfolders (including current folder) */
    CanViewItemAnySubfolder: ApiPermissionResult;
    /** Indicates whether user is able to edit items in any of the subfolders (including current folder)
By edit we mean edit any aspect of the item (this also includes Owned/Assigned variants of the permission).  */
    CanEditItemAnySubfolder: ApiPermissionResult;
    /** Indicates whether user is able to cut items in any of the subfolders (including current folder). 
This permission is also granted if the user is able to cut items which are assigned to him or owned by him. */
    CanCutItemAnySubfolder: ApiPermissionResult;
    /** Indicates whether user is able to batch-edit items in any of the subfolders (including current folder) */
    CanBatchEditItemAnySubfolder: ApiPermissionResult;
    /** Indicates whether user is able to create items in any of the subfolders (including current folder) */
    CanCreateItemAnySubfolder: ApiPermissionResult;
    /** Indicates whether user is able to delete items in any of the subfolders (including current folder)
This also includes Owned/Assigned variants of the permission. */
    CanDeleteItemAnySubfolder: ApiPermissionResult;
    /** Indicates whether the user in allowed to execute automated tests cases */
    CanExecuteTestCaseAutomated: ApiPermissionResult;
    /** Indicates whether the user in allowed to perform manual test executions */
    CanExecuteTestCaseManual: ApiPermissionResult;
    /** Indicates whether the user in allowed to finalize test executions */
    CanFinalizeTestExecution: ApiPermissionResult;
}

/** Contains information about editable status of an item. */
export interface ApiEditableInfo {
    /** Editable status */
    Status: ApiEditableStatus;
    /** If item is currently being edited then contains information about the user editing the item */
    LockingUser: ApiUserInfo | undefined;
    /** If item is currently being edited then contains date when the edit started (when edit lock has been placed). */
    LockingDate: ApiFieldValueDateTime | undefined;
}

/** This enum has the following values:  - `Editable` The item can be edited.  - `Locked` The item is already locked (either by another user or by the same user in a different context)  - `NoPermissionToEdit` The current user is not permitted to edit the item.  - `NoPermissionToView` The current user is not permitted to view the item.  - `Unknown` No information is provided whether the item is editable or not. The item should not be edited based on this editable status. */
export enum ApiEditableStatus {
    Editable = "Editable",
    Locked = "Locked",
    NoPermissionToEdit = "NoPermissionToEdit",
    NoPermissionToView = "NoPermissionToView",
    Unknown = "Unknown",
}

/** Represents permissions of an item. Intended to be subclassed by classes with more fine-grained permission set for given context. */
export interface ApiItemPermissions {
    /** Indicates whether user is able to create the item dependency.
In order to create a dependency between two different item types it is enough to have 'Create Dependency' permission for either of the linked items.
If the permission is denied check the other side as well. */
    CanCreateDependency: ApiPermissionResult;
    /** Indicates whether user is able to delete the item dependency.
In order to delete a dependency between two different item types it is enough to have 'Delete Dependency' permission for either of the linked items.
If the permission is denied check the other side as well. */
    CanDeleteDependency: ApiPermissionResult;
    /** Indicates whether the user is able to create a new dependent item of
a certain type in the same folder as the current item is located in. */
    CanCreateDependentItem: { [key in keyof typeof ApiItemType]?: ApiPermissionResult; } | undefined;
    /** Indicates whether user is able to edit the item's fields. */
    CanEditFields: ApiPermissionResult;
    /** Indicates whether user is able to change the item's sttaus. */
    CanEditStatus: ApiPermissionResult;
    /** Indicates whether user is able to delete the item. */
    CanDelete: ApiPermissionResult;
    /** Indicates whether user is able to view the item's attachments. */
    CanViewAttachments: ApiPermissionResult;
    /** Indicates whether user is able to add attachments to the item. */
    CanAddAttachments: ApiPermissionResult;
    /** Indicates whether user is able to delete the item's attachments. */
    CanDeleteAttachments: ApiPermissionResult;
    /** Indicates whether user is able to edit/create mind maps. */
    CanCreateEditMindMap: ApiPermissionResult;
    /** Indicates whether the user is able to manage project-level
custom defaults for items of this type. */
    CanManageProjectCustomDefaults: ApiPermissionResult;
}

/** Identifies the type of item. This enum has the following values:  - `Defect`  - `ExternalJira`  - `ExternalOtrs`  - `Requirement`  - `Script`  - `TestCase`  - `TestExecution`  - `TestScenario` */
export enum ApiItemType {
    Defect = "Defect",
    Requirement = "Requirement",
    TestCase = "TestCase",
    TestScenario = "TestScenario",
    TestExecution = "TestExecution",
    Script = "Script",
    ExternalJira = "ExternalJira",
    ExternalOtrs = "ExternalOtrs",
}

/** This enum has the following values:  - `Error` The item is synced and there was a problem in the sync, sync stopped  - `Ok` The item is synced and sync status is ok  - `Unsynced` The item is not part of any sync  - `Warning` The item is synced and there was a problem in the sync, sync stopped */
export enum ApiSyncItemStatus {
    Ok = "Ok",
    Warning = "Warning",
    Error = "Error",
    Unsynced = "Unsynced",
}

/** Items list request with filtering, sorting, and paging */
export interface ApiItemListRequest {
    /** The id of the project of which the items are loaded. */
    ProjectId: number;
    /** The id of the folder of which the items are loaded. */
    FolderId: number;
    /** The item types to import as comma-separated list.
Possible values for item type are: Defect, Requirement, TestCase, TestScenario and Script. */
    ItemTypes: string | undefined;
    /** Contains filter and search information. */
    Search: string | undefined;
    /** Sprint filter:
Not specified - do not filter by sprint
0 - select items without psorint assigned only
1+ - select items for specified sprint only */
    SprintId: number | undefined;
    /** Comma-separated list of properties which should be used to order
the result list. ASC or DESC can be appended to indicate the sort order. Ascending sort
order is assumed by default. */
    OrderBy: string | undefined;
    /** Indicates whether items from sub folders should be included. */
    IncludeSubfolders: boolean;
    /** Indicates whether archieved items should be included. */
    IncludeArchived: boolean;
    /** Number of results to skip when the results are fetched.
Can be used for pagination. */
    StartAt: number;
    /** Maximum number of results which are fetched.
Can be used for pagination. */
    MaxResults: number;
    /** Indicates whether items should be filtered by status */
    IsFilteredByStatus: boolean;
    /** Whether or not to include the edit layout in each item */
    IncludeEditLayout: boolean;
}

/** Contains the reorderd agile priority. */
export interface ApiAgileReorderItemsResponse {
    /** Dictionary containing the item id and the new order of the item. */
    ReorderedPriority: { [key: string]: number; } | undefined;
}

/** Backlog items reorder request data */
export interface ApiAgileReorderItemsRequest {
    /** The ids of the items which will be reorderd. */
    Ids: number[] | undefined;
    /** The id of the item which is used as anchor of the sorting. */
    TargetId: number;
    /** Indicates whether items should be reorded before or after the target. */
    BeforeTarget: boolean;
}

/** Provides settings for Agile */
export interface ApiAgileSettings {
    /** Provides settings for backlog in Agile */
    Backlog: ApiAgileBacklog | undefined;
}

/** Provides settings for backlog in Agile */
export interface ApiAgileBacklog {
    /** Available statuses for requirements */
    RequirementStatuses: ApiAgileBacklogStatus[] | undefined;
    /** Available statuses for defects */
    DefectStatuses: ApiAgileBacklogStatus[] | undefined;
    /** Available statuses for test cases */
    TestCaseStatuses: ApiAgileBacklogStatus[] | undefined;
}

/** Provides status for items in Agile backlog */
export interface ApiAgileBacklogStatus {
    /** ID */
    Id: number;
    /** Name */
    Name: string | undefined;
    /** Provides information whether an item with this status 
should be hidden in the backlog or not */
    IsHidden: boolean;
}

/** Contains the values which are allowed for a batch update of the specified fields in the specified items. */
export interface ApiBatchAllowedValuesResponse {
    /** The items for which this response is valid. */
    Items: ApiItemIdentifier[] | undefined;
    /** Entries containing information for each requested field.  */
    Entries: ApiBatchAllowedValuesResponseEntry[] | undefined;
}

/** Contains the values which are allowed for a batch update of the specified field (in the specified items). */
export interface ApiBatchAllowedValuesResponseEntry {
    /** The field for which this response is valid. */
    Field: ApiField | undefined;
    /** The list with the values which are allowed for the specified field
in all of the specified items.
If the limit was specified in the request then this collection contains 
only up to given number fo values. The overall count can be always 
found in AllowedValuesTotalCount.  */
    AllowedValues: ApiFieldValue[] | undefined;
    /** Overall number of allowed values.  */
    AllowedValuesTotalCount: number;
    /** Indicates whether the other values, which are not included in the
AllowedValues, are allowed as long as they fit the field type. */
    AllowOtherValues: boolean;
}

/** A request for the values which are alllowed for a batch update of given field in the given items. */
export interface ApiBatchAllowedValuesRequest {
    /** The ids of the items for which the possible values should
be computed */
    ItemIds: number[] | undefined;
    /** The ids of the field for which the possible values should
be computed. */
    FieldIds: string[] | undefined;
    /** Limit on number of returned values per field (0 means unlimited).
If found more values than allowed limit then return only the part (not more than limit) and additionally 
count of all values.  */
    Limit: number;
}

/** Result of a REST API call that started long operation (asynchronous) to perform the actual job. When LongRunningTaskGuid is null this indicates a situation when REST API was able to process the task without starting asynchronous job. Then the actual result is returned in Result field. */
export interface ApiLongOperationOfBoolean {
    /** Id of the long running task. Can be used to query the progress (see GET /System/LongOperation/{guid}). 
If empty indicates the long operation has not been started and actual result is immediately available in the Result field.  */
    LongRunningTaskGuid: string | undefined;
    /** Filled only when LongRunningTaskGuid is not provided. Contains actual, immediate result of the call.  */
    Result: boolean;
}

/** Represent a request to modify a bunch of items (of the same type). Actual subclasses are used, depending on OperationType. */
export interface ApiItemsPatchRequest {
    OperationType: string;
}

/** Represents operation that moves a bunch of items to a different folder in the same project. */
export interface ApiItemsPatchRequestMoveInProject extends ApiItemsPatchRequest {
    /** Details of the move operation.  */
    MoveOperation: ApiItemLongOperationMoveInProject | undefined;
}

/** Represents request to move items to a given folder (in scope of the same project) */
export interface ApiItemLongOperationMoveInProject {
    /** Defines how to select items that should be moved.  */
    Criteria: ApiItemLongOperationDomain | undefined;
    /** Id of the target folder. Use zero for root folder.   */
    TargetFolderId: number;
}

/** Defines set of items to be processed. */
export interface ApiItemLongOperationDomain {
    /** Project where to look in. */
    ProjectId: number;
    Type: string;
}

/** Defines set of items matching a given filter. */
export interface ApiItemLongOperationDomainFilterBased extends ApiItemLongOperationDomain {
    /** Folder where to look in. Zero means root folder (combined with Recursive=true means all items in project).  */
    FolderId: number;
    /** If true items in subfolders are considered as well.  */
    Recursive: boolean;
    /** If provided then only items matching this filter would be processed.  */
    Filter: ApiFilterUpdate | undefined;
    /** If true the archived items (matching other criteria) are included as well.  */
    IncludeArchived: boolean;
}

/** Contains the new filter expression. */
export interface ApiFilterUpdate {
    /** The filter expression as JSON structure. */
    Expression: any[] | undefined;
}

/** Defines set of items matching a given list of ids. */
export interface ApiItemLongOperationDomainListBased extends ApiItemLongOperationDomain {
    /** List of ids of items */
    Items: number[] | undefined;
}

/** Represents operation that archived (or un-archives) a bunch of items. */
export interface ApiItemsPatchRequestArchive extends ApiItemsPatchRequest {
    /** Details of the archive operation.  */
    ArchiveOperation: ApiItemLongOperationArchive | undefined;
}

/** Represents request to batch archive (or un-archive) items. */
export interface ApiItemLongOperationArchive {
    /** Defines how to select items that should be archived/un-archived.  */
    Criteria: ApiItemLongOperationDomain | undefined;
    /** If true, the items will be marked as archived. 
If false, the items will be marked as non-archived.  */
    Archive: boolean;
}

/** Represents operation that deletes a bunch of items. */
export interface ApiItemsPatchRequestDelete extends ApiItemsPatchRequest {
    /** Details of the archive operation.  */
    DeleteOperation: ApiItemLongOperationDelete | undefined;
}

/** Represents request to batch delete items. */
export interface ApiItemLongOperationDelete {
    /** Defines how to select items that should be deleted.  */
    Criteria: ApiItemLongOperationDomain | undefined;
}

/** Represents operation that updates properties of some items. */
export interface ApiItemsPatchRequestUpdateProperties extends ApiItemsPatchRequest {
    /** Details of the update properties operation.  */
    UpdatePropertiesOperation: ApiItemLongOperationUpdateProperties | undefined;
}

/** Represents request to batch update items (update properties). */
export interface ApiItemLongOperationUpdateProperties {
    /** Defines how to select items that should be updated. */
    Criteria: ApiItemLongOperationDomain | undefined;
    /** List of updates to be applied.  */
    Updates: ApiBatchFieldUpdate[] | undefined;
}

/** Represents batch update of a single field to a given value. */
export interface ApiBatchFieldUpdate {
    /** The value to which the field will be changed. The exact type of the
value depends on the field of the type: 
- for regular fields (UpdateType=RegularField) it should be the same as defined in ApiFieldUpdate.Value
- for differential update of multi-selection fields (UpdateType=MultiChoiceFieldDifferential) it should be an array of ints (ids)
- for a new enclosure (UpdateType=NewEnclosure) it should be string containing plain text of the enclosure content. */
    Value: any | undefined;
    /** Performs update only if the field is currently empty.  */
    UpdateOnlyIfEmpty: boolean;
    UpdateType: string;
}

/** Represents update of a "regular" field i.e. field which is editable in the edit mask (see project meta). */
export interface ApiBatchFieldUpdateRegularField extends ApiBatchFieldUpdate {
    /** Id of the regular field to update. */
    FieldId: string | undefined;
}

/** Represents differential update of a multi-selection field. */
export interface ApiBatchFieldUpdateMultiChoiceFieldDifferential extends ApiBatchFieldUpdateRegularField {
    /** If true, the values of multi-selection field are added to the current set. 
If false, the values are removed.  */
    Add: boolean;
}

/** Represents a special type of update that creates a new defect enclosure. Valid only for defects. */
export interface ApiBatchFieldUpdateNewEnclosure extends ApiBatchFieldUpdate {
    /** Type of enclosure to be created.  */
    EnclosureType: ApiEnclosureType;
}

/** Identifies the type of enclosure. This enum has the following values:  - `Description` The enclosure is a description of the defect.  - `Note` The enclosure is a note.  - `ReplicationProcedure` The enclosure is a replication procedure which explains how to reproduce the defect.  - `Resolution` The enclosure explains how the defect has been resolved. */
export enum ApiEnclosureType {
    Description = "Description",
    Note = "Note",
    ReplicationProcedure = "ReplicationProcedure",
    Resolution = "Resolution",
}

/** Represents operation that copies a bunch of items to a different folder in the same project. */
export interface ApiItemsPatchRequestCopyInProject extends ApiItemsPatchRequest {
    /** Details of the copy operation.  */
    CopyOperation: ApiItemLongOperationCopyInProject | undefined;
}

/** Represents request to copy items to a given folder (in scope of the same project) */
export interface ApiItemLongOperationCopyInProject {
    /** Defines how to select items that should be moved.  */
    Criteria: ApiItemLongOperationDomain | undefined;
    /** Id of the target folder. Use zero for root folder.   */
    TargetFolderId: number;
}

/** Represents operation that copies a bunch of items to a different folder in the same project. */
export interface ApiItemsPatchRequestCopyToProject extends ApiItemsPatchRequest {
    /** Details of the copy operation.  */
    CopyOperation: ApiItemLongOperationCopyToProject | undefined;
}

/** Represents request to copy items to a given folder (in scope of the same project) */
export interface ApiItemLongOperationCopyToProject {
    /** Defines how to select items that should be moved.  */
    Criteria: ApiItemLongOperationDomain | undefined;
    /** Id of the target project. */
    TargetProjectId: number;
    /** Id of the target folder. Use zero for root folder.   */
    TargetFolderId: number;
}

/** Base class for models representing config elements. */
export interface ApiConfigElementBase {
    /** Path of the config element. Lowercase letters divided by dots are expected here 
e.g. "this.is.sample.path".  */
    DataPath: string | undefined;
    /** True if the config element is locked. 
The flag is considered only for non-user entries (project or global).  */
    Locked: boolean;
    /** Id of the project this config element belongs to. 
Can be null - then represents global configuration (system-wide).  */
    ProjectId: number | undefined;
    /** Id of the owner user. Can be null, then represents a default 
configuration (either project or global level).  */
    UserId: number | undefined;
}

/** Represents a config element (consisting of one or more entries), identified by given data path. */
export interface ApiConfigElement extends ApiConfigElementBase {
    /** Entries in this config element.  */
    Entries: ApiConfigElementEntry[] | undefined;
}

/** Represents single entry of a config element. */
export interface ApiConfigElementEntrySave {
    /** Label of the entry. */
    Label: string | undefined;
    /** Content of the entry. */
    Content: string | undefined;
}

/** Represents single entry of a config element. */
export interface ApiConfigElementEntry extends ApiConfigElementEntrySave {
    /** If of the entry. Can be used to e.g. delete the entry.  */
    Id: number;
}

/** Represents a config element (consisting of one or more entries), identified by given data path. */
export interface ApiConfigElementSave extends ApiConfigElementBase {
    /** Entries to be saved.  */
    Entries: ApiConfigElementEntrySave[] | undefined;
}

export interface ApiConfigElementPatchOperation {
    OperationType: string;
}

/** Represents details of a an operation that deletes sevral config element entries basing on given parameters. */
export interface ApiConfigElementPatchOperationDelete extends ApiConfigElementPatchOperation {
    /** Path of the considered config elements. Lowercase letters divided by dots are expected here 
e.g. "this.is.sample.path".  */
    DataPath: string | undefined;
    /** Id of the project where config element belongs to. 
Can be null - then represents global configurations (system-wide).  */
    ProjectId: number | undefined;
    /** Id of the owner user. Can be null, then represents a default 
configurations (either project or global level).  */
    UserId: number | undefined;
}

export interface HttpRequestMessage {
    Version: Version | undefined;
    Content: HttpContent | undefined;
    Method: HttpMethod | undefined;
    RequestUri: string | undefined;
    Headers: HttpRequestHeaders | undefined;
    Properties: { [key: string]: any; } | undefined;
}

export interface Version {
    Major: number;
    Minor: number;
    Build: number;
    Revision: number;
    MajorRevision: number;
    MinorRevision: number;
}

export interface HttpContent {
    Headers: HttpContentHeaders | undefined;
}

export interface Anonymous {
    Allow: string[] | undefined;
    ContentDisposition: ContentDispositionHeaderValue | undefined;
    ContentEncoding: string[] | undefined;
    ContentLanguage: string[] | undefined;
    ContentLength: number | undefined;
    ContentLocation: string | undefined;
    ContentMD5: string | undefined;
    ContentRange: ContentRangeHeaderValue | undefined;
    ContentType: MediaTypeHeaderValue | undefined;
    Expires: Date | undefined;
    LastModified: Date | undefined;
}

export interface HttpContentHeaders extends Anonymous {

    [key: string]: any;
}

export interface ContentDispositionHeaderValue {
    DispositionType: string | undefined;
    Parameters: NameValueHeaderValue[] | undefined;
    Name: string | undefined;
    FileName: string | undefined;
    FileNameStar: string | undefined;
    CreationDate: Date | undefined;
    ModificationDate: Date | undefined;
    ReadDate: Date | undefined;
    Size: number | undefined;
}

export interface NameValueHeaderValue {
    Name: string | undefined;
    Value: string | undefined;
}

export interface ContentRangeHeaderValue {
    Unit: string | undefined;
    From: number | undefined;
    To: number | undefined;
    Length: number | undefined;
    HasLength: boolean;
    HasRange: boolean;
}

export interface MediaTypeHeaderValue {
    CharSet: string | undefined;
    Parameters: NameValueHeaderValue[] | undefined;
    MediaType: string | undefined;
}

export interface KeyValuePairOfStringAndIEnumerableOfString {
    Key: string | undefined;
    Value: string[] | undefined;
}

export interface HttpMethod {
    Method: string | undefined;
}

export interface Anonymous2 {
    Accept: MediaTypeWithQualityHeaderValue[] | undefined;
    AcceptCharset: StringWithQualityHeaderValue[] | undefined;
    AcceptEncoding: StringWithQualityHeaderValue[] | undefined;
    AcceptLanguage: StringWithQualityHeaderValue[] | undefined;
    Authorization: AuthenticationHeaderValue | undefined;
    Expect: NameValueWithParametersHeaderValue[] | undefined;
    ExpectContinue: boolean | undefined;
    From: string | undefined;
    Host: string | undefined;
    IfMatch: EntityTagHeaderValue[] | undefined;
    IfModifiedSince: Date | undefined;
    IfNoneMatch: EntityTagHeaderValue[] | undefined;
    IfRange: RangeConditionHeaderValue | undefined;
    IfUnmodifiedSince: Date | undefined;
    MaxForwards: number | undefined;
    ProxyAuthorization: AuthenticationHeaderValue | undefined;
    Range: RangeHeaderValue | undefined;
    Referrer: string | undefined;
    TE: TransferCodingWithQualityHeaderValue[] | undefined;
    UserAgent: ProductInfoHeaderValue[] | undefined;
    CacheControl: CacheControlHeaderValue | undefined;
    Connection: string[] | undefined;
    ConnectionClose: boolean | undefined;
    Date: Date | undefined;
    Pragma: NameValueHeaderValue[] | undefined;
    Trailer: string[] | undefined;
    TransferEncoding: TransferCodingHeaderValue[] | undefined;
    TransferEncodingChunked: boolean | undefined;
    Upgrade: ProductHeaderValue[] | undefined;
    Via: ViaHeaderValue[] | undefined;
    Warning: WarningHeaderValue[] | undefined;
}

export interface HttpRequestHeaders extends Anonymous2 {

    [key: string]: any;
}

export interface MediaTypeWithQualityHeaderValue extends MediaTypeHeaderValue {
    Quality: number | undefined;
}

export interface StringWithQualityHeaderValue {
    Value: string | undefined;
    Quality: number | undefined;
}

export interface AuthenticationHeaderValue {
    Scheme: string | undefined;
    Parameter: string | undefined;
}

export interface NameValueWithParametersHeaderValue extends NameValueHeaderValue {
    Parameters: NameValueHeaderValue[] | undefined;
}

export interface EntityTagHeaderValue {
    Tag: string | undefined;
    IsWeak: boolean;
}

export interface RangeConditionHeaderValue {
    Date: Date | undefined;
    EntityTag: EntityTagHeaderValue | undefined;
}

export interface RangeHeaderValue {
    Unit: string | undefined;
    Ranges: RangeItemHeaderValue[] | undefined;
}

export interface RangeItemHeaderValue {
    From: number | undefined;
    To: number | undefined;
}

export interface TransferCodingHeaderValue {
    Value: string | undefined;
    Parameters: NameValueHeaderValue[] | undefined;
}

export interface TransferCodingWithQualityHeaderValue extends TransferCodingHeaderValue {
    Quality: number | undefined;
}

export interface ProductInfoHeaderValue {
    Product: ProductHeaderValue | undefined;
    Comment: string | undefined;
}

export interface ProductHeaderValue {
    Name: string | undefined;
    Version: string | undefined;
}

export interface CacheControlHeaderValue {
    NoCache: boolean;
    NoCacheHeaders: string[] | undefined;
    NoStore: boolean;
    MaxAge: string | undefined;
    SharedMaxAge: string | undefined;
    MaxStale: boolean;
    MaxStaleLimit: string | undefined;
    MinFresh: string | undefined;
    NoTransform: boolean;
    OnlyIfCached: boolean;
    Public: boolean;
    Private: boolean;
    PrivateHeaders: string[] | undefined;
    MustRevalidate: boolean;
    ProxyRevalidate: boolean;
    Extensions: NameValueHeaderValue[] | undefined;
}

export interface ViaHeaderValue {
    ProtocolName: string | undefined;
    ProtocolVersion: string | undefined;
    ReceivedBy: string | undefined;
    Comment: string | undefined;
}

export interface WarningHeaderValue {
    Code: number;
    Agent: string | undefined;
    Text: string | undefined;
    Date: Date | undefined;
}

export interface ApiDashboardNG {
    Id: number;
    Title: string | undefined;
    Size: ApiDashboardNGSize;
    Widgets: ApiDashboardNGWidget[] | undefined;
    ProjectShares: ApiDashboardNGShareProject[] | undefined;
    Owner: ApiUserInfo | undefined;
    /** True if the dashboard is marked as favourite by current user. 
Note: this property is ignored when saving. Please use specialized method instead
(to set/unset dashboard as favourite). */
    IsFavourite: boolean;
}

/** This enum has the following values:  - `Large`  - `Medium`  - `Small` */
export enum ApiDashboardNGSize {
    Small = "Small",
    Medium = "Medium",
    Large = "Large",
}

export interface ApiDashboardNGWidget {
    Id: number;
    Title: string | undefined;
    Type: string | undefined;
    Binding: ApiDashboardNGWidgetBinding | undefined;
    Model: ApiWidgetModel | undefined;
    Data: ApiWidgetData | undefined;
}

/** Specifies the binding (project and folder) as well as recursive flag of a widget. */
export interface ApiDashboardNGWidgetBinding {
    /** The id of the project. 
This field is required when saving.  */
    ProjectId: number;
    /** The id of the folder or zero (root folder).
This field is required when saving.  */
    FolderId: number;
    /** Specifies whether data should be loaded from the all subfolder or only from given folder. 
This field is required when saving.  */
    Recursive: boolean;
    /** The name of the project.
This field is ignored when saving.  */
    ProjectName: string | undefined;
    /** The human readable path as text. The path consists of the project name and
the folder names separated by slashes.
This field is ignored when saving. 
WARNING! This field can be null in case the folder has been deleted.  */
    Text: string | undefined;
    /** Provides a list of folders with the complete path. The order of items corresponds to the path. The project itself is not contained.
This field is ignored when saving. 
WARNING! This field can be null in case the folder has been deleted.  */
    Path: ApiProjectFolder[] | undefined;
}

/** Base class for all widget models. */
export interface ApiWidgetModel {
    WidgetType: string;
}

/** Represents the model of the chart widget */
export interface ApiChartWidgetModel extends ApiWidgetModel {
    /** Chart type */
    ChartType: ApiChartType;
    /** Textual representation of the filter string (included in ChartWidgetDataSpecification) */
    FilterDisplay: string | undefined;
    /** If true the chart should show a legend. */
    ShowLegend: boolean;
    /** If true the chart should show totals. */
    ShowTotals: boolean;
    /** If true the chart should show percentages. */
    ShowPercentages: boolean;
    /** KPI specifications (optional) */
    KPI: ApiChartWidgetKPIEntry[] | undefined;
    /** Data specification for the chart widget */
    ChartWidgetDataSpecification: ApiChartWidgetDataSpecification | undefined;
}

/** This enum has the following values:  - `Bar`  - `BarSideBySide`  - `BarStacked`  - `Pie`  - `Table` */
export enum ApiChartType {
    Pie = "Pie",
    Bar = "Bar",
    BarSideBySide = "BarSideBySide",
    BarStacked = "BarStacked",
    Table = "Table",
}

/** KPI for a chart widget */
export interface ApiChartWidgetKPIEntry {
    /** The type of condition which should be used for the KPI */
    ConditionType: ApiChartWidgetKPICondition;
    /** If not-null the value is used to select only some of the grouped values. */
    Selector: string | undefined;
    /** Threshold (count) to be compared using the given ConditionType */
    Threshold: number;
    /** Color to be used (optional). HEX RGB string e.g. "ffaabc" */
    Color: string | undefined;
}

/** KPI condition type This enum has the following values:  - `Equal`  - `Greater`  - `GreaterEqual`  - `Less`  - `LessEqual`  - `NotEqual` */
export enum ApiChartWidgetKPICondition {
    Equal = "Equal",
    NotEqual = "NotEqual",
    Less = "Less",
    LessEqual = "LessEqual",
    Greater = "Greater",
    GreaterEqual = "GreaterEqual",
}

/** Data specification for the chart widget */
export interface ApiChartWidgetDataSpecification {
    /** Number of dimensions. Allowed values are 1 or 2  */
    Dimensions: number;
    /** Type of item to consider.  */
    ItemType: ApiItemType;
    /** Title of the field used to aggregate on X-axis (used only if the number of dimensions is 2). */
    XAxisPropertyTitle: string | undefined;
    /** X-axis scale for datetime fields (used only if number od dimensions is 2). */
    XAxisDateTimeScale: ApiChartWidgetDateTimeScale;
    /** If true and field used for aggregation on X-axis is a multi-select field (dictionary or user) 
then data is aggregated for each single element of the multi-select list, not for subsets. 
(used only if number od dimensions is 2) */
    XAxisSeparateMultiList: boolean;
    /** Title of the field used to group by. */
    GroupByPropertyTitle: string | undefined;
    /** Group-by scale for datetime fields (used only if number od dimensions is 2). */
    GroupByDateTimeScale: ApiChartWidgetDateTimeScale;
    /** If true and field used for aggregation on Group-By is a multi-select field (dictionary or user) 
then data is aggregated for each single element of the multi-select list, not for subsets.  */
    GroupBySeparateMultiList: boolean;
    /** Filter expression to be used for filtering data for this chart */
    FilterExpression: any | undefined;
    /** If true then sorting on X-axis should be reversed  (used only if number od dimensions is 2) */
    ReverseSortXAxis: boolean;
    /** If true then sorting on group-by should be reversed */
    ReverseSortGroupBy: boolean;
}

/** This enum has the following values:  - `CalendarWeek` Aggregate by calendar week  - `Day` Aggregate by day (default)  - `Month` Aggregate by month */
export enum ApiChartWidgetDateTimeScale {
    Day = "Day",
    CalendarWeek = "CalendarWeek",
    Month = "Month",
}

/** Represents the model of the HTML content widget */
export interface ApiHtmlContentWidgetModel extends ApiWidgetModel {
    /** Data specification for the HTML content widget */
    HtmlContentWidgetDataSpecification: ApiHtmlContentWidgetDataSpecification | undefined;
}

/** The data specification for an HTML content widget */
export interface ApiHtmlContentWidgetDataSpecification {
    /** The URL of the HTML content which should be displayed */
    Url: string | undefined;
}

/** Represents the model of the item-list widget */
export interface ApiItemListWidgetModel extends ApiWidgetModel {
    /** Columns to be presented in the grid. */
    Columns: string[] | undefined;
    /** Textual representation of the filter string which is included in
ItemListWidgetDataSpecification. */
    FilterDisplay: string | undefined;
    /** Data specification for the item list widget. Contains all parameters required to fetch data (from server) for this item list.  */
    ItemListWidgetDataSpecification: ApiItemListWidgetDataSpecification | undefined;
}

/** The data specification for an item list widget */
export interface ApiItemListWidgetDataSpecification {
    /** Item type */
    ItemType: ApiItemType;
    /** Filter expression to be used. */
    FilterExpression: any | undefined;
    /** Number of elements to skip (used for pagination) */
    FirstResults: number;
    /** Number of elements to take (used for pagination) */
    MaxResults: number;
    /** Language ('en' or 'de'), required for generating values of some fields
that depend on the current language (e.g. last execution status).  */
    Culture: string | undefined;
    /** The sorting which should be applied to the item list */
    SortColumns: ApiItemListWidgetSorting[] | undefined;
}

/** Represent sorting in item list widget */
export interface ApiItemListWidgetSorting {
    /** Title of the field to sort by */
    FieldTitle: string | undefined;
    /** Sorting direction - if true then ascending, descending otherwise.  */
    Ascending: boolean;
}

/** Base class for all widget data classes. */
export interface ApiWidgetData {
    DataType: string;
}

/** The data for a chart widget */
export interface ApiChartWidgetData extends ApiWidgetData {
    /** The status indicates whether there was any issue with fetching
the chart data */
    Status: ApiChartWidgetDataStatus;
    /** The data points for a one-dimensional chart */
    OneDimensionalData: ApiChartWidgetDataOneDimensionalElement[] | undefined;
    /** The data points for a two-dimensional chart */
    TwoDimensionalData: ApiChartWidgetDataTwoDimensionalElement[] | undefined;
    /** The metadata of the field by which the data has been grouped */
    GroupByFieldMeta: ApiFieldMeta | undefined;
    /** The metadata of the field which has been used for X-axis data
of a two-dimensional chart */
    XAxisFieldMeta: ApiFieldMeta | undefined;
}

/** This enum has the following values:  - `InvalidFilter`  - `InvalidSpecification`  - `NoPermission`  - `OK` */
export enum ApiChartWidgetDataStatus {
    OK = "OK",
    NoPermission = "NoPermission",
    InvalidFilter = "InvalidFilter",
    InvalidSpecification = "InvalidSpecification",
}

/** A data point for a one-dimensional chart */
export interface ApiChartWidgetDataOneDimensionalElement {
    /** The value by which the data was grouped together */
    GroupedValue: ApiFieldValue | undefined;
    /** The number of elements which have this value */
    NumberOfElements: number;
}

/** A data point for a two-dimensional chart */
export interface ApiChartWidgetDataTwoDimensionalElement {
    /** The value by which the data was grouped together on the Y-axis */
    GroupedValue: ApiFieldValue | undefined;
    /** The value by which the data was grouped together on the X-axis */
    XAxisValue: ApiFieldValue | undefined;
    /** The number of elements which have these values */
    NumberOfElements: number;
}

/** Contains the meta-information of a specific field. */
export interface ApiFieldMeta {
    /** The id of the field. The field id is identical to the internal property name. Therefore, it is
only unique in scope of the same project and item type. */
    Id: string | undefined;
    /** Title of this field, as visible in the UI. Can be customized by in project configuration. */
    Title: string | undefined;
    /** True if this field is a custom field. */
    IsCustom: boolean;
    /** True if the field can be used as GroupBy or XAxis property on a chart (dashbaord). */
    IsGroupableInCharts: boolean;
    /** Indicates whether this field supports field rules. */
    SupportsFieldRules: boolean;
    /** Contains a list of all filter operators which are supported
for this field. */
    SupportedFilterOperations: string[] | undefined;
    /** Indicates whether it is possible to filter by this field e.g.
in item lists. */
    IsFilterable: boolean;
    /** Indicates whether it is possible to sort by this field e.g.
in item lists. */
    IsSortable: boolean;
    /** Indicates whether it is possible to affect this field by field rules. */
    IsAffectable: boolean;
    /** Indicates whether it is possible to group by this field e.g.
in item lists. */
    IsGroupable: boolean;
    /** Indicates whether the field is currently enabled or disabled. */
    IsActive: boolean;
    /** Indicates whether the field supports batch updates in general. Depending on the
concrete items and the configured workflow, it might still not be possible to change
a value even if the field supports batch updates in general. */
    SupportsBatchUpdate: boolean;
    /** EditMeta of the current field. */
    EditMeta: ApiFieldEditMeta | undefined;
    FieldType: string;
}

/** Contains the meta-information of a date time field. */
export interface ApiFieldMetaDateTime extends ApiFieldMeta {
    /** Field mask  */
    FieldMask: string | undefined;
}

/** Contains the meta-information of a decimal field. */
export interface ApiFieldMetaDecimal extends ApiFieldMeta {
    /** Field mask  */
    FieldMask: string | undefined;
    /** Minimum allowed field value (if defined) */
    Min: number | undefined;
    /** Maximum allowed field value (if defined) */
    Max: number | undefined;
}

/** Contains the meta-information of a (single selection) dictionary field. */
export interface ApiFieldMetaDictionary extends ApiFieldMeta {
    /** Dictionary entries. */
    Entries: ApiFieldMetaDictionaryEntry[] | undefined;
    /** Indicates if the field value set is shared. */
    IsShared: boolean;
}

/** Contains the meta-information of a dictionary entry. */
export interface ApiFieldMetaDictionaryEntry {
    /** Id of the entry. This value is stored on actual item that references the dictionary entry.
(entries can be safely renamed, as their ids do not change).  */
    Id: number;
    /** Name of the dictionary entry. This is the value visible in the UI.  */
    Name: string | undefined;
    /** Indicates whether this entry should be cosnidered as default for this dictionary.  */
    IsDefault: boolean;
    /** Indicates whether this entry was deleted. 
Deleted entries are not available for selection, but still can seen on old items (edited before teh entry has been deleted). */
    IsDeleted: boolean;
}

/** Contains the meta-information of a (multi selection) dictionary field. */
export interface ApiFieldMetaDictionaryMultiChoice extends ApiFieldMeta {
    /** Dictionary entries. */
    Entries: ApiFieldMetaDictionaryEntry[] | undefined;
    /** Indicates if the field value set is shared. */
    IsShared: boolean;
}

export interface ApiFieldMetaExecutionHistory extends ApiFieldMeta {
}

/** Contains the meta-information of a flag field. */
export interface ApiFieldMetaFlag extends ApiFieldMeta {
}

/** Contains the meta information of an Id field */
export interface ApiFieldMetaId extends ApiFieldMeta {
}

/** Contains the meta-information of a sprint field. */
export interface ApiFieldMetaSprint extends ApiFieldMeta {
}

/** Contains the meta-information of a string field. */
export interface ApiFieldMetaString extends ApiFieldMeta {
    /** Field mask  */
    FieldMask: string | undefined;
    /** Maximum field length  */
    Length: number;
}

/** Contains the meta-information of a auto-complete string field. */
export interface ApiFieldMetaStringAutoComplete extends ApiFieldMetaString {
}

export interface ApiFieldMetaTestJobStatistics extends ApiFieldMeta {
}

export interface ApiFieldMetaTestScenarios extends ApiFieldMeta {
}

/** Contains the meta information of a timespan field */
export interface ApiFieldMetaTimeSpan extends ApiFieldMeta {
}

/** Contains the meta-information of a (single selection) user field. */
export interface ApiFieldMetaUser extends ApiFieldMeta {
}

/** Contains the meta-information of a (multi selection) user field. */
export interface ApiFieldMetaUserMultiChoice extends ApiFieldMeta {
}

/** Contains the meta-information of a list of strings. */
export interface ApiFieldMetaStringList extends ApiFieldMeta {
}

/** The data for an HTML content widget */
export interface ApiHtmlContentWidgetData extends ApiWidgetData {
}

/** The data for an item list widget */
export interface ApiItemListWidgetData extends ApiWidgetData {
    /** The total number of items which match the filter in the
widget defintion. */
    Count: number | undefined;
    /** The actual items. Only a subset of the matching items is
included in the response depending on the pagination settings
in the widget's data specification. */
    Items: ApiItemInfo[] | undefined;
}

/** Represents fact of sharing a dashboard with members of a given project (or all projects), optionally with a role. Please see below for possible combination: a) no project, no role: all users b) project, no role: all members of the project c) no project, role: all users having this role in any of the projects d) project, role: all members of the project in given role */
export interface ApiDashboardNGShareProject {
    /** If set, then only members of this project can see the dashboard. 
If not set (null) then all users can see the dashboard. 
See global description for detailed meaning in different combinations of Project and Role. 
When saving the Id field is considered only (or null). */
    Project: ApiProjectIdName | undefined;
    /** If set, then only users having this role (in given project) are considered. 
See global description for detailed meaning in different combinations of Project and Role. 
When saving the Id field is considered only (or null).  */
    Role: ApiRoleIdName | undefined;
}

/** Holds the id and the name of a project. */
export interface ApiProjectIdName {
    /** The id of the project. */
    Id: number;
    /** The name of the project. */
    Name: string | undefined;
}

/** Holds the id and the name of a role. */
export interface ApiRoleIdName {
    /** The id of the role. */
    Id: number;
    /** The name of the role. */
    Name: string | undefined;
}

export interface ApiDashboardNGReorderWidgets {
    /** The id of the widget. */
    WidgetId: number;
    /** The new position of the widget. */
    NewPosition: number;
}

export interface ApiDefect extends ApiItem {
    /** Contains all defect enclosures */
    Enclosures: ApiEnclosure[] | undefined;
}

/** An enclosure of a defect. */
export interface ApiEnclosure {
    /** The id of the enclosure. */
    Id: number;
    /** The type of the enclosure. */
    Type: ApiEnclosureType;
    /** The date when the enclosure has been created. */
    CreationDate: Date;
    /** The content of the enclosure. */
    Content: ApiRichText | undefined;
    /** The owner of the enclosure. */
    Owner: ApiUserInfo | undefined;
    /** The permissions of the enclosure. */
    Permissions: ApiEnclosurePermissions | undefined;
}

/** Contains some rich text. The rich text is provided in several different formats. When sending rich text to the server, the rich text must be provided in exactly one format. */
export interface ApiRichText {
    /** Contains the description rendered as HTML. Images are included with standard image tags.
When sending HTML to server, all images must be uploaded to the server first by posting
to /api/Image. The returned URLs can then be included into the HTML. */
    Html: string | undefined;
    /** Indicates that rich text features are used which are not supported by the REST API,
e.g. comments. Information from the rich text might be missing in the HTML and
plain text provided by the REST API. The rich text cannot be modified via the REST API. */
    IncompatibleRichTextFeatures: boolean;
    /** Contains the description as plain text. The plain text does not contain any formatting or images. */
    PlainText: string | undefined;
}

/** Represents permissions of a Enclosure. */
export interface ApiEnclosurePermissions {
    /** Indicates whether user is able to delete enclosure. */
    CanDelete: ApiPermissionResult;
    /** Indicates whether user is able to edit enclosure. */
    CanEdit: ApiPermissionResult;
}

/** Specifies the changes to perform on a specific item. */
export interface ApiItemUpdate {
    /** The list of updates to perform on the different fields of the item. */
    Details: ApiFieldUpdate[] | undefined;
    /** Contains the changes which should be applied to the attachments of the item. */
    Attachments: ApiAttachments | undefined;
}

/** Specifies the changes to perform on a specific item including its enclosures. */
export interface ApiItemUpdateWithEnclosures extends ApiItemUpdate {
    /** Contains all the modifications which should be applied to
the enclosures. */
    Enclosures: ApiEnclosuresUpdate | undefined;
}

/** Contains a list of different changes which should be applied to the enclosure collection. */
export interface ApiEnclosuresUpdate {
    /** A list with the new enclosures which should be added. */
    Added: ApiEnclosureUpdate[] | undefined;
    /** A list with enclosures which should be updated. */
    Modified: ApiEnclosureUpdateWithId[] | undefined;
    /** A list with the ids of the enclosures which should be removed. */
    Removed: number[] | undefined;
}

/** Specifies the changes to perform on a specific enclosure. */
export interface ApiEnclosureUpdate {
    /** The new type of the enclosure. */
    Type: ApiEnclosureType;
    /** The new description of the enclosure. You must specify exactly one type
of description. */
    Content: ApiRichText | undefined;
}

/** Specifies the changes to perform on a specific enclosure and also the id of the enclosure to modify which is useful when sending a list of updates. */
export interface ApiEnclosureUpdateWithId extends ApiEnclosureUpdate {
    /** The id of the enclosure to update. */
    Id: number;
}

/** Specifies the update to perform on a specific field. */
export interface ApiFieldUpdate {
    /** The id of the field to update. */
    FieldId: string | undefined;
    /** The value to which the field will be changed. The exact type of the
value depends on the field of the type:

    String: the value as string
    Decimal: the value as number
    Datetime: a string defining the date and time in the following format: yyyy-MM-ddTHH:mm:ssK or 
    yyyy-MM-ddTHH:mm:ss.fffK. The K represents optional time zone information (Z for UTC or a time zone offset).
    E.g.: 2018-03-15T21:42:42, 2018-03-15T21:42:42.123, 2018-03-15T21:42:42.123Z, 2018-03-15T21:42:42.123+02:00.
    Dictionary: the id of the field value as number (or null for empty)
    MultiChoiceDictionary: a list of numbers where each number is a field value id. E.g.: [1,2] (or [] for empty)
    User: the user id as number (or null for empty)
    MultiChoiceUser: a list of numbers where each number is a user id. E.g.: [1,2] (or [] for empty)
    TimeSpan: the value of the time span as number e.g.: {"FieldId": {"Value": 4,"Unit": "Hour"}}.
    Sprint: the id of the sprint as number (or null for empty)
    Text: ApiRichText object, e.g.: {{  "html": "sometext",  "incompatibleRichTextFeatures": false}} */
    Value: any | undefined;
}

/** Contains all changes to the attachments of an item. */
export interface ApiAttachments {
    /** The list of attachments to add to the item. */
    Added: ApiAttachmentNew[] | undefined;
    /** The list of ids of the attachments which should be removed from
the item. */
    Removed: number[] | undefined;
}

/** An attachment which should be created as part of a list of attachment changes for a certain item. The file attach must have been uploaded to /File beforehand. */
export interface ApiAttachmentNew {
    /** The GUID which uniquely identifies the uploaded file.
The file should be uploaded to the endpoint
[UploadFile](#operation/File_UploadFile)
or
[UploadFileWithGuid](#operation/File_UploadFileWithGuid)
first. */
    Guid: string;
}

/** Contains the necessary data to create a new item. */
export interface ApiItemNew {
    /** The location where the new item should be created. You must
provide either project id and folder id or the path. When all three
are provided, they must match. */
    Location: ApiItemLocationUpdate | undefined;
    /** The list values which should be set when creating the item. */
    Details: ApiFieldUpdate[] | undefined;
    /** The list of attachments which should be added to the new item. */
    Attachments: ApiAttachmentNew[] | undefined;
}

/** Contains the necessary data to create a new item including its enclosures. */
export interface ApiItemNewWithEnclosures extends ApiItemNew {
    /** Contains all the enclosures that should be created together with the item. */
    Enclosures: ApiEnclosureUpdate[] | undefined;
}

export interface ApiItemLocationUpdate {
    /** The id of the project */
    ProjectId: number | undefined;
    /** The id of the folder */
    FolderId: number | undefined;
}

/** Edit status information for an item. */
export interface ApiItemEditStatus {
    /** This field provides information about the item version. */
    ItemVersion: ApiItemVersion | undefined;
    /** This field provides information about the item editibale status and if item is locked, about a lock user. */
    EditableInfo: ApiEditableInfo | undefined;
}

/** Contains the metadata which is necessary for creating a new item. */
export interface ApiItemCreateMeta {
    /** Location for which the create metadata is valid. */
    Location: ApiItemLocation | undefined;
    /** Contains all available fields together with their metadata. */
    Fields: ApiField[] | undefined;
    /** Contains information about fields layout (i.e. how to layout fields in the edit mask). */
    EditLayout: ApiEditLayout | undefined;
    /** Specifies permissions of current user in regard to operations available
for this new item. */
    Permissions: ApiItemPermissions | undefined;
}

/** Contains the metadata of fields of an item being edited. */
export interface ApiItemEditMeta {
    /** Contains all available fields together with their metadata. */
    Fields: ApiField[] | undefined;
    /** Contains information about fields layout (i.e. how to layout fields in the edit mask). */
    EditLayout: ApiEditLayout | undefined;
}

/** Meta information for an attachments. E.g. file name and size. This structure does not contain the content of the attachment which must be requested separately. */
export interface ApiAttachmentInfo {
    /** The id of the attachment. */
    Id: number;
    /** The full file name of the attachment including the file extension. */
    Filename: string | undefined;
    /** The file extension of the attachment. */
    FileExtension: string | undefined;
    /** The date when attachment was created. This can be either the server time when
the attachment was saved or the time when file was last modified in the file system
before being uploaded to the server. */
    FileDate: Date;
    /** The size of the attachment in bytes. */
    Size: number;
    /** The url where the content of the attachment is located. For this url,
the API will force browsers to display the content by setting the
content-disposition header to inline. */
    ViewUrl: string | undefined;
    /** The url where the content of the attachment is located. For this url,
the API will force browsers to download the file by setting the
content-disposition header to attachment. */
    DownloadUrl: string | undefined;
}

/** This result is returned as part of a redirection response. Most clients should automatically follow the redirect and will never see this response. */
export interface ApiRedirectResult {
    /** A human-readable info message */
    Message: string;
    /** The URL to which the request is redirected. */
    Url: string;
}

/** Represents a file upload to the REST API. You do not need to provide a JSON structure. Instead just send the content of the file you would like to upload. The content can be sent directly as the request body or inside a multipart form data. */
export interface ApiUploadedFile {
    /** The content of the uploaded file. The content can be sent either directly
as the request body or in a multipart form . */
    Content: string | undefined;
    /** When the file is uploaded using a multipart form, the file name is taken from
the ContentDisposition header. Otherwise, the name is null. The name must include the file extension otherwise the request will be rejected. */
    Name: string | undefined;
}

/** Contains the information necessary to lock an item for exclusive editing. */
export interface ApiLockNew {
    /** The version of the item to lock which the client currently knows. */
    Version: number;
}

/** Contains all changes which were done to an item in one operation together with information on when and by whon the item has been changed. When no changes of a given type occurred, the corresponding field in this response will be missing. */
export interface ApiHistoryEntry {
    /** The id of the history entry */
    Id: number;
    /** The date and time when the changes were performed */
    TimeStamp: Date;
    /** Information on the person who performed the changes.
The user info might only contain the full name
and user image. */
    Editor: ApiUserInfo | undefined;
    /** The list of changes to the fields */
    Fields: ApiHistoryFieldChanged[] | undefined;
    /** Information on the creation of the item */
    Created: ApiHistoryItemCreated | undefined;
    /** Contains the information that the item has been moved */
    Moved: ApiHistoryItemMoved | undefined;
    /** Contains the changes to the attachments */
    Attachments: ApiHistoryAttachments | undefined;
    /** Contains the changes to the list of subscribed users */
    UserCCs: ApiHistoryUserCCs | undefined;
    /** Contains the changes to a dependency */
    DependencyChanged: ApiHistoryDependencyChanged | undefined;
    /** Contains the changes to a specific post */
    PostChanged: ApiHistoryPostChanged | undefined;
    /** Contains information on the sync event that has been logged
for this item. Connectors to third-party systems log sync errors
and the resolving of sync errors here. */
    SyncEvent: ApiHistorySyncEvent | undefined;
    /** Contains the information information that the item has been
migrated from a third-party system to aqua. */
    Migrated: ApiHistoryItemMigrated | undefined;
}

/** Contains all changes which were done to a defect in one operation together with information on when and by whom the defect has been changed. When no changes of a given type occurred, the corresponding field in this response will be missing. */
export interface ApiHistoryEntryDefect extends ApiHistoryEntry {
    /** A list with all changes to the enclosures of this defect. */
    Enclosures: ApiHistoryEnclosureChanged[] | undefined;
}

/** Contains the changes to a single enclosure. */
export interface ApiHistoryEnclosureChanged {
    /** The id of the changed enclosure. Might be null, if
the id has not been tracked. */
    Id: number | undefined;
    /** The type of the changed enclosure. Might be null, if the
enclosure type has not been tracked. */
    EnclosureType: ApiEnclosureType | undefined;
    /** The type of change to the enclosure. */
    ChangeType: ApiHistoryEnclosureChangeType;
    /** The content of the enclosure before the change. */
    OldContent: ApiRichText | undefined;
    /** The content of the enclosure after the change. */
    NewContent: ApiRichText | undefined;
}

/** Identifies the type of change to a certain enclosure. This enum has the following values:  - `Added` The enclosure has been added.  - `Deleted` The enclosure has been deleted.  - `Modified` The enclosure has been modified. */
export enum ApiHistoryEnclosureChangeType {
    Added = "Added",
    Modified = "Modified",
    Deleted = "Deleted",
}

/** A certain field of an item has changed */
export interface ApiHistoryFieldChanged {
    /** The id of the changed field */
    FieldId: string | undefined;
    /** The title of the changed field */
    FieldTitle: string | undefined;
    /** The kind of change which occurred to the field */
    ChangeType: ApiHistoryFieldChangeType;
    /** The old value before the change as human readable object.
If the flag IsRichText is true the value is of type ApiRichText otherwise of type string.
ApiRichText contains following information:
- string Html: information rendered as HTML.
- bool IncompatibleRichTextFeatures: Indicates that rich text features are used which are not supported by the REST API.
- string PlainText: information as plaintext. */
    OldValue: any | undefined;
    /** The new value after the change as human readable object. 
If the flag IsRichText is true the value is of type ApiRichText otherwise of type string.
ApiRichText contains following information:
- string Html: information rendered as HTML.
- bool IncompatibleRichTextFeatures: Indicates that rich text features are used which are not supported by the REST API.
- string PlainText: information as plaintext. */
    NewValue: any | undefined;
    /** If true indicates that the values are of type ApiRichText, otherwise of type string. */
    IsRichText: boolean;
}

/** Identifies the type of change to a certain field This enum has the following values:  - `Added` The field was changed from empty to a certain value  - `Changed` The field was changed from one value to another  - `ChangedNoDiff` The field was changed but the value before and after the change have not been recorded  - `Removed` The field was changed from a value to empty */
export enum ApiHistoryFieldChangeType {
    Added = "Added",
    Changed = "Changed",
    Removed = "Removed",
    ChangedNoDiff = "ChangedNoDiff",
}

/** Information on the creation of the item. */
export interface ApiHistoryItemCreated {
    /** How the item was created */
    CreationMode: ApiHistoryCreationMode;
    /** The source item based on which the current item has been
created. When the item has been created as an empty item,
the source contains the item itself. The name specified here
is the name the item was given at its creation. */
    Source: ApiItemInfo | undefined;
}

/** Identifies how the item was created This enum has the following values:  - `CopyOfItem` The item was created as a copy of an existing item  - `EmptyItem` The item was created as an empty item  - `NewVersionOfItem` The item was created as a new version of an existing item */
export enum ApiHistoryCreationMode {
    EmptyItem = "EmptyItem",
    CopyOfItem = "CopyOfItem",
    NewVersionOfItem = "NewVersionOfItem",
}

export interface ApiHistoryItemMoved {
    /** The old path of the item before it was moved */
    OldPath: string | undefined;
    /** The new path of the item after it was moved */
    NewPath: string | undefined;
}

/** The list of changes to the attachments of an item. */
export interface ApiHistoryAttachments {
    /** The list of names of the attachments which were added
to the item */
    Added: string[] | undefined;
    /** The list of names of the attachments which were removed
from the item */
    Removed: string[] | undefined;
}

/** Contains the changes to the list of users which have subscribed to the item and are notified about any changes. */
export interface ApiHistoryUserCCs {
    /** The list of full names of users which were added to the list
of subscribers. */
    Added: string[] | undefined;
    /** The list of full names of users which were removed from the
list of subscribers. */
    Removed: string[] | undefined;
}

/** Contains information on the dependency which changed. */
export interface ApiHistoryDependencyChanged {
    /** The type of change which occurred to the dependency */
    ChangeType: ApiHistoryDependencyChangeType;
    /** The name of the current item at the time when the dependency
has been modified */
    ItemName: string | undefined;
    /** The name of the other item which is part of this dependency */
    OtherItemName: string | undefined;
    /** The type of the dependency after the change */
    DependencyType: ApiDependencyType | undefined;
    /** The type of the dependency before the change */
    OldDependencyType: ApiDependencyType | undefined;
}

/** Indicates the type of change which occurred to a certain dependency This enum has the following values:  - `Added` The dependency has been added  - `Removed` The depencency has been removed  - `TypeChanged` The type of the dependency has been changed */
export enum ApiHistoryDependencyChangeType {
    Added = "Added",
    TypeChanged = "TypeChanged",
    Removed = "Removed",
}

/** Identifies the type of dependency. This enum has the following values:  - `AlternativeTo` This item is an alternative to the other item  - `ConflictsWith` This item conflicts with the other item.  - `DependsOn` This item depends on the other item. This is the reverse of HasDependentItem.  - `Details` This item details the other item. This is the reverse of IsDetailedBy.  - `Duplicates` This item duplicates the other item.  - `HasDependentItem` The other item depends on this item. This is the reverse of DependsOn.  - `HasNewerVersion` This item has a new version which is the other item. This is the reverse of IsNewerVersionOf.  - `HasPrecondition` This item has the other item as a precondition. This is the reverse of IsPreconditionOf.  - `IsCopyOf` This item is a copy of the other item. This is the reverse of WasCopiedBy.  - `IsDetailedBy` This item is detailed by the other item meaning that the other item contains additional details for this item. This is the reverse of Details.  - `IsNestedIn` This item (test case) is nested in another item (another test case). This is the reverse of Nests.  - `IsNewerVersionOf` This item is a newer version of the other item. This is the reverse of HasNewerVersion.  - `IsPreconditionOf` This item is a precondition of the other item. This is the reverse of HasPrecondition.  - `IsUtilityScriptOf` This item is a utility script of the other item. This is the reverse of UsesUtilityScript.  - `IsVerifiedBy` This item is verified by the other item. This is the reverse of Verifies.  - `Nests` This item (test case) nestst the other item (test case). This is the reverse of IsNestedIn.  - `ReferencesTestCaseTestData` This item (test case) references test data from the other item (test case). This is the reverse of SharesTestDataWith.  - `RelatedTo` This item is related to the other item.  - `SharesTestDataWith` This item (test case) shares its test data with another item (another test case). This is the reverse of ReferencesTestCaseTestData.  - `UsesUtilityScript` This item uses the other item as a utility script. This is the reverse of IsUtilityScriptOf.  - `Verifies` This item verifies the other item. This is the reverse of IsVerifiedBy.  - `WasCopiedTo` This item was copied to the other item. This is the reverse of IsCopyOf. */
export enum ApiDependencyType {
    RelatedTo = "RelatedTo",
    Duplicates = "Duplicates",
    Details = "Details",
    IsDetailedBy = "IsDetailedBy",
    IsNewerVersionOf = "IsNewerVersionOf",
    HasNewerVersion = "HasNewerVersion",
    DependsOn = "DependsOn",
    HasDependentItem = "HasDependentItem",
    ConflictsWith = "ConflictsWith",
    AlternativeTo = "AlternativeTo",
    Verifies = "Verifies",
    IsVerifiedBy = "IsVerifiedBy",
    IsPreconditionOf = "IsPreconditionOf",
    HasPrecondition = "HasPrecondition",
    IsCopyOf = "IsCopyOf",
    WasCopiedTo = "WasCopiedTo",
    IsUtilityScriptOf = "IsUtilityScriptOf",
    UsesUtilityScript = "UsesUtilityScript",
    Nests = "Nests",
    IsNestedIn = "IsNestedIn",
    ReferencesTestCaseTestData = "ReferencesTestCaseTestData",
    SharesTestDataWith = "SharesTestDataWith",
}

/** Contains the changes to a certain post. */
export interface ApiHistoryPostChanged {
    /** The kind of change which occurred to the post. */
    ChangeType: ApiHistoryPostChangeType;
    /** The index of this post in the list posts of the current item. */
    Number: number;
    /** The list of full names of the users which are mentioned in the post
after the change. */
    MentionedUsers: string[] | undefined;
    /** Truncated version of the content as plain text.  */
    ContentTruncated: string | undefined;
}

/** Identifies the type of change to a certain post This enum has the following values:  - `Added` The post has been added.  - `Modified` The post has been modified.  - `Removed` The post has been deleted. */
export enum ApiHistoryPostChangeType {
    Added = "Added",
    Modified = "Modified",
    Removed = "Removed",
}

/** Contains information about the sync event which has been logged in the item's history. Connectors which synchronize items in aqua with third-party systems log their errors and the resolving of the errors in the history to make them visible to the user. */
export interface ApiHistorySyncEvent {
    /** Indicates the type of sync event which occurred. */
    EventType: ApiHistorySyncEventType;
    /** The id of the sync in which the error occurred. This can be null
for some legacy syncs. */
    SyncModuleId: number | undefined;
    /** The type of the sync in which the error occurred. */
    SyncModuleType: string | undefined;
    /** The name of the sync in which the sync error occurred. */
    SyncName: string | undefined;
    /** Indicates whether the sync error occurred during a push or pull.
When true, the error occurred during a push. Otherwise, it occurred
during a pull. */
    IsPushError: boolean;
    /** Indicates whether the sync error occurred during an automatic
merge operation. When true, the error occurred during an automatic
merge. Otherwise, it occurred during a normal sync operation. */
    IsAutoMergeError: boolean;
    /** The actual error message provided by the sync for the sync error. */
    ErrorMessage: string | undefined;
}

/** Indicates the type of sync event. This enum has the following values:  - `Error` The sync failed with an error.  - `ErrorResolved` The sync error has been resolved. */
export enum ApiHistorySyncEventType {
    Error = "Error",
    ErrorResolved = "ErrorResolved",
}

/** Information on the migration of the item from a third-party system. */
export interface ApiHistoryItemMigrated {
    /** Some information provided by the migration tool. Most likely
the name of the third-party system from which the item was migrated
and or its original id. */
    Info: string | undefined;
    /** A URL where a file with the history of the item in the third-party
system can be downloaded. */
    HistoryDownloadUrl: string | undefined;
}

/** Contains the requested relations together with some information on the item for which the relations were requested. */
export interface ApiRelations {
    /** The item for which the relation were requested. */
    Item: ApiItemIdentifier | undefined;
    /** The depth (number of levels) for which the relations
were requested. */
    Depth: number;
    /** The relations of the items. Might contain several
levels of relations depending on the requested depth. */
    Relations: ApiRelation[] | undefined;
}

/** Represents a relation between to items. These items might belong either to aqua or to an external system. */
export interface ApiRelation {
    /** The id of the relation itself. */
    Id: string | undefined;
    /** The type of the dependency. */
    Type: ApiRelationType;
    /** Information on the source item of the relation. The amount of
information included depends on the request and the item type. */
    Item: ApiItemIdentifier | undefined;
    /** Contains relation-specific data for the source item of
the relation. */
    ItemExtra: IApiRelationItemExtra | undefined;
    /** The target item of the relation. The amount of information
included depends on the request and the item type. */
    OtherItem: ApiItemIdentifier | undefined;
    /** Contains relation-specific data for the target item of
the relation. */
    OtherItemExtra: IApiRelationItemExtra | undefined;
    /** Indicates whether the user is allowed view to the other item.
Further permission information might be found in the item itself. */
    OtherItemCanView: ApiPermissionResult;
}

/** Identifies the type of relation. This enum has the following values:  - `AffectsExecution` The item affects an execution. This is the reverse of ExecutionAffectedBy.  - `AlternativeTo` This item is an alternative to the other item  - `ConflictsWith` This item conflicts with the other item.  - `DependsOn` This item depends on the other item. This is the reverse of HasDependentItem.  - `Details` This item details the other item. This is the reverse of IsDetailedBy.  - `Duplicates` This item duplicates the other item.  - `ExecutionAffectedBy` The item (which is an execution) is affected by the other item. This is the reverse of AffectsExecution.  - `HasDependentItem` The other item depends on this item. This is the reverse of DependsOn.  - `HasNewerVersion` This item has a new version which is the other item. This is the reverse of IsNewerVersionOf.  - `HasPrecondition` This item has the other item as a precondition. This is the reverse of IsPreconditionOf.  - `IsCopyOf` This item is a copy of the other item. This is the reverse of WasCopiedBy.  - `IsDetailedBy` This item is detailed by the other item meaning that the other item contains additional details for this item. This is the reverse of Details.  - `IsNestedIn` This item (test case) is nested in another item (another test case). This is the reverse of Nests.  - `IsNewerVersionOf` This item is a newer version of the other item. This is the reverse of HasNewerVersion.  - `IsPreconditionOf` This item is a precondition of the other item. This is the reverse of HasPrecondition.  - `IsUtilityScriptOf` This item is a utility script of the other item. This is the reverse of UsesUtilityScript.  - `IsVerifiedBy` This item is verified by the other item. This is the reverse of Verifies.  - `Nests` This item (test case) nestst the other item (test case). This is the reverse of IsNestedIn.  - `ReferencesTestCaseTestData` This item (test case) references test data from the other item (test case). This is the reverse of SharesTestDataWith.  - `RelatedTo` This item is related to the other item.  - `SharesTestDataWith` This item (test case) shares its test data with another item (another test case). This is the reverse of ReferencesTestCaseTestData.  - `UsesUtilityScript` This item uses the other item as a utility script. This is the reverse of IsUtilityScriptOf.  - `Verifies` This item verifies the other item. This is the reverse of IsVerifiedBy.  - `WasCopiedTo` This item was copied to the other item. This is the reverse of IsCopyOf. */
export enum ApiRelationType {
    RelatedTo = "RelatedTo",
    Duplicates = "Duplicates",
    Details = "Details",
    IsDetailedBy = "IsDetailedBy",
    IsNewerVersionOf = "IsNewerVersionOf",
    HasNewerVersion = "HasNewerVersion",
    DependsOn = "DependsOn",
    HasDependentItem = "HasDependentItem",
    ConflictsWith = "ConflictsWith",
    AlternativeTo = "AlternativeTo",
    Verifies = "Verifies",
    IsVerifiedBy = "IsVerifiedBy",
    IsPreconditionOf = "IsPreconditionOf",
    HasPrecondition = "HasPrecondition",
    IsCopyOf = "IsCopyOf",
    WasCopiedTo = "WasCopiedTo",
    IsUtilityScriptOf = "IsUtilityScriptOf",
    UsesUtilityScript = "UsesUtilityScript",
    Nests = "Nests",
    IsNestedIn = "IsNestedIn",
    AffectsExecution = "AffectsExecution",
    ExecutionAffectedBy = "ExecutionAffectedBy",
    ReferencesTestCaseTestData = "ReferencesTestCaseTestData",
    SharesTestDataWith = "SharesTestDataWith",
}

/** Holds additional, relation-specific data for one side of a relation. */
export interface IApiRelationItemExtra {
}

/** The necessary metadata to create new relations for a certain item. */
export interface ApiRelationCreateMeta {
    /** Contains for each item type the list of relations types which are allowed between
the source item and items of the given item type. */
    AllowedTypes: { [key in keyof typeof ApiItemType]?: ApiRelationType[]; } | undefined;
}

/** Contains the data necessary to create a new relation. */
export interface ApiRelationNew {
    /** Contains relation-specific data for the source item of
the new relation. */
    ItemExtra: any | undefined;
    /** The id of the target of the new relation. */
    OtherItemId: string | undefined;
    /** The item type of the target of the new relation. */
    OtherItemType: ApiItemType;
    /** Contains relation-specific data for the target item of
the new relation. */
    OtherItemExtra: any | undefined;
    /** The type of the new relation. */
    Type: ApiRelationType;
}

/** Represents a new watcher to be added. */
export interface ApiWatcherNew {
    /** The id of the involved user. */
    UserId: number;
}

/** Represents an update to the watchers list. */
export interface ApiWatchersUpdate {
    /** Ids of the users to be added to the watchers list */
    UserIdsAdded: number[] | undefined;
    /** Ids of the users to be removed from the watchers list */
    UserIdsRemoved: number[] | undefined;
}

/** This class contains just the basic information on a post but not its contents or the list of users mentioned in it. */
export interface ApiPostInfo {
    /** The id of the post. */
    Id: number;
    /** The index of this post in the list posts for the associated item. */
    Number: number;
    /** The user who created the post. */
    Creator: ApiUserInfo | undefined;
    /** The user who edited the post most recently. */
    LastEditor: ApiUserInfo | undefined;
    /** The date when the post was created. */
    DateCreated: Date;
    /** The date when the post was last modified. */
    DateModified: Date;
    /** Indicates whether the post has been deleted. Deleted posts do not contain any
content but are still included in the list of post for a certain item. */
    Deleted: boolean;
}

/** A post with its full contents and the list of mentioned users. */
export interface ApiPost extends ApiPostInfo {
    /** The text content of the post. The content is provided in multiple formats. */
    Content: ApiRichText | undefined;
    /** The list of users which are mentioned in the post. Users can be mentioned in
a post by using the @username syntax. */
    MentionedUsers: ApiUserInfo[] | undefined;
}

/** Contains paginated posts with total count of posts. */
export interface ApiPostPaginated {
    /** The list of paginated posts. */
    Posts: ApiPost[] | undefined;
    /** The total count of posts for this object. */
    PostsTotalCount: number;
}

/** Provides information about a system environment */
export interface ApiEnvironmentInfo {
    /** Multitenant environment is used */
    IsMultiTenant: boolean;
}

/** Request for exporting files */
export interface ApiItemExportRequest {
    /** The objectTypes to export
If an objecttype is specified, all items of that objecttype in the folder are exported, 
the respective id list for that objecttype is then ignored in this case. */
    objectTypes: ObjectType[] | undefined;
    /** Ids of requirements to be exported */
    RequirementIds: number[] | undefined;
    /** Ids of defect to be exported  */
    DefectIds: number[] | undefined;
    /** Ids of testcases to be exported */
    TestCaseIds: number[] | undefined;
    /** Ids of testscenarios to be exported */
    TestScenarioIds: number[] | undefined;
    /** Export everything from subfolders */
    recursive: boolean;
    /** Export fields not visible on layout */
    includeInvisibleFields: boolean;
    /** Export the Attachments */
    includeAttachments: boolean;
    /** Export the rtf to external files */
    includeRtfFiles: boolean;
}

export enum ObjectType {
    None = 0,
    Requirement = 1,
    Defect = 2,
    TestCase = 3,
    BusinessWorkflow = 4,
    TestScenario = 5,
    Script = 6,
    TestJobExecution = 7,
    ExternalItem00 = 100,
    ExternalItem01 = 101,
    ExternalItem02 = 102,
    ExternalItem03 = 103,
    ExternalItem04 = 104,
    ExternalItem05 = 105,
    ExternalItem06 = 106,
    ExternalItem07 = 107,
    ExternalItem08 = 108,
    ExternalItem09 = 109,
    VirtualTypeProjectPlan = 200,
    SpecialCommon = 300,
}

/** The detail about a given feature */
export interface ApiFeatureInfo {
    /** If the feature is enabled or not */
    IsEnabled: boolean;
}

/** Contains metadata for an uploaded image. */
export interface ApiFileUploadInfo {
    /** The GUID which identifies this file upload. */
    Guid: string;
    /** The URL which allows you to download the temporarily uploaded file again. */
    Url: string | undefined;
}

/** Contains a file upload URL and some corresponding metadata. */
export interface ApiFileUploadUrlResponse {
    /** The Guid which uniquely identifies the file upload. */
    Guid: string;
    /** The type of the upload URL. The upload request needs to be
constructed differently depending on the type. */
    UrlType: ApiFileUploadUrlType;
    /** The URL to which the content of the file should be uploaded.
This URL is only valid for a limited time. */
    UploadUrl: string | undefined;
    /** This URL can be used to download the content again after
it was uploaded. This URL is only valid for a limited time. */
    DownloadUrl: string | undefined;
}

/** The type of the upload URL. This enum has the following values:  - `Aqua` The upload URL points to aqua itself. The upload should be performed with a PUT request.  - `AzureBlobStorage` The upload URL points to Azure Blob Storage. The upload should be performed with a PUT request.The upload must contain the following custom header `x-ms-blob-type: BlockBlob`. */
export enum ApiFileUploadUrlType {
    Aqua = "Aqua",
    AzureBlobStorage = "AzureBlobStorage",
}

/** Contains the necessary information for creating an upload URL. */
export interface ApiFileUploadUrlRequest {
    /** The name of the file for which the upload URL is requested. */
    FileName: string;
    /** The size (in bytes) of the file for which the upload URL is requested. */
    FileSize: number;
}

/** Represents the result of a global items search */
export interface ApiGlobalSearchResult {
    /** The number of items which were skipped in the list of results.
This value is provided during the request. */
    StartAt: number;
    /** The maximum number of items which should be included in the result. */
    MaxResults: number;
    /** The overall number of items which are available. When using pagination,
this number is higher than the number of items which are included in the result. */
    Count: number;
    /** The list of items. */
    Items: ApiGlobalSearchItem[] | undefined;
}

/** Represents an item for a global search */
export interface ApiGlobalSearchItem {
    /** Id of item */
    Id: number;
    /** Name of item */
    Name: string | undefined;
    /** Type of Item */
    ItemType: ApiItemType;
    /** Name of the project which contains this item */
    ProjectName: string | undefined;
}

/** Represents a request for a global items search */
export interface ApiGlobalSearchRequest {
    /** Item types among which the search will be executed */
    SearchArea: ApiGlobalSearchArea;
    /** Searching text */
    SearchText: string | undefined;
    /** Shows if archived projects will be included or not */
    IncludeArchived: boolean;
    /** The number of items which were skipped in the list of results.
This value is provided during the request. */
    StartAt: number;
    /** The maximum number of items which should be included in the result. */
    MaxResults: number;
    /** Id of project where items will be searched. If value equals 0 it means that
items will be searched among all projects */
    ProjectId: number;
    /** The id of the folder of which the items are loaded. */
    FolderId: number;
    /** Indicates whether items from sub folders should be included. */
    IncludeSubfolders: boolean;
}

/** Represents available areas for search This enum has the following values:  - `AllItems`  - `Defects`  - `Requirements`  - `Scripts`  - `TestCases`  - `TestScenarios` */
export enum ApiGlobalSearchArea {
    AllItems = "AllItems",
    Requirements = "Requirements",
    Defects = "Defects",
    TestCases = "TestCases",
    TestScenarios = "TestScenarios",
    Scripts = "Scripts",
}

/** The metadata of an image. The content of the image is not included. */
export interface ApiImageInfo {
    /** The id of the image */
    Id: number;
    /** The checksum of the image's content */
    Checksum: string | undefined;
    /** The file extension of the image. Can be used to identify the type
of image. The extension .rtf is used for images included
in rich text. */
    FileExtension: string | undefined;
}

/** Contains metadata for an uploaded image. */
export interface ApiImageUploadInfo {
    /** The checksum of the image */
    Checksum: string | undefined;
    /** The absolute url which can be used to reference the image */
    Url: string | undefined;
}

/** Request for importing files from a previously uploaded excel file Suggested usage: first,import file with ignoreIncorrectRow set to false, to see if Import works and get any errors If any errors occur, display errors and let user decide if an import while skipping errors is desired. If he decides for an import with skipping erors, repeat the request with ignoreIncorrectRow set to true, the same fileMeta can be reused to avoid uploading the file again. */
export interface ApiItemImportRequest {
    /** Metadata of the uploaded excel import. */
    fileMeta: ApiFileUploadInfo | undefined;
    /** Controls the behavior for errors on import.
When set to false, the import will process all rows and log the errors into ApiImportLongRunningTaskInfo.FailedItems, which can be retrieved via /api/System/LongOperation. The successful items will NOT be saved.
When set to true the import will process all rows and successful items will be saved. NOT ERRORS WILL BE LOGGED. */
    ignoreIncorrectRow: boolean;
}

/** Contains the integration configurations together with necessary meta data. */
export interface ApiIntegrationConfigurations {
    /** Holds the configurations for the different integrations. */
    Configurations: ApiIntegrationConfigBase[] | undefined;
    /** Indicates whether the current user is allowed to edit
the configurations. */
    CanEdit: ApiPermissionResult;
}

/** Base class for integration configuration classes */
export interface ApiIntegrationConfigBase {
    /** Indicates whether this configuration supports remote lookup.
Requires support from "technology" (currently JIRA only) but also needs the proper configuration.
Note: the flag is properly set even if config has been "obfuscated" from sensitive data.
This flag is ignored during save (doesn't have to be provided at all). */
    SupportsLookup: boolean;
    IsEnabled: boolean;
    CustomerId: number;
    ProjectId: number | undefined;
    IntegrationType: string;
}

/** Represents configuration of JIRA integration in aqua. */
export interface ApiIntegrationConfigJira extends ApiIntegrationConfigBase {
    ItemViewURLPattern: string | undefined;
    ItemCreateURLPattern: string | undefined;
    APIBaseURL: string | undefined;
    APIUser: string | undefined;
    APIPassword: string | undefined;
}

/** Represents configuration of JIRA integration in aqua. */
export interface ApiIntegrationConfigOtrs extends ApiIntegrationConfigBase {
    ItemViewURLPattern: string | undefined;
}

/** The verification response */
export interface ApiIntegrationVerifyResponse {
    /** True if the connection succeeded */
    IsSuccess: boolean;
}

/** Base class for integration configuration update classes */
export interface ApiIntegrationConfigVerifyBase {
    IntegrationType: string;
}

/** Represents configuration of JIRA integration in aqua. */
export interface ApiIntegrationConfigVerifyJira extends ApiIntegrationConfigVerifyBase {
    APIBaseURL: string | undefined;
    APIUser: string | undefined;
    APIPassword: string | undefined;
}

/** Represents configuration of JIRA integration in aqua. */
export interface ApiIntegrationConfigVerifyOtrs extends ApiIntegrationConfigVerifyBase {
}

/** The body for the integration enable request */
export interface ApiIntegrationEnable {
    /** The customer id of the integration */
    CustomerId: number;
    /** The project id of the integration */
    ProjectId: number | undefined;
    /** A flag to indicate if the integration should be enabled */
    IsEnabled: boolean;
}

/** Encapsulates the update of the integrations configuration. */
export interface ApiIntegrationConfigurationsUpdate {
    /** Holds the configurations for the different integrations. */
    Configurations: ApiIntegrationConfigUpdateBase[] | undefined;
}

/** Base class for integration configuration update classes */
export interface ApiIntegrationConfigUpdateBase {
    /** Indicates whether this configuration supports remote lookup.
Requires support from "technology" (currently JIRA only) but also needs the proper configuration.
Note: the flag is properly set even if config has been "obfuscated" from sensitive data.
This flag is ignored during save (doesn't have to be provided at all). */
    SupportsLookup: boolean;
    IsEnabled: boolean;
    IntegrationType: string;
}

/** Represents configuration of JIRA integration in aqua. */
export interface ApiIntegrationConfigUpdateJira extends ApiIntegrationConfigUpdateBase {
    ItemViewURLPattern: string | undefined;
    ItemCreateURLPattern: string | undefined;
    APIBaseURL: string | undefined;
    APIUser: string | undefined;
    APIPassword: string | undefined;
}

/** Represents configuration of JIRA integration in aqua. */
export interface ApiIntegrationConfigUpdateOtrs extends ApiIntegrationConfigUpdateBase {
    ItemViewURLPattern: string | undefined;
}

/** Represents a newly created label. */
export interface ApiLabelNewResponse {
    /** Id of this label. */
    Id: number;
}

/** Represents a new label. */
export interface ApiLabelNew {
    /** Name of this label. The name is unique in combination with the base object type. */
    Name: string | undefined;
    /** Project this label should belong to. */
    ProjectId: number;
    /** Description of label. */
    Description: string | undefined;
    /** Contains a list of lables this label includes, making it a super label. */
    SubLabels: ApiLabelInfo[] | undefined;
}

/** Minimal version of a label. */
export interface ApiLabelInfo {
    /** Id of this label. */
    Id: number;
    /** Label version. */
    Version: number;
}

/** Represents a new label. */
export interface ApiLabelUpdate {
    /** Id of this label. */
    Id: number;
    /** Name of this label. The name is unique in combination with the base object type. */
    Name: string | undefined;
    /** Description of this label. */
    Description: string | undefined;
    /** Current Version of this label. */
    Version: number;
    /** Contains a list of lables this label includes, making it a super label. */
    SubLabels: ApiLabelInfo[] | undefined;
}

export interface ApiLabelListResult {
    Items: ApiLabel[] | undefined;
}

/** Represents a label. */
export interface ApiLabel extends ApiLabelInfo {
    /** Name of this label. The name is unique in combination with the base object type. */
    Name: string | undefined;
    /** Description of this label. */
    Description: string | undefined;
    /** Contains a list of lables this label includes, making it a super label. */
    SubLabels: ApiLabelInfo[] | undefined;
}

/** Represent a license info. */
export interface ApiLicenseInfo {
    /** License file name. */
    Name: string | undefined;
}

/** Represents the filter, sorting and search information */
export interface ApiItemArrangement {
    /** The filter syntax is as follows:
on the first place should be the FieldId followed by the operator and if the operator expects an value followed by the value.
[["Priority", "=", "High"], "and", ["DateCreatedDateTime", ">=", "2018-01-01"]]
The values for different field types should be defined as follows:

    String: the value as string
    Decimal: the value as number
    Datetime: a string defining the date and time in the following format: yyyy-MM-ddTHH:mm:ssK or
    yyyy-MM-ddTHH:mm:ss.fffK. The K represents optional time zone information (Z for UTC or a time zone offset).
    E.g.: 2018-03-15T21:42:42, 2018-03-15T21:42:42.123, 2018-03-15T21:42:42.123Z, 2018-03-15T21:42:42.123+02:00.
    Dictionary: the id of the field value as number
    MultiChoiceDictionary: a list of numbers where each number is a field value id. E.g.: [1,2]
    User: the user id as number.
    MultiChoiceUser: a list of numbers where each number is a user id. E.g.: [1,2] 
    TimeSpan: the value of the time span as number in seconds.
    Sprint: the id of the sprint as number.

The [field meta data](#operation/ProjectMeta_GetProjectFieldMeta) can be used to check which filter operators are supported for which fields. */
    Filter: string | undefined;
    /** The sorting syntax is as follows:
[["Significane", "desc"], ["Status", "asc]].
The [field meta data](#operation/ProjectMeta_GetProjectFieldMeta) can be used to check which fields support sorting. */
    Sorting: string | undefined;
    /** A fulltext search will be performed with this term and only matching
items will be included in the result */
    Search: string | undefined;
    /** The time zone offset, in minutes, of the client. Used for date filter operations */
    TimeZoneOffset: number | undefined;
}

export interface ApiItemGroupsResult {
    Total: number;
    Groups: ApiItemGroup[] | undefined;
}

export interface ApiItemGroup {
    FieldId: string | undefined;
    Caption: string | undefined;
    Count: number;
    Filter: any | undefined;
    SubGroups: ApiItemGroup[] | undefined;
}

/** Represents the filter, sorting, search and grouping information. */
export interface ApiItemArrangementGrouping extends ApiItemArrangement {
    /** The grouping syntax is as follows:
[["Significane", "desc"], ["Status", "asc]]
The field meta data can be used to check which fields support grouping. Grouping always includes
sorting by the grouped fields. The fields provided in sorting are used for additional sorting. */
    Groups: string | undefined;
}

export interface ApiNavigationDependencyResponse {
    /** The list of dependet item ids. */
    DependentItemIds: number[] | undefined;
}

/** Contains information about requested projects and subfolders, mainly for rendering the project tree. */
export interface ApiProjectTreeResponse {
    /** Contains list of available projects. 
This field is filled only if requested, may be null.  */
    Projects: ApiProjectTreeProject[] | undefined;
    /** Contains subfolders info for requested nodes. 
The response is returned in the same order as in the request. */
    Subfolders: ApiProjectTreeFolder[][] | undefined;
}

/** Holds the project information required to render a projects/folders tree. */
export interface ApiProjectTreeProject {
    /** The id of the project. */
    Id: number;
    /** The name of the project. */
    Name: string | undefined;
    /** Indicates whether this project has any subfolders */
    HasSubfolders: boolean;
    /** Indicates whether this project is archived */
    Archived: boolean;
}

/** Holds the folder information required to render a projects/folders tree. */
export interface ApiProjectTreeFolder {
    /** Id of folder */
    Id: number;
    /** Id of project where folder is located */
    ProjectId: number;
    /** Name of folder */
    Name: string | undefined;
    /** Folder Id of Parent, '0' means it is a root folder of the given project */
    ParentFolderId: number;
    /** Indicates whether this folder has any subfolders */
    HasSubfolders: boolean;
}

/** Contains information about requested folder "path" i.e. includes project information and information of all parents of a given folder up to the top. */
export interface ApiProjectTreePathResponse {
    /** Contains project information. */
    Project: ApiProjectTreeProject | undefined;
    /** Contains folder path, in top-down order.  */
    FoldersPath: ApiProjectTreeFolder[] | undefined;
}

export interface ApiSearchOperationLogResult {
    /** Count of all records matching the search request.  */
    Count: number;
    /** FirstResults from search request (if any) */
    FirstResults: number | undefined;
    /** MaxResults from search request (if any) */
    MaxResults: number | undefined;
    /** Contains found items matching the search criteria. 
If FirstResults/MaxResults have been provided in the search request then contains only appropriate portion of results, */
    Items: ApiOperationLog[] | undefined;
}

export interface ApiOperationLog {
    /** The id of this log entry. */
    Id: number;
    /** The user who did the change. Can be empty, in case of changes not related to any particular user (system changes). */
    OperationUser: ApiUserInfo | undefined;
    /** Date (UTC) when change has occurred.  */
    OperationDateUTC: ApiFieldValueDateTime | undefined;
    /** The id of the project */
    ProjectId: number | undefined;
    /** The name of the project */
    ProjectName: string | undefined;
    /** The id of the folder */
    FolderId: number | undefined;
    /** The human readable path as text. The path consists of the project name and
the folder names separated by slashes */
    FolderPath: string | undefined;
    /** Log category path (levels separated by dots). */
    Category: string | undefined;
    /** Related entity type. Depends on category, but usually it is e.g. object type (Defect, Requirement, ...), Sprint, ProjectPlan etc.  */
    EntityType: string | undefined;
    /** Related entity id. */
    EntityId: number | undefined;
    /** Additional descriptino of the change (human-readable, in english) */
    FurtherInfo: string | undefined;
    /** Filled only when entity type is User. Contains information about the user the operation was related to.  */
    EntityUser: ApiUserInfo | undefined;
}

/** A category for system log entries. */
export interface ApiOperationLogCategory {
    /** The name of the category. */
    Name: string | undefined;
    /** The scope to which system log entries with this
category apply. */
    Scope: ApiOperationLogCategoryScope;
}

/** The scope of a system log category. This enum has the following values:  - `Global` System log entries of this category apply to the whole system.  - `Project` System log entries of this category are specific for a certain project. */
export enum ApiOperationLogCategoryScope {
    Global = "Global",
    Project = "Project",
}

/** Info of a given project */
export interface ApiProjectInfo extends ApiProjectIdName {
    /** True if project was makred as archived.  */
    IsArchived: boolean;
    /** true if project was makred as favourite */
    IsFavourite: boolean;
    /** Indicates whether this project has any subfolders.  */
    HasSubfolders: boolean;
    /** short description of this project  */
    ShortDescription: string | undefined;
    /** Permissions of project-level operations  */
    ProjectPermissions: ApiProjectPermissions | undefined;
    /** Permissions of system-level operations  */
    SystemPermissions: ApiSystemPermissions | undefined;
    /** Permissions of root-folder operations  */
    FolderPermissions: ApiProjectFolderPermissions | undefined;
    /** Contains some basic information regarding the project configuration. */
    ProjectConfig: ApiProjectConfigInfo | undefined;
}

/** Represents permissions in a project. Includes only project-level permissions. For permissions that can be defined on folder level (e.g. permissions to create items) please refer to ApiProjectFolderPermissions (this also included a project's root-folder permissions). */
export interface ApiProjectPermissions {
    /** Indicates whether user is able to configure the project. */
    CanConfigureProject: ApiPermissionResult;
    /** Indicates whether user is allowed to use notifications. */
    CanUseNotifications: ApiPermissionResult;
    /** Indicates whether user is able to edit public user views. */
    CanEditPublicUserView: ApiPermissionResult;
    /** Indicates whether user is able to publish user views. */
    CanPublishUserView: ApiPermissionResult;
    /** Indicates whether user is able to see report definitions. */
    CanViewReportDefinitions: ApiPermissionResult;
    /** Indicates whether user is able to create report definitions. */
    CanCreateReportDefinition: ApiPermissionResult;
    /** Indicates whether user is able to import report definitions. */
    CanImportReportDefinition: ApiPermissionResult;
    /** Indicates whether user is able to configure the project template. */
    CanConfigureProjectTemplate: ApiPermissionResult;
    /** Indicates whether user is able to configure the project workflows. */
    CanConfigureProjectWorkflows: ApiPermissionResult;
    /** Indicates whether user is able to manage the users. */
    CanManageProjectUsers: ApiPermissionResult;
    /** Indicates whether user is able to configure the default notification rules. */
    CanConfigureDefaultNotificationRules: ApiPermissionResult;
    /** Indicates whether the user is able to configure the templates for
email notifications. */
    CanConfigureNotificationTemplates: ApiPermissionResult;
    /** Indicates whether user is able to see agents. */
    CanViewAgents: ApiPermissionResult;
    /** Indicates whether user is able to manage the agents. */
    CanManageAgents: ApiPermissionResult;
    /** Indicates whether user is able to add dependency in the project (in at least one subfolder). */
    CanAddDependencyAnySubfolder: ApiPermissionResult;
    /** Indicates whether user is able to see agile board. */
    CanViewAgileBoard: ApiPermissionResult;
    /** Indicates whether user is able to create or edit sprints. */
    CanCreateEditSprints: ApiPermissionResult;
    /** Indicates whether user is able to delete sprints. */
    CanDeleteSprints: ApiPermissionResult;
    /** Indicates whether user is able to plan sprints. */
    CanPlanSprints: ApiPermissionResult;
}

/** Represents permissions in a system. */
export interface ApiSystemPermissions {
    /** Indicates whether user is able to create a project.  */
    CanCreateProject: ApiPermissionResult;
    /** Indicates whether user is able to manage the roles.  */
    CanManageRoles: ApiPermissionResult;
    /** Indicates whether user is able to manage users in at least
one project. */
    CanManageAnyUsers: ApiPermissionResult;
    /** Indicates whether user is able to see system log. */
    CanViewSystemLog: ApiPermissionResult;
    /** Inidicates whether the user is able to manage integrations
for at least one project. */
    CanManageAnyIntegrations: ApiPermissionResult;
    /** Indicates whether user is able to see agile board
for at least one project. */
    CanViewAnyAgileBoard: ApiPermissionResult;
}

/** Some basic information regarding the project configuration (template, etc.). */
export interface ApiProjectConfigInfo {
    /** Indicates whether the current project owns the project configuration. */
    IsOwned: boolean;
    /** Indicates whether this project configuration is shared between
multiple projects. */
    IsShared: boolean;
    /** Contains basic information regarding the project which owns this
project configuration. Might be null, if the user is not allowed
to access the owning project. */
    OwningProject: ApiProjectIdName | undefined;
}

/** Contains information about created project. */
export interface ApiProjectNewResponse {
    /** The id of the project. */
    ProjectId: number;
    /** Represents asnychronous operation that is copying items into newly created project. 
(only if CopyItems was true).  */
    CopyItemsLongOperation: ApiLongOperation | undefined;
}

/** Result of a REST API call that started long operation (asynchronous) to perform the actual job. Status of the task can be queried using GET System/LongOperation/{guid}/Status or GET System/LongOperation/{guid} In most cases it is also possible to be notified via SignalR when operation finishes. */
export interface ApiLongOperation {
    /** Id of the long running task. Can be used to query the progress (see GET /System/LongOperation/{guid}).  */
    LongRunningTaskGuid: string | undefined;
}

/** Contains necessary information to create a new project. */
export interface ApiProjectCreate {
    /** The name of the project. */
    Name: string | undefined;
    /** The information about the source project (or null if creating project from defaults). */
    SourceProject: ApiProjectCreateSource | undefined;
    /** Project configuration (imported from an .acxz file) to be used for the created project
(or null if creating project from defaults). The file should be uploaded to the endpoint
[UploadFile](#operation/File_UploadFile)
first. */
    UploadedConfiguration: ApiFileUploadInfo | undefined;
}

/** Contains informations about the source project used to create a new project. */
export interface ApiProjectCreateSource {
    /** The id of the source project. */
    ProjectId: number;
    /** If true the project configuration and items will be copied, otherwise only project configuration will be copied. */
    CopyItems: boolean;
    /** If true shares the configuration with the source project. */
    ShareConfiguration: boolean;
}

/** Represents data required to execute project-modify operation. There are multiple project modify operations supported - see ApiProjectPatchTypes. Depending on the type the actual properties can differ. See subclasses for details. */
export interface ApiProjectPatchOperation {
    PatchOperation: string;
}

/** Rename project operation. */
export interface ApiProjectPatchRename extends ApiProjectPatchOperation {
    /** New name of the project being updated.  */
    NewName: string | undefined;
}

/** Archive/unarchive project operation. */
export interface ApiProjectPatchArchive extends ApiProjectPatchOperation {
    /** Specifies whether given project should be set archive (true) or non-archived (false) */
    Archived: boolean;
}

/** Contains information about report definition. */
export interface ApiReportDefinitionInfo {
    /** The id of the report definition. */
    Id: number;
    /** The name of the report definition. */
    Name: string | undefined;
    /** The owner of the report definition. */
    Owner: ApiUserInfo | undefined;
    /** The id and the name of the project. */
    ProjectInfo: ApiProjectIdName | undefined;
    /** The color of the report definition */
    Color: string | undefined;
    /** If true indicates that the report definition is public. */
    IsPublic: boolean;
    /** List of used ApiItemTypes for this report definition. */
    ItemTypes: ApiItemType[] | undefined;
    /** Information about user permissions. */
    Permissions: ApiReportPermissions | undefined;
}

/** Represents permissions for a report. */
export interface ApiReportPermissions {
    /** Indicates whether the user is able to generate a report based on
this report definition. */
    CanGenerate: ApiPermissionResult;
    /** Indicates whether the user is able to edit this report definition's properties. */
    CanEditProperties: ApiPermissionResult;
    /** Indicates whether the user is able to edit this report definition's layout. */
    CanEditLayout: ApiPermissionResult;
    /** Indicates whether the user is able to delete this report definition. */
    CanDelete: ApiPermissionResult;
    /** Indicates whether the user is able to export this report definition. */
    CanExport: ApiPermissionResult;
    /** Indicates whether the user is able to publish this report definition. */
    CanPublish: ApiPermissionResult;
    /** Indicates whether the user is able to unpublish this report definition. */
    CanMakePrivate: ApiPermissionResult;
}

/** Represent the report definition patch request. */
export interface ApiReportPatchOperation {
    PatchType: string;
}

/** Represent the report definition import request. */
export interface ApiReportPatchImport extends ApiReportPatchOperation {
    /** The list of report template files which should be imported.
The files should be uploaded to the endpoint
[UploadFile](#operation/File_UploadFile)
first. */
    filesMeta: ApiFileUploadInfo[] | undefined;
}

/** This enum has the following values:  - `Active`  - `All`  - `Inactive` */
export enum ApiSprintsInclude {
    All = "All",
    Active = "Active",
    Inactive = "Inactive",
}

export interface ApiProjectSubFolder extends ApiProjectFolder {
    /** Indicates whether this folder has any subfolders.  */
    HasSubfolders: boolean;
}

/** Contains information about update on the project folder roles. */
export interface ApiProjectUpdateProjectFolderRolesResponse {
    /** Indicates if an error occurred during the update. */
    ErrorOccurred: boolean;
    /** The error list. */
    ErrorList: ApiErrorInformation[] | undefined;
}

/** Contains information about an error which occurred during an API call. */
export interface ApiErrorInformation {
    /** The type of argument error which occurred. 
Used only when Type == ApiErrorType.ArgumentError */
    ArgumentErrorType: ApiArgumentErrorType;
    /** A human-readable description of the error. */
    Message: string | undefined;
}

/** Contains information about update for the project roles. */
export interface ApiProjectUpdateProjectFolderRolesRequest {
    /** The list of roles wich should be added or modified. */
    AddRoles: ApiUpdateProjectFolderRole[] | undefined;
    /** The list of roles wich should be deleted. */
    DeleteRoles: ApiDeleteProjectFolderRole[] | undefined;
}

export interface ApiDeleteProjectFolderRole {
    /** The id of the folder. */
    FolderId: number;
    /** The id of the user. */
    UserId: number;
}

export interface ApiUpdateProjectFolderRole extends ApiDeleteProjectFolderRole {
    /** The role id for the folder. */
    RoleId: number;
}

/** The user project assignment. */
export interface ApiUserProjectFolderAssignment {
    /** User Id. */
    UserId: number;
    /** Project folder id, for the project assignment use id 0. */
    FolderId: number;
    /** Role id. */
    RoleId: number;
}

/** Represents the get user assignment response. */
export interface ApiGetUserAssignmentResponse {
    /** The list of assignments. */
    Assignements: ApiUserRole[] | undefined;
}

/** Represents the user. the assigned role and the folder. */
export interface ApiUserRole {
    /** The assigned role.
             */
    Role: ApiRoleIdName | undefined;
    /** The user. */
    User: ApiUserInfo | undefined;
    /** The folder id. */
    FolderId: number;
}

export interface ApiUserProjectFolderAssignmentPatchOperation {
    OperationType: string;
}

/** Replace role operation */
export interface ApiUserProjectFolderAssignmentPatchReplace extends ApiUserProjectFolderAssignmentPatchOperation {
    /** New role id.  */
    NewRoleId: number;
}

export interface ApiProjectSubfoldersPatchOperation {
    OperationType: string;
}

export interface ApiProjectSubfoldersBatchCreate extends ApiProjectSubfoldersPatchOperation {
    /** Path separator. Expected to be single character.  */
    PathSeparator: string | undefined;
    /** List of subfolders to be created. Each entry is a full path of the folder (relative to the origin parent folder).
For example, the following list: 

/a
/a/b
/a/b/c
/a/b/d

would create a tree structure:

* project 
  - parent folder 
    - a
      - b 
        - c
        - d

WARNING! folders needs to be included on the list in order that guarantee parent folder is before its children.  */
    Subfolders: string[] | undefined;
}

/** Result of a REST API call that started long operation (asynchronous) to perform the actual job. When LongRunningTaskGuid is null this indicates a situation when REST API was able to process the task without starting asynchronous job. Then the actual result is returned in Result field. */
export interface ApiLongOperationOfInteger {
    /** Id of the long running task. Can be used to query the progress (see GET /System/LongOperation/{guid}). 
If empty indicates the long operation has not been started and actual result is immediately available in the Result field.  */
    LongRunningTaskGuid: string | undefined;
    /** Filled only when LongRunningTaskGuid is not provided. Contains actual, immediate result of the call.  */
    Result: number;
}

export interface ApiProjectFolderCreate {
    /** Name fo the folder to be created. 
If SourceFolder is provided then Name must be null, what means using the same name as name of the source folder. 
If SourceFolder is not provided then Name is required (not empty). 
Note: folder names must be unique (on one level).  */
    Name: string | undefined;
    /** If provided then new folder is created as a copy of the given source folder.  */
    SourceFolder: ApiProjectFolderCreateSourceFolder | undefined;
}

/** Encapsulated information about location of a source folder. */
export interface ApiProjectFolderCreateSourceFolder {
    /** Id of the source folder (in the source project). 
Zero is not supported here.  */
    FolderId: number;
}

/** Represents data required to execute folder-modify operation. There are multiple folder modify operations supported - see ApiProjectFolderPatchOperationType. Depending on the type the actual properties can differ. See subclasses for details. */
export interface ApiProjectFolderPatchOperation {
    OperationType: string;
}

/** Rename folder operation */
export interface ApiProjectFolderPatchRename extends ApiProjectFolderPatchOperation {
    /** New name of the folder being updated.  */
    NewName: string | undefined;
}

/** Move folder operation. As we currently do not support cross-projects operations the target folder needs to be located in the same project. */
export interface ApiProjectFolderPatchMove extends ApiProjectFolderPatchOperation {
    TargetParentFolderId: number;
}

/** Contains a paginated result. */
export interface ApiPaginatedResultOfApiItemInfo {
    /** The number of items which were skipped in the list of results.
This value is provided during the request. */
    StartAt: number;
    /** The maximum number of items which should be included in the result.
This value is provided during the request. */
    MaxResults: number;
    /** The overall number of items which are available. When using pagination,
this number is higher than the number of items which are included in the result. */
    Count: number;
    /** The actual items included in this response. */
    Items: ApiItemInfo[] | undefined;
}

/** The list of search results and some meta information regarding the search. */
export interface ApiItemSearchResult {
    /** The term for which the search has been performed */
    SearchTerm: string | undefined;
    /** The overall number of results. */
    Count: number;
    /** The results of the search. The list contains basic information
for each search result. */
    Items: ApiItemInfo[] | undefined;
}

/** Contains some basic information on the user view. */
export interface ApiUserViewInfo {
    /** The id of the view. */
    Id: number;
    /** The information about the owner. */
    Owner: ApiUserInfo | undefined;
    /** The name of the view. */
    Name: string | undefined;
    /** The description of the view. */
    Description: string | undefined;
    /** The color of the view. */
    Color: string | undefined;
    /** Indicates whether the view is public or not. */
    IsPublic: boolean;
    /** Indicates whether the view is favorite or not. */
    IsFavorite: boolean;
    /** Information about user permissions. */
    Permissions: ApiUserViewPermissions | undefined;
    /** List of ApiItemTypes for wich this user view is applicable. */
    ApplicableItemTypes: ApiItemType[] | undefined;
}

/** Represents permissions for a report. */
export interface ApiUserViewPermissions {
    /** Indicates whether user is able to edit user view. */
    CanEdit: ApiPermissionResult;
    /** Indicates whether user is able to delete user view. */
    CanDelete: ApiPermissionResult;
    /** Indicates whether user is able to publish user view. */
    CanPublish: ApiPermissionResult;
    /** Indicates whether user is able to depublish user view. */
    CanMakePrivate: ApiPermissionResult;
}

/** Represents a report plugin. */
export interface ApiReportPlugin {
    /** Unique code of this report plugin. */
    UniqueCode: string | undefined;
    /** Name of the plugin. */
    Name: string | undefined;
    /** Plugin description (can be empty) */
    Description: string | undefined;
}

/** Represents the preview for the import of project configuration. */
export interface ApiImportProjectTemplatePreviewResponse {
    /** Represents the list of changes which need to be applied. */
    ListOfChanges: ApiImportProjectTemplatePreviewEntry[] | undefined;
}

export interface ApiImportProjectTemplatePreviewEntry {
    /** The realted item type of the future change. */
    ItemType: ApiItemType | undefined;
    /** The description of the future change. */
    Description: string | undefined;
    /** The category of the future change. */
    Category: ApiDiffCategoryType;
    /** The flag which identifies if the future change can be done automatically. */
    ReadyToImport: boolean;
    /** The cause why the future change can not be done automatically. */
    Cause: string | undefined;
}

/** Identifies the type of item. This enum has the following values:  - `FieldRules`  - `Notification`  - `Subtemplate`  - `Template`  - `Workflow` */
export enum ApiDiffCategoryType {
    Template = "Template",
    Workflow = "Workflow",
    Subtemplate = "Subtemplate",
    Notification = "Notification",
    FieldRules = "FieldRules",
}

/** The different modes in which the list of fields can be sorted. This enum has the following values:  - `ById` Sorts the fields by their Id.  - `ByLayoutPosition` Sort the fields by the position in the edit layout. Fields which are not part of the edit layout are added at the end.  - `ByTitle` Sort the fields by their title. */
export enum ApiFieldSortMode {
    ById = "ById",
    ByLayoutPosition = "ByLayoutPosition",
    ByTitle = "ByTitle",
}

/** Represents a single dictionary (i.e. entity that has a name and holds list of values) defined in the project template. Please note that dictionary fields reference either their own ("local") dictionaries, or use dictionaries referenced by many fields at the same time ("shared"). */
export interface ApiProjectTemplateDictionary {
    /** Entries of this dictionary. The order matters.  */
    Entries: ApiProjectTemplateDictionaryEntry[] | undefined;
    /** Internal Id of the dictionary. */
    Id: number;
    /** Name of the dictionary. */
    Name: string | undefined;
    /** Consistency key. Needs to be provided when saving. 
Prevents from concurrent modifications.  */
    ConsistencyKey: string | undefined;
}

/** Contains the meta-information of a new dictionary entry. */
export interface ApiProjectTemplateDictionaryEntryNew {
    /** Name of the dictionary entry. This is the value visible in the UI.  */
    Name: string | undefined;
    /** Indicates whether this entry should be considered as default for this dictionary.  */
    IsDefault: boolean;
}

/** Contains the meta-information of a dictionary entry. */
export interface ApiProjectTemplateDictionaryEntry extends ApiProjectTemplateDictionaryEntryNew {
    /** Id of the entry. This value is stored on actual item that references the dictionary entry.
(Entries can be safely renamed, as their ids do not change). */
    Id: number;
}

/** Represents an update of single dictionary (i.e. entity that has a name and holds list of values) defined in the project template. Please note that dictionary fields reference either their own ("local") dictionaries, or use dictionaries referenced by many fields at the same time ("shared"). */
export interface ApiProjectTemplateDictionaryUpdate {
    /** Entries of this dictionary. The order matters.  */
    Entries: ApiProjectTemplateDictionaryEntry[] | undefined;
    /** Internal Id of the dictionary. */
    Id: number;
    /** Name of the dictionary. */
    Name: string | undefined;
    /** Consistency key. Needs to be provided when saving. 
Prevents from concurrent modifications.  */
    ConsistencyKey: string | undefined;
}

/** Represents data required to execute modify operation. */
export interface ApiFieldPatchOperation {
    /** The id of the field. */
    FieldId: string;
    /** The item type. */
    ItemType: ApiItemType;
    PatchOperation: string;
}

/** Activate field operation. */
export interface ApiFieldPatchOperationActivateField extends ApiFieldPatchOperation {
}

/** Deactivate field operation. */
export interface ApiFieldPatchOperationDeactivateField extends ApiFieldPatchOperation {
}

/** Contains the meta-information of a project template. */
export interface ApiProjectTemplateInformation {
    /** List of projects which share the template. */
    AffectedProjects: ApiProjectIdName[] | undefined;
    /** List which indicates for each item type whether the layout was created in web client. */
    ApiItemTypeIsWebLayout: ApiItemTypeIsWebLayoutInfo[] | undefined;
    /** The project for which this part of the project configuration was requested. */
    Project: ApiProjectIdName | undefined;
    /** Indicates whether the project configuration is shared with
a different project. */
    IsShared: boolean;
    /** Indicates whether the project configuration is owned by the
project for which this part of the configuration was requested. */
    IsOwned: boolean;
    /** The project which owns the project configuration. When the project
configuration is shared, the project configuration might not be owned by the project for
which this part of the project configuration was requested. This info can be null if you
are not allowed to access the owning project. */
    OwningProject: ApiProjectIdName | undefined;
}

/** Contains the meta-information of a base object template which is shown by the item type and the information where the layout was created. */
export interface ApiItemTypeIsWebLayoutInfo {
    /** Item type which represents base object template for which the layout information is returned. */
    ItemType: ApiItemType;
    /** Indicates whether the layout was created in web client. */
    IsWebLayout: boolean;
}

/** Contains the FieldRules for all item types for a certain project. */
export interface ApiProjectFieldRules {
    /** The project for which this part of the project configuration was requested. */
    Project: ApiProjectIdName;
    /** Indicates whether the project configuration is shared with
a different project. */
    IsShared: boolean;
    /** Indicates whether the project configuration is owned by the
project for which this part of the configuration was requested. */
    IsOwned: boolean;
    /** The project which owns the project configuration. When the project
configuration is shared, the project configuration might not be owned by the project for
which this part of the project configuration was requested. This info can be null if you
are not allowed to access the owning project. */
    OwningProject: ApiProjectIdName | undefined;
    /** Contains the FieldRules for each item type. */
    Rules: ApiFieldRules[];
}

/** Contains the field rules for a certain item type in a certain project. */
export interface ApiFieldRules {
    /** The item type to which the field rules apply. */
    ItemType: ApiItemType;
    /** The list of rules. Rules can be only one of the following types:
  - DependentValues: rules of this type restrict the possible values
    of a certain field based on the current value of another field.
  - Workflow: rules of this type specify actions which are executed when
    the value of a dictionary field is changed to a certain value.
    These actions include setting a field readonly, changing
    the value of a field, etc. */
    Rules: ApiFieldRule[];
}

/** Contains the modifications which should be applied to the field rules for all item types in a project. */
export interface ApiProjectFieldRulesUpdate {
    /** Contains the field rules to update per item type. If nothing
is specified for a certain item type, its field rules are not
modified. */
    Rules: ApiFieldRulesUpdateWithItemType[];
}

/** Contains the modifications which should be applied to the field rules for a certain item type. */
export interface ApiFieldRulesUpdate {
    /** The list of field rules which should be set. The existing rules
will be replaced. Rules can be only one of the following types:
  - DependentValues: rules of this type restrict the possible values
    of a certain field based on the current value of another field.
  - Workflow: rules of this type specify actions which are executed when
    the value of a dictionary field is changed to a certain value.
    These actions include setting a field readonly, changing
    the value of a field, etc. */
    Rules: ApiFieldRuleUpdate[];
}

/** Contains the modifications which should be applied to the field rules of a certain item type together with the item type to which this update should be applied. */
export interface ApiFieldRulesUpdateWithItemType extends ApiFieldRulesUpdate {
    /** The item type to which this update should be applied. */
    ItemType: ApiItemType;
}

/** Represents a single rule for a field. */
export interface ApiFieldRuleUpdate {
    /** The id of the field to which the rule applies. */
    FieldId: string;
    RuleType: string;
}

/** A field rule which defines a dependency between to dictionary fields. Values of the field with the id FieldId are only allowed for certain values in the field with the id OtherFieldId. */
export interface ApiFieldRuleDependentValuesUpdate extends ApiFieldRuleUpdate {
    /** The id of the other field on which the field to which this rule applies depends. */
    OtherFieldId: string;
    /** The list with the restrictions for the value of the field. */
    Restrictions: ApiFieldValueRestrictionUpdate[];
}

/** Represents the modification of a restriction, which restricts the value of field based on the values of another field. */
export interface ApiFieldValueRestrictionUpdate {
    /** The value which should be restricted. */
    Value: any;
    /** A list of values of the other field for which the current
value is allowed. */
    AllowedFor: any[];
}

/** This field rule allows to specify actions which are performed when a dictionary field is changed to a certain value. */
export interface ApiFieldRuleWorkflowUpdate extends ApiFieldRuleUpdate {
    /** The list of transitions which this rule defines. Each transition
specifies a list of actions which should be performed when the
field is changed to the specified value. */
    Transitions: ApiFieldRuleWorkflowTransitionUpdate[];
}

/** Contains all the actions which should be performed when the dictionary field is changed to the specified value. */
export interface ApiFieldRuleWorkflowTransitionUpdate {
    /** The field value to which this transition applies. */
    Value: ApiFieldValue;
    /** The list of actions which are executed when the value of the
dictionary field is changed to the specified value. */
    Actions: ApiFieldRuleWorkflowActionsUpdate[];
}

/** Contains the actions which should be performed for one specific field. */
export interface ApiFieldRuleWorkflowActionsUpdate {
    /** This action is applied to the field with this id.
The id is the same as the base object property name. */
    FieldId: string;
    /** Indicates whether the field should be readonly. */
    Readonly: boolean;
    /** Indicates whether the field should be required. */
    Required: boolean;
    /** Indicates whether the field should be highlighted. */
    Visible: boolean;
    /** Indicates whether the field should be visible. */
    Highlight: boolean;
    /** Indicates whether the value of the field should be changed. */
    ChangeValue: boolean;
    /** The value to which the field should be set. The type depends
on the field type. */
    Value: ApiFieldValue | undefined;
}

/** Contains the field rules for a certain item type in a certain project together with some additional information regarding the ownership of the project template to which the field rules belong. */
export interface ApiFieldRulesWithOwnership extends ApiFieldRules {
    /** The project for which this part of the project configuration was requested. */
    Project: ApiProjectIdName;
    /** Indicates whether the project configuration is shared with
a different project. */
    IsShared: boolean;
    /** Indicates whether the project configuration is owned by the
project for which this part of the configuration was requested. */
    IsOwned: boolean;
    /** The project which owns the project configuration. When the project
configuration is shared, the project configuration might not be owned by the project for
which this part of the project configuration was requested. This info can be null if you
are not allowed to access the owning project. */
    OwningProject: ApiProjectIdName | undefined;
}

/** Represents options of a certain project. */
export interface ApiProjectOptions {
    /** If set, then 'Expected Results' field is mandatory when defining a test case.  */
    RequireExpectedResults: boolean;
    /** If set, then 'Actual Results' field is mandatory when manually executing a test case.  */
    RequireActualResults: boolean;
}

/** Represents options of a certain project together with some additional information regarding the ownership of the project options (either project itself or the master project, in case of shared template setup). */
export interface ApiProjectOptionsWithOwnership extends ApiProjectOptions {
    /** The project for which this part of the project configuration was requested. */
    Project: ApiProjectIdName | undefined;
    /** Indicates whether the project configuration is shared with
a different project. */
    IsShared: boolean;
    /** Indicates whether the project configuration is owned by the
project for which this part of the configuration was requested. */
    IsOwned: boolean;
    /** The project which owns the project configuration. When the project
configuration is shared, the project configuration might not be owned by the project for
which this part of the project configuration was requested. This info can be null if you
are not allowed to access the owning project. */
    OwningProject: ApiProjectIdName | undefined;
    /** Indicates whether the current user is allowed to edit the project
settings. */
    CanEdit: ApiPermissionResult;
}

/** Represents a single dictionary (i.e. entity that has a name and holds list of values) defined in the project template. Please not that dictionary fields reference either their own ("local") dictionaries, or use dictionaries referenced by many fields at the same time ("shared"). Additionally, this class includes information whether (and where) in the project template the dictionary is referenced (which custom field use it). For local dictionaries we expect to find exactly one matching custom field. For shared dictionaries the list can be longer (but also zero). */
export interface ApiProjectTemplateDictionaryWithUsage extends ApiProjectTemplateDictionary {
    /** Contains list of places (custom fields) where the dictionary is referenced in current project template.  */
    Usage: ApiProjectTemplateDictionaryUsage[] | undefined;
}

/** Represents a usage of dictionary by a custom field. */
export interface ApiProjectTemplateDictionaryUsage {
    /** Item type  */
    ItemType: ApiItemType;
    /** Id of the field */
    FieldId: string | undefined;
    /** Field title  */
    FieldTitle: string | undefined;
}

/** Represents a new dictionary to be created. */
export interface ApiProjectTemplateDictionaryNew {
    /** Entries of this dictionary. The order matters. 
All items must be new. */
    Entries: ApiProjectTemplateDictionaryEntryNew[] | undefined;
    /** Name of the dictionary. */
    Name: string | undefined;
}

/** Contains the project default notification rule. */
export interface ApiProjectNotificationRule {
    /** Item type this rule is defined for. */
    ItemType: ApiItemType;
    /** The id and name of the project. */
    ProjectInfo: ApiProjectIdName | undefined;
    /** Creator user info. */
    CreatedByUser: ApiUserInfo | undefined;
    /** The id of the rule. */
    Id: number;
    /** The type of the filter. */
    FilterType: ApiNotificationRuleFilterType;
    /** Possible filter options only available if FilterType is Custom. */
    CustomFilterOptions: ApiNotificationRuleFilterOptions | undefined;
    /** Ignore if owner action. */
    IgnoreIfOwnerAction: boolean;
}

/** The type of notification rule filter. This enum has the following values:  - `AnyChange` Any change notification.  - `Custom` Custom notification filter.  - `None` No notification filter. */
export enum ApiNotificationRuleFilterType {
    None = "None",
    Custom = "Custom",
    AnyChange = "AnyChange",
}

/** The type options of notification rule. */
export interface ApiNotificationRuleFilterOptions {
    /** Any change of base object property. */
    BaseObjectChangedProperties: boolean;
    /** Base object's status field has changed. */
    BaseObjectChangedStatus: boolean;
    /** List of accepted statuses as comma separated list. */
    BaseObjectAcceptedStatuses: string | undefined;
    /** Base object has been created.  */
    BaseObjectCreated: boolean;
    /** Base object has been moved between folders.  */
    BaseObjectMoved: boolean;
    /** Base object has been deleted.  */
    BaseObjectDeleted: boolean;
    /** Base object has been changed (including changed properties, create, delete, move)
assigned user notification. */
    BaseObjectChangeUnderAssignment: boolean;
    /** Base object has been changed (including changed properties, create, delete, move)
owner notification. */
    BaseObjectChangeUnderOwnership: boolean;
    /** Base object has been assigned. */
    BaseObjectAssigned: boolean;
}

/** Contains the necessary information to create a new folder notification rule. */
export interface ApiFolderNotificationRuleReplacement {
    /** The type of the filter. */
    FilterType: ApiNotificationRuleFilterType;
    /** Possible filter options only available if FilterType is Custom. */
    CustomFilterOptions: ApiNotificationRuleFilterOptions | undefined;
    /** Ignore if owner action. */
    IgnoreIfOwnerAction: boolean;
}

/** Contains the necessary information to create a new folder notification rule. */
export interface ApiFolderNotificationRuleReplacementWithType extends ApiFolderNotificationRuleReplacement {
    /** Item type this rule is defined for. */
    ItemType: ApiItemType;
}

/** Contains the notification templates of a specific project togehter with some meta information. */
export interface ApiProjectNotificationTemplates {
    /** The project for which this part of the project configuration (the
notification templates) was requested. */
    Project: ApiProjectIdName | undefined;
    /** Indicates whether the project configuration is shared with
a different project. */
    IsShared: boolean;
    /** Indicates whether the project configuration is owned by the
project for which this part of the configuration was requested. */
    IsOwned: boolean;
    /** The project which owns the project configuration. When the project
configuration is shared, the project configuration might not be owned by the project for
which this part of the project configuration was requested. This info can be null if you
are not allowed to access the owning project. */
    OwningProject: ApiProjectIdName | undefined;
    /** The notification templates. */
    Templates: ApiProjectNotificationTemplate[] | undefined;
}

/** Represents a single notification template in a project */
export interface ApiProjectNotificationTemplate {
    /** Subject line pattern  */
    Subject: string | undefined;
    /** Email body pattern (html) */
    Body: string | undefined;
    /** Language of this template (to be used for expanding values like e.g. item type).
It is expected that all templates in a project are configured with same language. 
Accepted values are "en-GB" and "de-DE". */
    CultureName: string | undefined;
    /** Id of this notification template.  */
    Id: number;
    /** Specifies the type of the notification */
    Type: ApiProjectNotificationType;
    /** Specifies maximum length of item's name when included in Subject line. 
If actual name is longer than this value then it is cut off with "..." */
    MaxNameLength: number;
}

/** The type of notification. This enum has the following values:  - `BaseObjectChangedProperties` Any change of base object property.  - `BaseObjectChangedStatus` Base object's status field has changed  - `BaseObjectCreated` Base object has been created.  - `BaseObjectDeleted` Base object has been deleted.  - `BaseObjectMoved` Base object has been moved between folders. */
export enum ApiProjectNotificationType {
    BaseObjectChangedProperties = "BaseObjectChangedProperties",
    BaseObjectChangedStatus = "BaseObjectChangedStatus",
    BaseObjectCreated = "BaseObjectCreated",
    BaseObjectMoved = "BaseObjectMoved",
    BaseObjectDeleted = "BaseObjectDeleted",
}

/** Represents report options. */
export interface ApiReportOptions {
    /** The report's name. */
    Name: string | undefined;
    /** The report's color. */
    Color: string | undefined;
    /** Code of report plugin to nbe used (if any) */
    PluginCode: string | undefined;
    /** List of allowed options. */
    AllowedOptions: ApiBaseObjectReportAllowedOptions[] | undefined;
    /** Report parameters (if any defined). */
    Parameters: ApiReportParameter[] | undefined;
}

/** Represents the report allowed options. Please note this model represent options as set by user when editing report options. Please do not confuse with so called "actual" report options, used when user generates the report. The main difference is that allowed options contain three-state values: always/user decides/never whilst actual options contain the actual selection: true/false. */
export interface ApiBaseObjectReportAllowedOptions {
    /** Option, include description. */
    IncludeDescription: ApiAllowedOption;
    /** Option, include pictures. */
    IncludePictures: ApiAllowedOption;
    /** Option, show details. */
    AllowToShowHideDetails: boolean;
    /** Option, include history. */
    IncludeHistory: ApiAllowedOption;
    /** Option, include attachments. */
    IncludeAttachments: ApiAllowedOption;
    /** Option, show related defects. */
    ShowRelatedDefects: ApiAllowedOption;
    /** Option, show related requirements. */
    ShowRelatedRequirements: ApiAllowedOption;
    /** Option, show related test cases. */
    ShowRelatedTestCases: ApiAllowedOption;
    /** Option, show related test scenarios. */
    ShowRelatedTestScenarios: ApiAllowedOption;
    /** Option, show related jira issues. */
    IncludeJiraItems: ApiAllowedOption;
    /** The type of the item. */
    ItemType: ApiItemType;
    /** The path of the options. */
    Path: ApiItemType[] | undefined;
    /** The filter. */
    Filter: ApiFilter | undefined;
    /** Indicates whether current user is able to see data on this level.  */
    DataAllowed: ApiPermissionResult;
}

/** Represents possible values for the report option. This enum has the following values:  - `AlwaysFalse` Always false.  - `AlwaysTrue` Always true.  - `AskUser` Ask user. */
export enum ApiAllowedOption {
    AskUser = "AskUser",
    AlwaysTrue = "AlwaysTrue",
    AlwaysFalse = "AlwaysFalse",
}

/** Represents the filter. */
export interface ApiFilter {
    /** The Expression of the filter. */
    Expression: any | undefined;
    /** The human readable text of the expression. */
    DisplayText: string | undefined;
}

/** Represents a value of report parameter. */
export interface ApiReportParameterValue {
    /** Internal name of the parameter (key) */
    Name: string | undefined;
    /** Value of this parameter (depends on Type). 
When loading report options this value represents default value.  */
    Value: any | undefined;
}

/** Represents a report parameter. */
export interface ApiReportParameter extends ApiReportParameterValue {
    /** Parameter description  */
    Description: string | undefined;
    /** Type of the parameter */
    Type: ApiReportParameterType;
    /** Indicates whether parameter should is visible for end users */
    Visible: boolean;
    /** Indicates whether parameter is multi-value i.e. the value is an array of values instead of single one */
    MultiValue: boolean;
}

/** Report parameter types This enum has the following values:  - `Boolean` Boolean  - `Date` Date  - `Guid` Guid  - `Number16` Short number (16 bit)  - `Number32` Number (32 bit)  - `Number64` Long number (64 bit)  - `NumberDecimal` Decimal number  - `NumberDouble` Double floating number  - `NumberFloat` Floating number  - `String` String */
export enum ApiReportParameterType {
    String = "String",
    Date = "Date",
    Number16 = "Number16",
    Number32 = "Number32",
    Number64 = "Number64",
    NumberFloat = "NumberFloat",
    NumberDouble = "NumberDouble",
    NumberDecimal = "NumberDecimal",
    Boolean = "Boolean",
    Guid = "Guid",
}

/** Represent the report to be created. Note: the report layout is not included here (report is created with default layout). */
export interface ApiReportCreateRequest {
    /** Id of the project where report should be created. */
    ProjectId: number;
    /** Report options. */
    Options: ApiReportOptionsNew;
}

/** Represents new report options. */
export interface ApiReportOptionsNew {
    /** The report's name. */
    Name: string;
    /** The report's color.
Allowed are only predefined colors, for more information see: [Get predefined colors](#operation/System_GetColors). */
    Color: string;
    /** Code of report plugin to be used (if any). */
    PluginCode: string | undefined;
    /** List of allowed options. */
    AllowedOptions: ApiBaseObjectReportAllowedOptionsUpdate[];
}

/** Represents the update information for base report allowed options. Please note this model represent options as set by user when editing report options. Please do not confuse with so called "actual" report options, used when user generates the report. The main difference is that allowed options contain three-state values: always/user decides/never whilst actual options contain the actual selection: true/false. */
export interface ApiBaseObjectReportAllowedOptionsUpdate {
    /** Option, include description. */
    IncludeDescription: ApiAllowedOption;
    /** Option, include pictures. */
    IncludePictures: ApiAllowedOption;
    /** Option, show details. */
    AllowToShowHideDetails: boolean;
    /** Option, include history. */
    IncludeHistory: ApiAllowedOption;
    /** Option, include attachments. */
    IncludeAttachments: ApiAllowedOption;
    /** Option, show related defects. */
    ShowRelatedDefects: ApiAllowedOption;
    /** Option, show related requirements. */
    ShowRelatedRequirements: ApiAllowedOption;
    /** Option, show related test cases. */
    ShowRelatedTestCases: ApiAllowedOption;
    /** Option, show related test scenarios. */
    ShowRelatedTestScenarios: ApiAllowedOption;
    /** Option, show related jira issues. */
    IncludeJiraItems: ApiAllowedOption;
    /** The path of the options. */
    Path: ApiItemType[] | undefined;
    /** The updated filter. */
    Filter: ApiFilterUpdate | undefined;
    ItemType: string;
}

/** Represents the defect allowed options update. */
export interface ApiDefectReportAllowedOptionsUpdate extends ApiBaseObjectReportAllowedOptionsUpdate {
    /** Option, include related executions. */
    IncludeRelatedExecutions: ApiAllowedOption;
}

/** Represents the requirement allowed options update. */
export interface ApiRequirementReportAllowedOptionsUpdate extends ApiBaseObjectReportAllowedOptionsUpdate {
}

/** Represents the test case allowed options update. */
export interface ApiTestCaseReportAllowedOptionsUpdate extends ApiBaseObjectReportAllowedOptionsUpdate {
    /** Option, include test steps. */
    IncludeTestSteps: ApiAllowedOption;
    /** Option, include executions. */
    IncludeExecutions: ApiAllowedOption;
    /** Option, include test data. */
    IncludeTestData: ApiAllowedOption;
}

/** Represents the test scenario allowed options update. */
export interface ApiTestScenarioReportAllowedOptionsUpdate extends ApiBaseObjectReportAllowedOptionsUpdate {
    /** Option, include test jobs. */
    IncludeTestJobs: ApiAllowedOption;
    /** Option, include executions. */
    IncludeExecutions: ApiAllowedOption;
}

/** Represent the response for the report definition patch collection operation. */
export interface ApiReportDefinitionPatchCollectionResponse {
}

/** Represents data required to execute report definition-modify collection operation. There are multiple project modify operations supported - see ApiReportDefinitionPatchCollectionTypes. Depending on the type the actual properties can differ. See subclasses for details. */
export interface ApiReportDefinitionPatchCollectionOperation {
    PatchOperation: string;
}

/** Represent the necessary information to copy a report definition. */
export interface ApiReportDefinitionPatchCopyCollectionOperation extends ApiReportDefinitionPatchCollectionOperation {
    /** The id of the report definition. */
    ReportDefinitionId: number;
    /** The id of the target project. */
    TargetProjectId: number;
    /** The new name for the report definition, if empty the old name will be kept. */
    NewName: string | undefined;
}

/** Represents updated report options. */
export interface ApiReportOptionsUpdate {
    /** The report's name. */
    Name: string | undefined;
    /** The report's color.
Allowed are only predefined colors, for more information see: [Get predefined colors](#operation/System_GetColors). */
    Color: string | undefined;
    /** Code of report plugin to be used (if any). */
    PluginCode: string | undefined;
    /** List of allowed options. Include options for all desired object types. 
Object types not found will be removed from report. */
    AllowedOptions: ApiBaseObjectReportAllowedOptionsUpdate[] | undefined;
}

/** Represents the patch request for report definition. */
export interface ApiReportDefinitionPatchRequest {
    PatchType: string;
}

/** Represent the report definition publish request. */
export interface ApiReportDefinitionPatchPublish extends ApiReportDefinitionPatchRequest {
}

/** Represent the report definition unpublish request. */
export interface ApiReportDefinitionPatchUnpublish extends ApiReportDefinitionPatchRequest {
}

/** Contains data required to generate a report printout. */
export interface ApiReportPrintoutRequest {
    /** ID of the report to generate. */
    ReportId: number;
    /** Id of the project where data (and report is located). */
    ProjectId: number;
    /** Id of the folder (zero means root folder). */
    FolderId: number;
    /** If true, the report contains includes data from selected folder and all folders below.
If false generated report contains data only from selected folder. */
    Recursive: boolean;
    /** Flat list of report options for corresponding levels (level is identified by Path property).
Depending on item type the list of options varies (see subclasses of ApiBaseObjectReportOptions). */
    ReportOptions: ApiBaseObjectReportOptions[];
    /** If true the report includes archived data as well. */
    IncludeArchived: boolean;
    /** Can be null. If not null then contains list of "related projects" (project sharing the same template
as "main" project, specified in ProjectId) to fetch data from. Please note it make no sense
to use FolderId other than zero in case when RelatedProjects are specified. */
    RelatedProjects: number[] | undefined;
    /** Actual value for report parameters. */
    ParameterValues: ApiReportParameterValue[] | undefined;
}

/** Contains data required to generate (and download) a report printout as a file. */
export interface ApiReportPrintoutRequestFile extends ApiReportPrintoutRequest {
    /** Type of report file to be generated. */
    FileType: ApiReportFileType;
}

/** Type of exported report file. This enum has the following values:  - `Csv` CSV file.  - `Docx` DOCX file.  - `Html` HTML file.  - `Image` Image file.  - `Mht` MHT file.  - `Pdf` PDF file.  - `Rtf` RTF file.  - `Text` Text file.  - `Xls` XLS file.  - `Xlsx` XLSX file. */
export enum ApiReportFileType {
    Pdf = "Pdf",
    Html = "Html",
    Mht = "Mht",
    Rtf = "Rtf",
    Xls = "Xls",
    Xlsx = "Xlsx",
    Csv = "Csv",
    Text = "Text",
    Image = "Image",
    Docx = "Docx",
}

/** Contains options affecting report generation on a given level (see Path property). Please note this model represent options as set by user during report generation. Please do not confuse with so called "allowed" report options (the main difference is that allowed options contain three-state values: always/user decides/never whilst actual options contain the actual selection: true/false). */
export interface ApiBaseObjectReportOptions {
    /** The path of the options. */
    Path: ApiItemType[] | undefined;
    /** The filter. */
    Filter: ApiFilterUpdate | undefined;
    /** Option, include description. */
    IncludeDescription: boolean;
    /** Option, include pictures. */
    IncludePictures: boolean;
    /** Option, show details. */
    ShowDetails: boolean;
    /** Option, include history. */
    IncludeHistory: boolean;
    /** Option, include attachments. */
    IncludeAttachments: boolean;
    /** Option, include attachments. */
    IncludeJiraItems: boolean;
    /** Option, show related defects. */
    ShowRelatedDefects: boolean;
    /** Option, show related requirements. */
    ShowRelatedRequirements: boolean;
    /** Option, show related test cases. */
    ShowRelatedTestCases: boolean;
    /** Option, show related test scenarios. */
    ShowRelatedTestScenarios: boolean;
    ItemType: string;
}

/** A type-specific version of report options affecting report generation on a given level. */
export interface ApiDefectReportOptions extends ApiBaseObjectReportOptions {
    /** Option, include related executions. */
    IncludeRelatedExecutions: boolean;
}

/** A type-specific version of report options affecting report generation on a given level. */
export interface ApiRequirementReportOptions extends ApiBaseObjectReportOptions {
}

/** A type-specific version of report options affecting report generation on a given level. */
export interface ApiTestCaseReportOptions extends ApiBaseObjectReportOptions {
    /** Option, include test steps. */
    IncludeTestSteps: boolean;
    /** Option, include executions. */
    IncludeExecutions: boolean;
    /** Option, include test data. */
    IncludeTestData: boolean;
}

/** A type-specific version of report options affecting report generation on a given level. */
export interface ApiTestScenarioReportOptions extends ApiBaseObjectReportOptions {
    /** Option, include test jobs. */
    IncludeTestJobs: boolean;
    /** Option, include executions. */
    IncludeExecutions: boolean;
}

export interface ApiReportPrintoutRequestPdf extends ApiReportPrintoutRequestFile {
    /** Pdf specific options for the printout */
    PdfOptions: ApiReportPdfPrintoutOptions | undefined;
}

export interface ApiReportPdfPrintoutOptions {
    /** The page range to be exported. Ranges are comma separated. e.g. “1,4,7-10”.
Invalid page numbers are ignored, if all page numbers are invalid, all pages are exported. */
    PageRange: string | undefined;
    /** The resolution (in DPI) used to rasterize vector images. */
    RasterizationResolution: number;
    /** When True, contained images will be converted to jpg. */
    ConvertImagesToJpeg: boolean;
    /** When true the print dialog is displayed on opening the pdf */
    ShowPrintDialogOnOpen: boolean;
    /** Semicolon delimited list of fonts never to embed in the pdf */
    NeverEmbeddedFonts: string | undefined;
    /** Specifies whether to convert editable fields to AcroForms fields on PDF export. */
    ExportEditingFieldsToAcroForms: boolean;
    /** the quality of images in the resulting PDF file. */
    ImageQuality: ApiPdfImageQuality;
    /** Document compatibility with the PDF/A specification */
    PdfACompatibility: ApiPdfACompatibility;
    /** PDF security options of the document, which require specifying a password. */
    PasswordSecurityOptions: ApiPdfPasswordSecurityOptions | undefined;
    /** Document Properties of the created PDF file */
    DocumentOptions: ApiReportPdfPrintoutDocumentOptions | undefined;
}

/** This enum has the following values:  - `High`  - `Highest`  - `Low`  - `Lowest`  - `Medium` */
export enum ApiPdfImageQuality {
    Lowest = "Lowest",
    Low = "Low",
    Medium = "Medium",
    High = "High",
    Highest = "Highest",
}

/** PDF/A compatibility mode of a document. This enum has the following values:  - `None` The document is not PDF/A-compatible and supports the ISO 32000-1:2005 specification.  - `PdfA1a` The document supports the PDF/A-1a (Accessible) specification and contains tags that assistive technologies can use.             - `PdfA1b` The document supports the PDF/A-1b (ISO 19005-1) specification.             - `PdfA2a` The document supports the PDF/A-2a (Accessible) specification and contains tags that assistive technologies can use.             - `PdfA2b` The document supports the PDF/A-2b (ISO 19005-2:2011) specification.             - `PdfA3a` The document supports the PDF/A-3a (Accessible) specification and contains tags that assistive technologies can use.             - `PdfA3b` The document supports the PDF/A-3b (ISO 19005-3:2012) specification. */
export enum ApiPdfACompatibility {
    None = "None",
    PdfA1a = "PdfA1a",
    PdfA1b = "PdfA1b",
    PdfA2a = "PdfA2a",
    PdfA2b = "PdfA2b",
    PdfA3a = "PdfA3a",
    PdfA3b = "PdfA3b",
}

export interface ApiPdfPasswordSecurityOptions {
    /** password for opening the exported PDF document. */
    OpenPassword: string | undefined;
    /** The algorithm used to encrypt PDF content. */
    EncryptionLevel: PdfEncryptionLevel;
    /** the PDF permissions password for the document. */
    PermissionsPassword: string | undefined;
    /** Provides access to the PDF permission options of the document. */
    PermissionsOptions: ApiPdfPermissionsOptions | undefined;
}

/** This enum has the following values:  - `AES128`  - `AES256`  - `ARC4` */
export enum PdfEncryptionLevel {
    AES128 = "AES128",
    AES256 = "AES256",
    ARC4 = "ARC4",
}

export interface ApiPdfPermissionsOptions {
    /** Permissions for changing the exported PDF document */
    ChangingPermissions: ApiPdfChangingPermissions;
    /** Permissions for printing the exported PDF document */
    PrintingPermissions: ApiPdfPrintingPermissions;
    /** Permissions for screen readers access to the exported PDF document */
    EnableScreenReaders: boolean;
    /** Permissions for copying the content of the exported PDF document. */
    EnableCopying: boolean;
}

/** This enum has the following values:  - `AnyExceptExtractingPages` Permits any changes for the PDF document, except extracting its pages.  - `CommentingFillingSigning` Permits commenting, filling in form fields, and signing existing signature fields for the PDF document.  - `FillingSigning` Permits filling in form fields and signing existing signature fields for the PDF document.  - `InsertingDeletingRotating` Permits inserting, deleting and rotating the PDF document’s pages.  - `None` No changes are permitted to the PDF document. */
export enum ApiPdfChangingPermissions {
    None = "None",
    InsertingDeletingRotating = "InsertingDeletingRotating",
    FillingSigning = "FillingSigning",
    CommentingFillingSigning = "CommentingFillingSigning",
    AnyExceptExtractingPages = "AnyExceptExtractingPages",
}

/** This enum has the following values:  - `HighResolution` Permits the PDF document’s printing in high resolution only  - `LowResolution` Permits the PDF document’s printing in low resolution only (150 dpi)  - `None` Forbids printing of the PDF document */
export enum ApiPdfPrintingPermissions {
    None = "None",
    LowResolution = "LowResolution",
    HighResolution = "HighResolution",
}

export interface ApiReportPdfPrintoutDocumentOptions {
    /** Author property of the resulting document */
    Author: string | undefined;
    /** Application property of the resulting document */
    Application: string | undefined;
    /** Title property of the resulting document */
    Title: string | undefined;
    /** Subject property of the resulting document */
    Subject: string | undefined;
    /** Keywords property of the resulting document */
    Keywords: string | undefined;
}

export interface ApiReportPrintoutRequestHtml extends ApiReportPrintoutRequestFile {
    /** Html specific options for the printout */
    HtmlOptions: ApiReportHtmlPrintoutOptions | undefined;
}

export interface ApiReportHtmlPrintoutOptions {
    /** Specifies whether the source is exported as a single page or pages seperated by page borders.  */
    ExportMode: ApiReportPrintoutExportMode;
    /** The page range to be exported. Ranges are comma separated. e.g. “1,4,7-10”.
Invalid page numbers are ignored, if all page numbers are invalid, all pages are exported. */
    PageRange: string | undefined;
    /** The resolution (in DPI) used to rasterize vector images. */
    RasterizationResolution: number;
    /** Color to be used (optional). HEX RGB string e.g. "0xffaabc" */
    PageBorderColor: string | undefined;
    /** Width (in pixels) of page borders when a document is exported to HTML page-by-page. */
    PageBorderWidth: number;
    /** Title of the created HTML file */
    Title: string | undefined;
    /** Determines whether to use the table or non-table layout in the resulting HTML file. */
    TableLayout: boolean;
    /** Specifies whether or not the document navigation is implemented by using scripts. */
    UseHRefHyperlinks: boolean;
    /** Specifies whether the JavaScript code can be placed in URLs in the resulting HTML document. */
    AllowJSURLs: boolean;
    /** Specifies Gets or sets a value indicating whether secondary symbols should be removed from the resulting HTML file, to reduce its size.  */
    RemoveSecondarySymbols: boolean;
    /** Specifies whether to export watermarks to HTML along with the rest of the document content. */
    ExportWatermarks: boolean;
    /** A String﻿ representing the encoding name set in the HTML file (e.g. "utf-8"). */
    CharacterSet: string | undefined;
}

/** This enum has the following values:  - `SingleFile`  - `SingleFilePageByPage` */
export enum ApiReportPrintoutExportMode {
    SingleFile = "SingleFile",
    SingleFilePageByPage = "SingleFilePageByPage",
}

export interface ApiReportPrintoutRequestMht extends ApiReportPrintoutRequestFile {
    /** Mht specific options for the printout */
    MhtOptions: ApiReportMhtPrintoutOptions | undefined;
}

export interface ApiReportMhtPrintoutOptions extends ApiReportHtmlPrintoutOptions {
}

export interface ApiReportPrintoutRequestRtf extends ApiReportPrintoutRequestFile {
    /** Rtf specific options for the printout */
    RtfOptions: ApiReportRtfPrintoutOptions | undefined;
}

export interface ApiReportRtfPrintoutOptions {
    /** Specifies whether the source is exported as a single page or pages seperated by page borders.  */
    ExportMode: ApiReportPrintoutExportMode;
    /** The page range to be exported. Ranges are comma separated. e.g. “1,4,7-10”.
Invalid page numbers are ignored, if all page numbers are invalid, all pages are exported. */
    PageRange: string | undefined;
    /** The resolution (in DPI) used to rasterize vector images. */
    RasterizationResolution: number;
    /** True if pagebreaks should be included in the export */
    ExportPageBreaks: boolean;
    /** True if watermarks should be included in the export */
    ExportWatermarks: boolean;
}

export interface ApiReportPrintoutRequestXls extends ApiReportPrintoutRequestFile {
    /** Xls specific options for the printout */
    XlsOptions: ApiReportXlsPrintoutOptions | undefined;
}

export interface ApiReportXlsxPrintoutOptions {
    /** Specifies whether the source is exported as a single worksheet or individual worksheets.  */
    ExportMode: ApiReportPrintoutExportMode;
    /** The page range to be exported. Ranges are comma separated. e.g. “1,4,7-10”.
Invalid page numbers are ignored, if all page numbers are invalid, all pages are exported. */
    PageRange: string | undefined;
    /** The resolution (in DPI) used to rasterize vector images. */
    RasterizationResolution: number;
    /** Whether the cells in the resulting execl document should use the same formatting as the original document */
    TextExportMode: ApiReportPrintoutTextExportMode;
    /** Whether hyperlinks should be exported */
    ExportHyperlinks: boolean;
    /** Enables the mode that produces simple tabular data without graphic elements, style and appearance settings. */
    RawDataMode: boolean;
    /** Name of the sheet in the created excel document */
    SheetName: string | undefined;
    /** Whether worksheet gridlines are visible */
    ShowGridLines: boolean;
    /** If vector images should be rasterized to the corresponding document format. */
    RasterizeImages: boolean;
    /** If the output document should be fit to the page width when printed.  */
    FitToPrintedPageWidth: boolean;
    /** If the output document should be fit to the page height when printed.  */
    FitToPrintedPageHeight: boolean;
    /** Lists the document errors that should be ignored by Excel. */
    IgnoreErrors: ApiXlsIgnoreErrors;
    /** If the layout of the resulting XLS document should be aligned to support locales using right-to-left fonts. */
    RightToLeftDocument: ApiReportPrintoutDefaultBoolean;
    /** XLS and XLSX file encryption options */
    EncryptionOptions: ApiReportXlPrintoutEncryptionOptions | undefined;
    /** XLS or XLSX file’s Document Properties. */
    DocumentOptions: ApiReportXlPrintoutDocumentOptions | undefined;
}

export interface ApiReportXlsPrintoutOptions extends ApiReportXlsxPrintoutOptions {
    /** Whether to suppress the exception that raises when trying to export a document to an XLS file with more than 256 columns.  */
    Suppress256ColumnsWarning: boolean;
    /** Whether to suppress the exception that raises when trying to export a document to an XLS file with more than 65536 rows. */
    Suppress65536RowsWarning: boolean;
    /** Specifies the color palette compatibility mode with different workbooks versions. */
    WorkbookColorPaletteCompliance: ApiReportWorkbookColorPaletteCompliance;
}

/** This enum has the following values:  - `AdjustColorsToDefaultPalette` Degrade the color values to match the 56 standard colors of the default workbook palette.  - `ReducePaletteForExactColors` Keep the original color values, but include only the first 56 colors into the palette. */
export enum ApiReportWorkbookColorPaletteCompliance {
    AdjustColorsToDefaultPalette = "AdjustColorsToDefaultPalette",
    ReducePaletteForExactColors = "ReducePaletteForExactColors",
}

/** This enum has the following values:  - `Text`  - `Value` */
export enum ApiReportPrintoutTextExportMode {
    Text = "Text",
    Value = "Value",
}

/** This enum has the following values:  - `None` No document errors are ignored in a resulting Excel file.  - `NumberStoredAsText` Values stored as text are ignored in a resulting Excel file. */
export enum ApiXlsIgnoreErrors {
    None = "None",
    NumberStoredAsText = "NumberStoredAsText",
}

/** This enum has the following values:  - `Default`  - `False`  - `True` */
export enum ApiReportPrintoutDefaultBoolean {
    True = "True",
    False = "False",
    Default = "Default",
}

export interface ApiReportXlPrintoutEncryptionOptions {
    /** Password to open the file */
    Password: string | undefined;
    /** Specifies the applied encryption mechanism. */
    Type: ApiReportXlsPrintoutEncryptionType;
}

/** This enum has the following values:  - `Compatible`  - `Strong` */
export enum ApiReportXlsPrintoutEncryptionType {
    Strong = "Strong",
    Compatible = "Compatible",
}

export interface ApiReportXlPrintoutDocumentOptions {
    /** Author property of the resulting excel file */
    Author: string | undefined;
    /** Application property of the resulting excel file */
    Application: string | undefined;
    /** Title property of the resulting excel file */
    Title: string | undefined;
    /** Subject property of the resulting excel file */
    Subject: string | undefined;
    /** Tags property of the resulting excel file */
    Tags: string | undefined;
    /** Category property of the resulting excel file */
    Category: string | undefined;
    /** Comments property of the resulting excel file */
    Comments: string | undefined;
    /** Company property of the resulting excel file */
    Company: string | undefined;
}

export interface ApiReportPrintoutRequestXlsx extends ApiReportPrintoutRequestFile {
    /** Xlsx specific options for the printout */
    XlsxOptions: ApiReportXlsxPrintoutOptions | undefined;
}

export interface ApiReportPrintoutRequestCsv extends ApiReportPrintoutRequestFile {
    /** Csv specific options for the printout */
    CsvOptions: ApiReportCsvPrintoutOptions | undefined;
}

export interface ApiReportTextPrintoutOptions {
    /** Encoding to be used in printout  */
    Encoding: string | undefined;
    /** Use the formatting of the data fields in the bound dataset for the cells in the exported document. */
    TextExportMode: ApiReportPrintoutTextExportMode;
    /** If a string should be quoted when it contains the seperator */
    QuoteStrings: boolean;
    /** The character(s) used to separate elements */
    Seperator: string | undefined;
}

export interface ApiReportCsvPrintoutOptions extends ApiReportTextPrintoutOptions {
    /** If empty rows should be skipped */
    SkipEmptyRows: boolean;
    /** If empty columns should be skipped */
    SkipEmptyColumns: boolean;
}

export interface ApiReportPrintoutRequestText extends ApiReportPrintoutRequestFile {
    /** Text specific options for the printout */
    TextOptions: ApiReportTextPrintoutOptions | undefined;
}

export interface ApiReportPrintoutRequestImage extends ApiReportPrintoutRequestFile {
    /** Image specific options for the printout */
    ImageOptions: ApiReportImagePrintoutOptions | undefined;
}

export interface ApiReportImagePrintoutOptions {
    /** Specifies whether the source is exported as a single image or individiual pages with borders drawn around them.  */
    ExportMode: ApiReportPrintoutExportMode;
    /** The page range to be exported. Ranges are comma separated. e.g. “1,4,7-10”.
Invalid page numbers are ignored, if all page numbers are invalid, all pages are exported. */
    PageRange: string | undefined;
    /** The resolution (in DPI)  */
    Resolution: number;
    /** Color to be used (optional). HEX RGB string e.g. "0xffaabc" */
    PageBorderColor: string | undefined;
    /** Width (in pixels) of page borders when a document is exported to HTML page-by-page. */
    PageBorderWidth: number;
    /** The target image format for the export */
    Format: ApiReportPrintoutExportImageType;
}

/** This enum has the following values:  - `gif`  - `jpeg`  - `png` */
export enum ApiReportPrintoutExportImageType {
    Jpeg = "jpeg",
    Png = "png",
    Gif = "gif",
}

export interface ApiReportPrintoutRequestDocx extends ApiReportPrintoutRequestFile {
    /** Docx specific options for the printout */
    DocxOptions: ApiReportDocxPrintoutOptions | undefined;
}

export interface ApiReportDocxPrintoutOptions extends ApiReportRtfPrintoutOptions {
    /** Whether to use the table or frame layout in the resulting DOCX file. */
    TableLayout: boolean;
    /** The exported document’s options */
    DocumentOptions: ApiReportDocxPrintoutDocumentOptions | undefined;
    /** If vector images should be rasterized to the corresponding document format. */
    RasterizeImages: boolean;
    /** Whether the height of table rows in a resulting document should have fixed values, or adding a new line of text to a cell’s content should increase the row height. */
    KeepRowHeight: boolean;
}

export interface ApiReportDocxPrintoutDocumentOptions {
    /** Author property of the resulting document */
    Author: string | undefined;
    /** Title property of the resulting document */
    Title: string | undefined;
    /** Subject property of the resulting document */
    Subject: string | undefined;
    /** Keywords property of the resulting document */
    Keywords: string | undefined;
    /** Category property of the resulting document */
    Category: string | undefined;
    /** Comments property of the resulting document */
    Comments: string | undefined;
}

/** Edit status information */
export interface ApiEditStatus {
    /** This field provides information about item version. */
    Version: number;
    /** This field provides information about the item editibale status and if item is locked, about a lock user. */
    EditableInfo: ApiEditableInfo | undefined;
}

/** Represents an item with a rich text description. */
export interface ApiItemWithDescription extends ApiItem {
    /** Contains the description of the item in different formats. */
    Description: ApiRichText | undefined;
}

export interface ApiRequirement extends ApiItemWithDescription {
    /** True if requirement has any sub requirements.  */
    HasSubRequirements: boolean;
}

/** Specifies the changes to perform on a specific item including its description. */
export interface ApiItemUpdateWithDescription extends ApiItemUpdate {
    /** The new description of the item. You must specify exactly one type
of description. */
    Description: ApiRichText | undefined;
}

/** Contains the necessary data to create a new item including its description. */
export interface ApiItemNewWithDescription extends ApiItemNew {
    /** The new description of the item. You must specify exactly one type
of description. */
    Description: ApiRichText | undefined;
}

/** A sub requirement is a child of another requirement. This class contains basic information for the sub requirement. */
export interface ApiSubrequirement {
    /** The id of the sub requirement. */
    Id: number;
    /** Further information on the requirement which is attached as a sub
requirement. Location and version are currently not provided. */
    Item: ApiItemInfo | undefined;
    /** The id of the parent of this sub requirement. */
    ParentId: number;
    /** The index of this requirement in the list of sub requirements
of the parent requirement. */
    ChildIndex: number;
    /** This list contains the position of this sub requirement in each level
of the sub requirement tree of the root requirement. E.g. [4,2]
means that this sub requirement is the 2nd sub requirement of the 4th
sub requirement of the root requirement.
This information is relative to the requirement for which the sub requirements
were requested. */
    Position: number[] | undefined;
    /** The number of sub requirements of the current sub requirement. */
    FurtherSubrequirementsCount: number;
    /** The edit status of the current sub requirement. Null means that no information
regarding the edit status is provided. This sub requirement should not
be edited based this information. */
    EditableStatus: ApiEditableStatus | undefined;
}

export interface ApiSubrequirementsUpdate {
    Subrequirements: ApiSubrequirement[] | undefined;
}

/** Contains a list of sub requirements which should be added to the specified the requirement in a single operation. */
export interface ApiSubrequirementsNew {
    /** The sub requirements which should be added */
    Subrequirements: ApiSubrequirementNew[] | undefined;
}

/** The information necessary to create a new sub requirement. */
export interface ApiSubrequirementNew {
    /** The id of the requirement which become the new sub requirement. */
    Id: number;
}

/** The information to update in a given sub requirement. */
export interface ApiSubrequirementUpdate {
    /** The new child index of the sub requirement. */
    ChildIndex: number;
}

/** Contains all changes which were done to a requirement in one operation together with information on when and by whom the requirement has been changed. When no changes of a given type occurred, the corresponding field in this response will be missing. */
export interface ApiHistoryEntryRequirement extends ApiHistoryEntry {
    /** The list of changes to the sub requirements of this requirement. Only
adding or removing of sub requirements is recorded here. For changes
to the sub requirement itself, check the separate history of the
sub requirement. */
    Subrequirements: ApiHistorySubrequirements | undefined;
}

/** The list of changes to the sub requirements of a requirement. */
export interface ApiHistorySubrequirements {
    /** The list of names of the sub requirements which were added
to the requirement */
    Added: string[] | undefined;
    /** The list of names of the sub requirements which were removed
from the requirement */
    Removed: string[] | undefined;
    /** True is any subrequirements have been rearranged (i.e. changed their positions).  */
    Rearranged: boolean;
}

/** Represents a batch operation. A batch operation performs the same change on multiple items. */
export interface ApiBatchOperation {
    /** Specifies the type of the batch operation. */
    Type: ApiBatchOperationType;
    /** Specifies the items which should be modified with this batch operation. */
    Ids: number[] | undefined;
}

/** The type of batch operation. This enum has the following values:  - `Unlock` Remove any edit locks by the current user on the specified items. */
export enum ApiBatchOperationType {
    Unlock = "Unlock",
}

/** Provides information about the result of resetting a user's password */
export interface ApiResetPasswordResult {
    /** Result about resetting for users */
    IsSuccess: boolean;
    /** Info about resetting for users */
    Message: string | undefined;
}

/** Contains info about user who is resetting the password */
export interface ApiResetPasswordUser {
    /** User's email */
    Email: string | undefined;
    /** User's tenant */
    Tenant: string | undefined;
}

export interface ApiScript extends ApiItem {
}

/** Contains information regarding the currently logged in user. It contains additional information which is not always exposed for users. */
export interface ApiMyUserInfo extends ApiUserInfo {
    /** The id of the current customer. */
    CustomerId: number;
    /** Indicates whether this is the first login to aqua
by the current user. */
    IsFirstLogin: boolean;
    /** Indicates if the user is server administrator or not. */
    ServerAdministrator: boolean;
    /** The name of the tenant if the current user has one */
    TenantName: string | undefined;
    /** The hash required to securely retrieve LaunchDarkly user variations */
    SecureModeHash: string | undefined;
}

/** Contains some server wide settings which might be interesting for a client. */
export interface ApiSystemSettings {
    /** Certain strings like item names can be customized in aqua. These
customized strings can be found here. This is primarily used to
correctly localize UIs. */
    CustomizedStrings: ApiCustomizedStrings | undefined;
    /** Settings for the integration with the aqua wiki. */
    WikiLinksSettings: ApiWikiLinksSettings | undefined;
    /** Settings related to the aqua news. */
    NewsSettings: ApiNewsSettings | undefined;
    /** The name of this aqua server. Each aqua server can be configured
to have a dedicated server name. */
    ServerIdentity: string | undefined;
    /** The version of aqua which this server is running. */
    SoftwareVersion: string | undefined;
    /** The maximum file size in bytes which is allowed for item attachments */
    AttachmentMaxFileSize: number;
    /** The maximum file size in bytes which is allowed for item attachments
when the attachment is uploaded using an upload URL. */
    AttachmentMaxFileSizeForUploadUrl: number;
    /** The maximum number of test jobs which might be contained in a
single test scenario. */
    TestJobsInTestScenarioMaxCount: number;
    /** If true, indicates that the aqua installation is running in enterprise mode. */
    IsEnterpriseModeOn: boolean;
    /** If true, indicates that the aqua is running in ocean mode. */
    OceanModeOn: boolean;
    /** The maximum file size in bytes which is allowed for screenshot. */
    ScreenShotMaxFileSize: number;
    /** If true, indicates that client should use new UI features of current release */
    EnableNewUI: boolean;
    /** Contains a comma-separated list of accepted file extensions. Sample ".png,.jpg,.png". 
If string is empty, all files will be accepted. */
    AllowedAttachmentFileExtensions: string | undefined;
    /** Indicates whether the execution time for manual test executions is tracked
and the stop watch in FormRunTestJob is enabled.
             */
    EnableStopWatchForManualExecutions: boolean;
    /** - */
    WL: string | undefined;
    /** Defines the maximum number of attached labels allowed on a single object. */
    MaximumNumberOfAttachedLabels: number;
    /** Whether or not the internal authentication in enabled in aqua. */
    AllowInternalUserAuthentication: boolean;
}

/** Contains the string which are customized for each server. This is primarily the case for item names which can be customized for each server. */
export interface ApiCustomizedStrings {
    /** Customized strings which should be used for the German localization. */
    German: { [key: string]: string; } | undefined;
    /** Customized strings which should be used for the English localization. */
    English: { [key: string]: string; } | undefined;
}

/** Contains the necessary settings to create links to the aqua wiki. */
export interface ApiWikiLinksSettings {
    /** Contains the base URL of the wiki for the different
locales (e.g. en or de). */
    BaseUrls: { [key: string]: string; } | undefined;
}

/** Contains settings related to the aqua news. */
export interface ApiNewsSettings {
    /** The URL of the news page for aqua. */
    Url: string | undefined;
}

export interface GenericPermissionInfo {
    Title: string | undefined;
    GenericPermissionName: string | undefined;
    Group: string | undefined;
    PermissionAll: Permission;
    PermissionAssigned: Permission | undefined;
    PermissionOwned: Permission | undefined;
    Scope: PermissionScope;
    AllowedFolderLevel: boolean;
    RequiredAll: string[] | undefined;
    RequiredAny: string[] | undefined;
    LoginClientType: AquaClientType | undefined;
    LicenseOnly: boolean;
    PermisionVariants: PermissionVariant[] | undefined;
}

export enum Permission {
    RQViewContentAll = 1010,
    RQViewDiscussionsAll = 1040,
    RQViewWordExportAll = 1050,
    RQViewWordExportAssigned = 1051,
    RQViewWordExportOwn = 1052,
    RQCreateEditFieldsDescriptionAll = 1110,
    RQCreateEditCommentsAll = 1130,
    RQCreateWordImportAll = 1140,
    RQEditStatusAll = 1210,
    RQEditStatusAssigned = 1211,
    RQEditStatusOwn = 1212,
    RQEditFieldsAll = 1220,
    RQEditFieldsAssigned = 1221,
    RQEditFieldsOwn = 1222,
    RQEditDescriptionAll = 1230,
    RQEditDescriptionAssigned = 1231,
    RQEditDescriptionOwn = 1232,
    RQEditCommentsAll = 1240,
    RQEditCommentsAssigned = 1241,
    RQEditCommentsOwn = 1242,
    RQEditWordImportAll = 1270,
    RQEditWordImportAssigned = 1271,
    RQEditWordImportOwn = 1272,
    RQEditBatchAll = 1280,
    RQDeleteAll = 1310,
    RQDeleteAssigned = 1311,
    RQDeleteOwn = 1312,
    RQMoveInProjectAll = 1410,
    RQMoveInProjectAssigned = 1411,
    RQMoveInProjectOwn = 1412,
    RQMoveBetweenProjectsAll = 1420,
    RQMoveBetweenProjectsAssigned = 1421,
    RQMoveBetweenProjectsOwn = 1422,
    RQCreateDependencyAll = 1510,
    RQDeleteDependencyAll = 1520,
    DFViewContentAll = 2010,
    DFCreateAll = 2110,
    DFEditAll = 2210,
    DFEditAssigned = 2211,
    DFEditOwn = 2212,
    DFEditEnclosuresAll = 2220,
    DFEditEnclosuresOwn = 2222,
    DFDeleteAll = 2310,
    DFDeleteAssigned = 2311,
    DFDeleteOwn = 2312,
    DFDeleteEnclosuresAll = 2320,
    DFDeleteEnclosuresOwn = 2322,
    DFEditBatchAll = 2410,
    DFMoveInProjectAll = 2510,
    DFMoveInProjectAssigned = 2511,
    DFMoveInProjectOwn = 2512,
    DFMoveBetweenProjectsAll = 2520,
    DFMoveBetweenProjectsAssigned = 2521,
    DFMoveBetweenProjectsOwn = 2522,
    DFCreateDependencyAll = 2610,
    DFDeleteDependencyAll = 2620,
    TCViewContentAll = 3010,
    TCCreateEditFieldsDescriptionAll = 3110,
    TCCreateEditVariablesAll = 3120,
    TCCreateEditNestingAll = 3130,
    TCCreateEditTestAutomationAll = 3140,
    TCEditStatusAll = 3210,
    TCEditStatusAssigned = 3211,
    TCEditStatusOwn = 3212,
    TCEditFieldDescriptionAll = 3220,
    TCEditFieldDescriptionAssigned = 3221,
    TCEditFieldDescriptionOwn = 3222,
    TCEditStepsAll = 3230,
    TCEditStepsAssigned = 3231,
    TCEditStepsOwn = 3232,
    TCEditVariablesAll = 3240,
    TCEditVariablesAssigned = 3241,
    TCEditVariablesOwn = 3242,
    TCEditNestingAll = 3250,
    TCEditNestingAssigned = 3251,
    TCEditNestingOwn = 3252,
    TCEditTestAutomationAll = 3260,
    TCEditTestAutomationAssigned = 3261,
    TCEditTestAutomationOwn = 3262,
    TCEditBatchAll = 3270,
    TCDeleteAll = 3310,
    TCDeleteAssigned = 3311,
    TCDeleteOwn = 3312,
    TCMoveInProjectAll = 3410,
    TCMoveInProjectAssigned = 3411,
    TCMoveInProjectOwn = 3412,
    TCMoveBetweenProjectsAll = 3420,
    TCMoveBetweenProjectsAssigned = 3421,
    TCMoveBetweenProjectsOwn = 3422,
    TCCreateDependencyAll = 3510,
    TCDeleteDependencyAll = 3520,
    TSViewContentAll = 4010,
    TSCreateAll = 4110,
    TSEditAll = 4210,
    TSEditAssigned = 4211,
    TSEditOwn = 4212,
    TSDeleteAll = 4310,
    TSDeleteAssigned = 4311,
    TSDeleteOwn = 4312,
    TSEditBatchAll = 4410,
    TSMoveInProjectAll = 4510,
    TSMoveInProjectAssigned = 4511,
    TSMoveInProjectOwn = 4512,
    TSMoveBetweenProjectsAll = 4520,
    TSMoveBetweenProjectsAssigned = 4521,
    TSMoveBetweenProjectsOwn = 4522,
    TSCreateDependencyAll = 4610,
    TSDeleteDependencyAll = 4620,
    EXSchedulingAll = 5210,
    EXSchedulingAssigned = 5211,
    EXSchedulingOwn = 5212,
    EXTCManualAll = 5310,
    EXTCAutomatedAll = 5320,
    EXTSManualAll = 5410,
    EXTSAutomatedAll = 5420,
    EXFinalizeAll = 5510,
    EXSetRelevanceAll = 5520,
    SCViewContentAll = 6010,
    SCCreateAll = 6110,
    SCEditAll = 6210,
    SCEditAssigned = 6211,
    SCEditOwn = 6212,
    SCDeleteAll = 6310,
    SCDeleteAssigned = 6311,
    SCDeleteOwn = 6312,
    SCEditBatchAll = 6410,
    SCMoveInProjectAll = 6510,
    SCMoveInProjectAssigned = 6511,
    SCMoveInProjectOwn = 6512,
    SCMoveBetweenProjectsAll = 6520,
    SCMoveBetweenProjectsAssigned = 6521,
    SCMoveBetweenProjectsOwn = 6522,
    SCCreateDependencyAll = 6610,
    SCDeleteDependencyAll = 6620,
    GEViewsPublishAll = 7010,
    GEViewsEditPublicAll = 7020,
    GEProjectEditTreeAll = 7110,
    GEProjectConfigureAll = 7120,
    GEProjectConfigureUsersAll = 7130,
    GEProjectConfigureSubtemplateAll = 7140,
    GEProjectViewAllUsersAll = 7150,
    GENotificationsAll = 7210,
    GEMindMapViewAll = 7310,
    GEMindMapCreateEditAll = 7320,
    GEAttachmentsViewOpenAll = 7410,
    GEAttachmentsAddAll = 7420,
    GEAttachmentsDeleteAll = 7430,
    GEExportItemAll = 7510,
    GEImportItemAll = 7520,
    PPViewContentAll = 8010,
    PPReportWorkAll = 8020,
    PPCreateEditDeleteItemsAll = 8030,
    PPShowEarnedValueAnalysisAll = 8040,
    DAViewAll = 9010,
    DAEditAll = 9020,
    DAChartPublishAll = 9030,
    DAChartEditPublicAll = 9040,
    AGViewAll = 10010,
    AGSprintCreateEditAll = 10020,
    AGSprintDeleteAll = 10030,
    AGSprintPlanningAll = 10040,
    RPUseAll = 11010,
    RPManageTemplatesAll = 11020,
    RPCreateTemplateEditLayoutAll = 11030,
    RPExportPDFAll = 11110,
    RPExportHTMLAll = 11120,
    RPExportMHTAll = 11130,
    RPExportRTFAll = 11140,
    RPExportXLSAll = 11150,
    RPExportXLSXAll = 11160,
    RPExportCSVAll = 11170,
    RPExportTextFileAll = 11180,
    RPExportImageFileAll = 11190,
    RPExportDOCAll = 11200,
    RPExportDOCXAll = 11210,
    RPExportODTAll = 11220,
    RPSignPDFAll = 11230,
    LoginRichClientAll = 50010,
    LoginWebAll = 50020,
    LoginOfflineAll = 50030,
    LoginApiAll = 50040,
    TranslateContentAll = 60010,
    EnterpriseSystemAll = 60020,
    GlobalConfigureRoles = 100010,
}

export enum PermissionScope {
    Project = 0,
    Global = 1,
}

export enum AquaClientType {
    Rich = 0,
    Offline = 1,
    Web = 2,
    API = 3,
}

export enum PermissionVariant {
    All = 0,
    Assigned = 1,
    Owned = 2,
}

/** Contains the response for get colors. */
export interface ApiSystemGetColorsResponse {
    /** List of predefined colors. */
    Colors: string[] | undefined;
}

/** Represents the role. */
export interface ApiRole extends ApiRoleIdName {
    /** The list of permissions of the role. */
    Permissions: ApiPermission[] | undefined;
    /** True if role is a default role, which means it can't be changed. */
    IsDefault: boolean;
}

/** Represention of possible permissions. This enum has the following values:  - `AGSprintCreateEditAll` Allows the user to create new sprints and edit existing ones.  - `AGSprintDeleteAll` Allows the user to delete sprints.  - `AGSprintPlanningAll` Allows the user to access the sprint planning.  - `AGViewAll` Allows the user to see the agile board.  - `DAChartEditPublicAll` Allows the user to change saved charts.  - `DAChartPublishAll` Allows the user to save charts in the chart gallery.  - `DAEditAll` Allows the user to add new charts or change visible charts.  - `DAViewAll` Allows the user to see the dashboard.  - `DFCreateAll` Allows the user to create new defects.  - `DFCreateDependencyAll` Allows to create new defect dependencies.  - `DFDeleteAll` Allows the user to delete all defects.  - `DFDeleteAssigned` Allows the user to delete assigned defects.  - `DFDeleteDependencyAll` Allows to delete existing defect dependencies.  - `DFDeleteEnclosuresAll` Allows the user to delete enclosures of all defects.  - `DFDeleteEnclosuresOwn` Allows the user to delete enclosures of own defects.  - `DFDeleteOwn` Allows the user to delete own defects.  - `DFEditAll` Allows the user to change all defects.  - `DFEditAssigned` Allows the user to change assigned defects.  - `DFEditBatchAll` Allows to batch change defects.  - `DFEditEnclosuresAll` Allows the user to add or change enclosures, for all defects.  - `DFEditEnclosuresOwn` Allows the user to add or change enclosures, for own defects.  - `DFEditOwn` Allows the user to change own defects.  - `DFMoveBetweenProjectsAll` Allows the user to move all defects between different projects.  - `DFMoveBetweenProjectsAssigned` Allows the user to move assigned defects between different projects.  - `DFMoveBetweenProjectsOwn` Allows the user to move own defects between different projects.  - `DFMoveInProjectAll` Allows the user to move all defects within one project.  - `DFMoveInProjectAssigned` Allows the user to move assigned defects within one project.  - `DFMoveInProjectOwn` Allows the user to move own defects within one project.  - `DFViewContentAll` Allows the user to open defects.  - `EXFinalizeAll` Allows the user to finalize an execution.  - `EXSchedulingAll` Allows the user to set up schedules for all regularly executed test scenarios.  - `EXSchedulingAssigned` Allows the user to set up schedules for assigned regularly executed test scenarios.  - `EXSchedulingOwn` Allows the user to set up schedules for own regularly executed test scenarios.  - `EXSetRelevanceAll` Allows the user to mark and unmark executions as (ir)relevant.  - `EXTCAutomatedAll` Allows the user to execute test cases which contain an automation.  - `EXTCManualAll` Allows the user to manually execute test cases.  - `EXTSAutomatedAll` Allows the user to execute test scenarios which contain an automation.  - `EXTSManualAll` Allows the user to manually execute test scenarios.  - `GEAttachmentsAddAll` Allows the user to add files.  - `GEAttachmentsDeleteAll` Allows the user to delete attachments.  - `GEAttachmentsViewOpenAll` Allows the user to open attached files.  - `GEExportItemAll` Allows to export items.  - `GEImportItemAll` Allows to import items.  - `GEMindMapCreateEditAll` Allows the user to edit and create Mind Maps.  - `GEMindMapViewAll` Allows the user to see Mind Maps.  - `GENotificationsAll` Allows the user to configure notifications and receive them.  - `GEProjectConfigureAll` Allows the user to add new projects and change configuration.  - `GEProjectConfigureSubtemplateAll` Allows the user to configure the sub template of a project.  - `GEProjectConfigureUsersAll` Allows the user to assign users to a project.  - `GEProjectEditTreeAll` Allows the user to add sub folders to a project.  - `GEProjectViewAllUsersAll` Allows the user to see all other users.  - `GEViewsEditPublicAll` Allows the user to change public filtered views in project gallery.  - `GEViewsPublishAll` Allows the user to publish saved filtered views in project gallery.  - `PPCreateEditDeleteItemsAll` Allows the user to create / edit / delete items in the project plan.  - `PPReportWorkAll` Allows the user to report work on items in the project plan.  - `PPShowEarnedValueAnalysisAll` Allows the user to see the earned value analysis of a project plan.  - `PPViewContentAll` Allows the user to open project plans.  - `RPCreateTemplateEditLayoutAll` Allows the user to create new reports and edit existing ones.  - `RPExportCSVAll` Allows the user to export reports to CSV format.  - `RPExportDOCAll` Allows the user to export reports to DOC format.  - `RPExportDOCXAll` Allows the user to export reports to DOCX format.  - `RPExportHTMLAll` Allows the user to export reports to HTML format.  - `RPExportImageFileAll` Allows the user to export reports to Image File.  - `RPExportMHTAll` Allows the user to export reports to MHT format.  - `RPExportODTAll` Allows the user to export reports to ODT format.  - `RPExportPDFAll` Allows the user to export reports to PDF format.  - `RPExportRTFAll` Allows the user to export reports to RTF format.  - `RPExportTextFileAll` Allows the user to export reports to Text File.  - `RPExportXLSAll` Allows the user to export reports to XLS format.  - `RPExportXLSXAll` Allows the user to export reports to XLSX format.  - `RPManageTemplatesAll` Allows to import/export report templates as well as to configure properties.  - `RPSignPDFAll` Allows the user to sign reports which are exported as PDF.  - `RPUseAll` Allows the user to see the reports.  - `RQCreateDependencyAll` Allows to create new requirement dependencies.  - `RQCreateEditCommentsAll` Allows the user to create comments in the description of the requirement.  - `RQCreateEditFieldsDescriptionAll` Allows the user to create new requirements.  - `RQCreateWordImportAll` Allows the user to import requirements from word.  - `RQDeleteAll` Allows the user to delete all requirements.  - `RQDeleteAssigned` Allows the user to delete assigned requirements.  - `RQDeleteDependencyAll` Allows to delete existing requirement dependencies.  - `RQDeleteOwn` Allows the user to delete own requirements.  - `RQEditBatchAll` Allows to batch change requirements.  - `RQEditCommentsAll` Allows the user to edit existing comments, for all requirements.  - `RQEditCommentsAssigned` Allows the user to edit existing comments, for assigned requirements.  - `RQEditCommentsOwn` Allows the user to edit existing comments, for own requirements.  - `RQEditDescriptionAll` Allows the user to edit the description of a requirement, for all requirements.  - `RQEditDescriptionAssigned` Allows the user to edit the description of a requirement, for assigned requirements.  - `RQEditDescriptionOwn` Allows the user to edit the description of a requirement, for own requirements.  - `RQEditFieldsAll` Allows the user to edit fields in the metadata, for all requirements.  - `RQEditFieldsAssigned` Allows the user to edit fields in the metadata, for assigned requirements.  - `RQEditFieldsOwn` Allows the user to edit fields in the metadata, for own requirements.  - `RQEditStatusAll` Allows the user to change the status of a requirement, for all requirements.  - `RQEditStatusAssigned` Allows the user to change the status of a requirement, for assigned requirements.  - `RQEditStatusOwn` Allows the user to change the status of a requirement, for own requirements.  - `RQEditWordImportAll` Allows to import a description from a Word-File, for all requirements.  - `RQEditWordImportAssigned` Allows to import a description from a Word-File, for assigned requirements.  - `RQEditWordImportOwn` Allows to import a description from a Word-File, for own requirements.  - `RQMoveBetweenProjectsAll` Allows the user to move all requirements between different projects.  - `RQMoveBetweenProjectsAssigned` Allows the user to move assigned requirements between different projects.  - `RQMoveBetweenProjectsOwn` Allows the user to move own requirements between different projects.  - `RQMoveInProjectAll` Allows the user to move all requirements within one project.  - `RQMoveInProjectAssigned` Allows the user to move assigned requirements within one project.  - `RQMoveInProjectOwn` Allows the user to move own requirements within one project.  - `RQViewContentAll` Allows the user to open requirements.  - `RQViewDiscussionsAll` Allows the user to open UMLs, for all requirements.  - `RQViewWordExportAll` Allows the user to export all requirements to a Word document.  - `RQViewWordExportAssigned` Allows the user to export assigned requirements to a Word document.  - `RQViewWordExportOwn` Allows the user to export own requirements to a Word document.  - `SCCreateAll` Allows the user to create new scripts.  - `SCCreateDependencyAll` Allows to create new script dependencies.  - `SCDeleteAll` Allows the user to delete all scripts.  - `SCDeleteAssigned` Allows the user to delete assigned scripts.  - `SCDeleteDependencyAll` Allows to delete existing script dependencies.  - `SCDeleteOwn` Allows the user to delete own scripts.  - `SCEditAll` Allows the user to edit all scripts.  - `SCEditAssigned` Allows the user to edit assigned scripts.  - `SCEditBatchAll` Allows to batch change scripts.  - `SCEditOwn` Allows the user to edit own scripts.  - `SCMoveBetweenProjectsAll` Allows the user to move all scripts between different projects.  - `SCMoveBetweenProjectsAssigned` Allows the user to move assigned scripts between different projects.  - `SCMoveBetweenProjectsOwn` Allows the user to move own scripts between different projects.  - `SCMoveInProjectAll` Allows the user to move all scripts within one project.  - `SCMoveInProjectAssigned` Allows the user to move assigned scripts within one project.  - `SCMoveInProjectOwn` Allows the user to move own scripts within one project.  - `SCViewContentAll` Allows the user to open scripts.  - `TCCreateDependencyAll` Allows to create new test case dependencies.  - `TCCreateEditFieldsDescriptionAll` Allows the user to create new test case.  - `TCCreateEditNestingAll` Allows the user to nest a test case within a test step.  - `TCCreateEditTestAutomationAll` Allows the user to use the automation tab to add new scripts.  - `TCCreateEditVariablesAll` Allows the user to parameterize tests using the variable manager.  - `TCDeleteAll` Allows the user to delete all test cases.  - `TCDeleteAssigned` Allows the user to delete assigned test cases.  - `TCDeleteDependencyAll` Allows to delete existing test case dependencies.  - `TCDeleteOwn` Allows the user to delete own test cases.  - `TCEditBatchAll` Allows to batch change test cases.  - `TCEditFieldDescriptionAll` Allows the user to edit fields in the metadata and the description, for all test cases.  - `TCEditFieldDescriptionAssigned` Allows the user to edit fields in the metadata and the description, for assigned test cases.  - `TCEditFieldDescriptionOwn` Allows the user to edit fields in the metadata and the description, for own test cases.  - `TCEditNestingAll` Allows the user to change nested test cases, for all test cases.  - `TCEditNestingAssigned` Allows the user to change nested test cases, for assigned test cases.  - `TCEditNestingOwn` Allows the user to change nested test cases, for own test cases.  - `TCEditStatusAll` Allows the user to change the status of all test cases.  - `TCEditStatusAssigned` Allows the user to change the status of assigned test cases.  - `TCEditStatusOwn` Allows the user to change the status of own test cases.  - `TCEditStepsAll` Allows the user to use the step designer, for all test cases.  - `TCEditStepsAssigned` Allows the user to use the step designer, for assigned test cases.  - `TCEditStepsOwn` Allows the user to use the step designer, for own test cases.  - `TCEditTestAutomationAll` Allows the user to change test scripts in test steps, for all test cases.  - `TCEditTestAutomationAssigned` Allows the user to change test scripts in test steps, for assigned test cases.  - `TCEditTestAutomationOwn` Allows the user to change test scripts in test steps, for own test cases.  - `TCEditVariablesAll` Allows the user to change variables in variable manager, for all test cases.  - `TCEditVariablesAssigned` Allows the user to change variables in variable manager, for assigned test cases.  - `TCEditVariablesOwn` Allows the user to change variables in variable manager, for own test cases.  - `TCMoveBetweenProjectsAll` Allows the user to move all test cases between different projects.  - `TCMoveBetweenProjectsAssigned` Allows the user to move assigned test cases between different projects.  - `TCMoveBetweenProjectsOwn` Allows the user to move own test cases between different projects.  - `TCMoveInProjectAll` Allows the user to move all test cases within one project.  - `TCMoveInProjectAssigned` Allows the user to move assigned test cases within one project.  - `TCMoveInProjectOwn` Allows the user to move own test cases within one project.  - `TCViewContentAll` Allows the user to open test cases.  - `TSCreateAll` Allows the user to create new test scenarios.  - `TSCreateDependencyAll` Allows to create new dependencies, for test scenarios.  - `TSDeleteAll` Allows the user to delete all test scenarios.  - `TSDeleteAssigned` Allows the user to delete assigned test scenarios.  - `TSDeleteDependencyAll` Allows to delete existing dependencies, for test scenarios.  - `TSDeleteOwn` Allows the user to delete own test scenarios.  - `TSEditAll` Allows the user to change all test scenarios.  - `TSEditAssigned` Allows the user to change assigned test scenarios.  - `TSEditBatchAll` Allows to batch change test scenarios.  - `TSEditOwn` Allows the user to change own test scenarios.  - `TSMoveBetweenProjectsAll` Allows the user to move all test scenarios between different projects.  - `TSMoveBetweenProjectsAssigned` Allows the user to move assigned test scenarios between different projects.  - `TSMoveBetweenProjectsOwn` Allows the user to move own test scenarios between different projects.  - `TSMoveInProjectAll` Allows the user to move all test scenarios within one project.  - `TSMoveInProjectAssigned` Allows the user to move assigned test scenarios within one project.  - `TSMoveInProjectOwn` Allows the user to move own test scenarios within one project.  - `TSViewContentAll` Allows the user to open test scenarios. */
export enum ApiPermission {
    RQViewContentAll = "RQViewContentAll",
    RQViewDiscussionsAll = "RQViewDiscussionsAll",
    RQViewWordExportAll = "RQViewWordExportAll",
    RQViewWordExportAssigned = "RQViewWordExportAssigned",
    RQViewWordExportOwn = "RQViewWordExportOwn",
    RQCreateEditFieldsDescriptionAll = "RQCreateEditFieldsDescriptionAll",
    RQCreateEditCommentsAll = "RQCreateEditCommentsAll",
    RQCreateWordImportAll = "RQCreateWordImportAll",
    RQEditStatusAll = "RQEditStatusAll",
    RQEditStatusAssigned = "RQEditStatusAssigned",
    RQEditStatusOwn = "RQEditStatusOwn",
    RQEditFieldsAll = "RQEditFieldsAll",
    RQEditFieldsAssigned = "RQEditFieldsAssigned",
    RQEditFieldsOwn = "RQEditFieldsOwn",
    RQEditDescriptionAll = "RQEditDescriptionAll",
    RQEditDescriptionAssigned = "RQEditDescriptionAssigned",
    RQEditDescriptionOwn = "RQEditDescriptionOwn",
    RQEditCommentsAll = "RQEditCommentsAll",
    RQEditCommentsAssigned = "RQEditCommentsAssigned",
    RQEditCommentsOwn = "RQEditCommentsOwn",
    RQEditWordImportAll = "RQEditWordImportAll",
    RQEditWordImportAssigned = "RQEditWordImportAssigned",
    RQEditWordImportOwn = "RQEditWordImportOwn",
    RQEditBatchAll = "RQEditBatchAll",
    RQDeleteAll = "RQDeleteAll",
    RQDeleteAssigned = "RQDeleteAssigned",
    RQDeleteOwn = "RQDeleteOwn",
    RQMoveInProjectAll = "RQMoveInProjectAll",
    RQMoveInProjectAssigned = "RQMoveInProjectAssigned",
    RQMoveInProjectOwn = "RQMoveInProjectOwn",
    RQMoveBetweenProjectsAll = "RQMoveBetweenProjectsAll",
    RQMoveBetweenProjectsAssigned = "RQMoveBetweenProjectsAssigned",
    RQMoveBetweenProjectsOwn = "RQMoveBetweenProjectsOwn",
    RQCreateDependencyAll = "RQCreateDependencyAll",
    RQDeleteDependencyAll = "RQDeleteDependencyAll",
    DFViewContentAll = "DFViewContentAll",
    DFCreateAll = "DFCreateAll",
    DFEditAll = "DFEditAll",
    DFEditAssigned = "DFEditAssigned",
    DFEditOwn = "DFEditOwn",
    DFEditEnclosuresAll = "DFEditEnclosuresAll",
    DFEditEnclosuresOwn = "DFEditEnclosuresOwn",
    DFEditBatchAll = "DFEditBatchAll",
    DFDeleteAll = "DFDeleteAll",
    DFDeleteAssigned = "DFDeleteAssigned",
    DFDeleteOwn = "DFDeleteOwn",
    DFDeleteEnclosuresAll = "DFDeleteEnclosuresAll",
    DFDeleteEnclosuresOwn = "DFDeleteEnclosuresOwn",
    DFMoveInProjectAll = "DFMoveInProjectAll",
    DFMoveInProjectAssigned = "DFMoveInProjectAssigned",
    DFMoveInProjectOwn = "DFMoveInProjectOwn",
    DFMoveBetweenProjectsAll = "DFMoveBetweenProjectsAll",
    DFMoveBetweenProjectsAssigned = "DFMoveBetweenProjectsAssigned",
    DFMoveBetweenProjectsOwn = "DFMoveBetweenProjectsOwn",
    DFCreateDependencyAll = "DFCreateDependencyAll",
    DFDeleteDependencyAll = "DFDeleteDependencyAll",
    TCViewContentAll = "TCViewContentAll",
    TCCreateEditFieldsDescriptionAll = "TCCreateEditFieldsDescriptionAll",
    TCCreateEditVariablesAll = "TCCreateEditVariablesAll",
    TCCreateEditNestingAll = "TCCreateEditNestingAll",
    TCCreateEditTestAutomationAll = "TCCreateEditTestAutomationAll",
    TCEditStatusAll = "TCEditStatusAll",
    TCEditStatusAssigned = "TCEditStatusAssigned",
    TCEditStatusOwn = "TCEditStatusOwn",
    TCEditFieldDescriptionAll = "TCEditFieldDescriptionAll",
    TCEditFieldDescriptionAssigned = "TCEditFieldDescriptionAssigned",
    TCEditFieldDescriptionOwn = "TCEditFieldDescriptionOwn",
    TCEditStepsAll = "TCEditStepsAll",
    TCEditStepsAssigned = "TCEditStepsAssigned",
    TCEditStepsOwn = "TCEditStepsOwn",
    TCEditVariablesAll = "TCEditVariablesAll",
    TCEditVariablesAssigned = "TCEditVariablesAssigned",
    TCEditVariablesOwn = "TCEditVariablesOwn",
    TCEditNestingAll = "TCEditNestingAll",
    TCEditNestingAssigned = "TCEditNestingAssigned",
    TCEditNestingOwn = "TCEditNestingOwn",
    TCEditTestAutomationAll = "TCEditTestAutomationAll",
    TCEditTestAutomationAssigned = "TCEditTestAutomationAssigned",
    TCEditTestAutomationOwn = "TCEditTestAutomationOwn",
    TCEditBatchAll = "TCEditBatchAll",
    TCDeleteAll = "TCDeleteAll",
    TCDeleteAssigned = "TCDeleteAssigned",
    TCDeleteOwn = "TCDeleteOwn",
    TCMoveInProjectAll = "TCMoveInProjectAll",
    TCMoveInProjectAssigned = "TCMoveInProjectAssigned",
    TCMoveInProjectOwn = "TCMoveInProjectOwn",
    TCMoveBetweenProjectsAll = "TCMoveBetweenProjectsAll",
    TCMoveBetweenProjectsAssigned = "TCMoveBetweenProjectsAssigned",
    TCMoveBetweenProjectsOwn = "TCMoveBetweenProjectsOwn",
    TCCreateDependencyAll = "TCCreateDependencyAll",
    TCDeleteDependencyAll = "TCDeleteDependencyAll",
    TSViewContentAll = "TSViewContentAll",
    TSCreateAll = "TSCreateAll",
    TSEditAll = "TSEditAll",
    TSEditAssigned = "TSEditAssigned",
    TSEditOwn = "TSEditOwn",
    TSEditBatchAll = "TSEditBatchAll",
    TSDeleteAll = "TSDeleteAll",
    TSDeleteAssigned = "TSDeleteAssigned",
    TSDeleteOwn = "TSDeleteOwn",
    TSMoveInProjectAll = "TSMoveInProjectAll",
    TSMoveInProjectAssigned = "TSMoveInProjectAssigned",
    TSMoveInProjectOwn = "TSMoveInProjectOwn",
    TSMoveBetweenProjectsAll = "TSMoveBetweenProjectsAll",
    TSMoveBetweenProjectsAssigned = "TSMoveBetweenProjectsAssigned",
    TSMoveBetweenProjectsOwn = "TSMoveBetweenProjectsOwn",
    TSCreateDependencyAll = "TSCreateDependencyAll",
    TSDeleteDependencyAll = "TSDeleteDependencyAll",
    EXTCManualAll = "EXTCManualAll",
    EXTCAutomatedAll = "EXTCAutomatedAll",
    EXTSManualAll = "EXTSManualAll",
    EXTSAutomatedAll = "EXTSAutomatedAll",
    EXSchedulingAll = "EXSchedulingAll",
    EXSchedulingAssigned = "EXSchedulingAssigned",
    EXSchedulingOwn = "EXSchedulingOwn",
    EXFinalizeAll = "EXFinalizeAll",
    EXSetRelevanceAll = "EXSetRelevanceAll",
    SCViewContentAll = "SCViewContentAll",
    SCCreateAll = "SCCreateAll",
    SCEditAll = "SCEditAll",
    SCEditAssigned = "SCEditAssigned",
    SCEditOwn = "SCEditOwn",
    SCEditBatchAll = "SCEditBatchAll",
    SCDeleteAll = "SCDeleteAll",
    SCDeleteAssigned = "SCDeleteAssigned",
    SCDeleteOwn = "SCDeleteOwn",
    SCMoveInProjectAll = "SCMoveInProjectAll",
    SCMoveInProjectAssigned = "SCMoveInProjectAssigned",
    SCMoveInProjectOwn = "SCMoveInProjectOwn",
    SCMoveBetweenProjectsAll = "SCMoveBetweenProjectsAll",
    SCMoveBetweenProjectsAssigned = "SCMoveBetweenProjectsAssigned",
    SCMoveBetweenProjectsOwn = "SCMoveBetweenProjectsOwn",
    SCCreateDependencyAll = "SCCreateDependencyAll",
    SCDeleteDependencyAll = "SCDeleteDependencyAll",
    GEViewsPublishAll = "GEViewsPublishAll",
    GEViewsEditPublicAll = "GEViewsEditPublicAll",
    GEProjectEditTreeAll = "GEProjectEditTreeAll",
    GEProjectConfigureAll = "GEProjectConfigureAll",
    GEProjectConfigureUsersAll = "GEProjectConfigureUsersAll",
    GEProjectConfigureSubtemplateAll = "GEProjectConfigureSubtemplateAll",
    GEProjectViewAllUsersAll = "GEProjectViewAllUsersAll",
    GENotificationsAll = "GENotificationsAll",
    GEMindMapViewAll = "GEMindMapViewAll",
    GEMindMapCreateEditAll = "GEMindMapCreateEditAll",
    GEAttachmentsViewOpenAll = "GEAttachmentsViewOpenAll",
    GEAttachmentsAddAll = "GEAttachmentsAddAll",
    GEAttachmentsDeleteAll = "GEAttachmentsDeleteAll",
    GEExportItemAll = "GEExportItemAll",
    GEImportItemAll = "GEImportItemAll",
    PPViewContentAll = "PPViewContentAll",
    PPReportWorkAll = "PPReportWorkAll",
    PPCreateEditDeleteItemsAll = "PPCreateEditDeleteItemsAll",
    PPShowEarnedValueAnalysisAll = "PPShowEarnedValueAnalysisAll",
    DAViewAll = "DAViewAll",
    DAEditAll = "DAEditAll",
    DAChartPublishAll = "DAChartPublishAll",
    DAChartEditPublicAll = "DAChartEditPublicAll",
    AGViewAll = "AGViewAll",
    AGSprintCreateEditAll = "AGSprintCreateEditAll",
    AGSprintDeleteAll = "AGSprintDeleteAll",
    AGSprintPlanningAll = "AGSprintPlanningAll",
    RPUseAll = "RPUseAll",
    RPManageTemplatesAll = "RPManageTemplatesAll",
    RPCreateTemplateEditLayoutAll = "RPCreateTemplateEditLayoutAll",
    RPExportPDFAll = "RPExportPDFAll",
    RPExportHTMLAll = "RPExportHTMLAll",
    RPExportMHTAll = "RPExportMHTAll",
    RPExportRTFAll = "RPExportRTFAll",
    RPExportXLSAll = "RPExportXLSAll",
    RPExportXLSXAll = "RPExportXLSXAll",
    RPExportCSVAll = "RPExportCSVAll",
    RPExportTextFileAll = "RPExportTextFileAll",
    RPExportImageFileAll = "RPExportImageFileAll",
    RPExportDOCAll = "RPExportDOCAll",
    RPExportDOCXAll = "RPExportDOCXAll",
    RPExportODTAll = "RPExportODTAll",
    RPSignPDFAll = "RPSignPDFAll",
}

/** Contains information about created role. */
export interface ApiRoleNewResponse {
    /** The id of the role. */
    RoleId: number;
}

export interface ApiRoleNew {
    /** The name of the role. */
    Name: string | undefined;
    /** The list of permission of this role. */
    Permissions: ApiPermission[] | undefined;
}

export interface ApiUpdateRole {
    /** The new name of the role. */
    NewName: string | undefined;
    /** The list of new permission of this role. */
    NewPermissions: ApiPermission[] | undefined;
}

/** Represent a request to modify a role. Actual subclasses are used, depending on OperationType. */
export interface ApiRolePatchRequest {
    OperationType: string;
}

/** Represents an operation that replace the role, the role on which the request is performed will be deleted. */
export interface ApiRolePatchRequestReplaceRole extends ApiRolePatchRequest {
    /** The id of the role which should be set. */
    RoleIdToReplaceWith: number;
}

/** Represent a response to validate permission dependencies. Actual subclasses are used, depending on OperationType. */
export interface ApiPermissionDependenciesPatchResponse {
    OperationType: string;
}

/** Represents an reponse that validates the permission depedencies for adding permission. */
export interface ApiDependenciesAddPermissionPatchResponse extends ApiPermissionDependenciesPatchResponse {
    /** List of dependet but missing permissions. */
    PermissionsToAdd: ApiPermission[] | undefined;
}

/** Represents an reponse that validates the permission depedencies for removing permission. */
export interface ApiDependenciesRemovePermissionPatchResponse extends ApiPermissionDependenciesPatchResponse {
    /** List of permission where depdencie is not resolved, after the remove operation. */
    PermissionsToRemove: ApiPermission[] | undefined;
}

/** Represents an reponse that validates the permission depedencies for an permission set. */
export interface ApiDependenciesPermissionSetPatchResponse extends ApiPermissionDependenciesPatchResponse {
    /** List of dependet but missing permissions. */
    PermissionsToAdd: ApiPermission[] | undefined;
}

/** Represent a request to validate permission dependencies. Actual subclasses are used, depending on OperationType. */
export interface ApiDependenciesPermissionPatchRequest {
    /** List of permissions to validate. */
    AllPermissions: ApiPermission[] | undefined;
    OperationType: string;
}

/** Represents an operation that validates the permission depedencies for added permissions. */
export interface ApiDependenciesAddSinglePermissionPatchRequest extends ApiDependenciesPermissionPatchRequest {
    /** Currently checked permission. */
    AddedPermission: ApiPermission;
}

/** Represents an operation that validates the permission depedencies for removed permissions. */
export interface ApiDependenciesRemoveSinglePermissionPatchRequest extends ApiDependenciesPermissionPatchRequest {
    /** Currently unchecked permission. */
    RemovedPermission: ApiPermission;
}

/** Represents an operation that validates depedencies for an permission set. */
export interface ApiDependenciesPermissionSetPatchRequest extends ApiDependenciesPermissionPatchRequest {
}

/** Contains repository of registered file editors (used in automation). */
export interface ApiRegisteredFileEditorsRepository {
    /** Editors meta-data  */
    Meta: ApiRegisteredFileEditor[] | undefined;
    /** Editors scripts (javascript content) */
    Scripts: string[] | undefined;
}

/** Contains meta-data of the registered file editor (used in automation). */
export interface ApiRegisteredFileEditor {
    /** Extension of the files supported by this editor (e.g. "cvs") */
    FileExtension: string | undefined;
    /** Unique key to identify the registered editor. For example 'CSV'. */
    Key: string | undefined;
    /** Name of the javascript object that implements functionality of this editor. 
(the proper javascript file needs to be injected/evaluated in order to access the editor code).  */
    JSControllerName: string | undefined;
    /** Small icon representing the editor/file type. 
Contains Base64 encoded PNG bytes to be used with 'data:image/png;base64,' */
    Icon16: string | undefined;
    /** Large icon representing the editor/file type. 
Contains Base64 encoded PNG bytes to be used with 'data:image/png;base64,' */
    Icon32: string | undefined;
}

export interface ApiLongOperationInfoBase {
    /** Current status of the long running operation. */
    Status: ApiLongOperationStatus;
    InfoType: string;
}

/** Represents status of a long running operation. This enum has the following values:  - `Aborted` Long operation has been aborted.  - `BlockedByAnotherTask` Long operation has been blocked by another task.  - `Failed` Long operation has failed.  - `Finished` Long operation has finished without problems.  - `FinishedWithWarning` Long operation has finished but there were some problems.  - `InProgress` Long operation is in progress.  - `Queued` Long operation has been queued, not started yet. */
export enum ApiLongOperationStatus {
    Queued = "Queued",
    InProgress = "InProgress",
    Finished = "Finished",
    FinishedWithWarning = "FinishedWithWarning",
    Failed = "Failed",
    Aborted = "Aborted",
    BlockedByAnotherTask = "BlockedByAnotherTask",
}

/** Details of a long running operation (including status). Depending on actual type might be heavyweight (e.g. include detailed information about failures) */
export interface ApiLongOperationInfo extends ApiLongOperationInfoBase {
    /** Number of elements processed so far. Includes also failed elements. */
    Done: number;
    /** Number of all elements to be processed. */
    Total: number;
    /** Number of all elements that could not be processed. */
    Failed: number;
}

/** A dedicated version of ApiLongOperationInfo returned for batch-item update long operations. */
export interface ApiItemLongOperationInfo extends ApiLongOperationInfo {
    /** List of failures.  */
    Issues: ApiBatchItemOperationIssue[] | undefined;
}

/** Represents a failure of batch-item update operation for a single item. */
export interface ApiBatchItemOperationIssue {
    /** Item information. */
    Item: ApiItemIdentifier | undefined;
    /** Reason of a failure. */
    Reason: ApiBatchItemUpdateIssueDetailsBase | undefined;
    /** Type of the issue. */
    IssueType: ApiBatchItemOperationIssueType;
}

export interface ApiBatchItemUpdateIssueDetailsBase {
    Type: ApiBatchItemUpdateIssueDetailsType;
    DetailsType: string;
}

/** Represents reason of a failure of batch-item update operation This enum has the following values:  - `Denied` Access to the item has been denied  - `Failure` Uncategorized failure  - `FieldIncompatible` A field could not be converted due to incompatibility  - `Locked` Item was currently edited by someone  - `NotFound` Item has not been found  - `ValueNotAllowed` When updating an item, the given value was not allowed (e.g. due to format, length, denied by workflow rules etc.) */
export enum ApiBatchItemUpdateIssueDetailsType {
    NotFound = "NotFound",
    Locked = "Locked",
    Denied = "Denied",
    ValueNotAllowed = "ValueNotAllowed",
    Failure = "Failure",
    FieldIncompatible = "FieldIncompatible",
}

export interface ApiBatchItemUpdateFieldIssueDetails extends ApiBatchItemUpdateIssueDetailsBase {
    SourceFieldName: string | undefined;
    TargetFieldName: string | undefined;
}

export interface ApiBatchItemUpdateIssueDetails extends ApiBatchItemUpdateIssueDetailsBase {
}

/** This enum has the following values:  - `FieldError`  - `FieldInformation`  - `FieldWarning`  - `ItemError`  - `ItemInformation`  - `ItemWarning` */
export enum ApiBatchItemOperationIssueType {
    ItemError = "ItemError",
    ItemWarning = "ItemWarning",
    ItemInformation = "ItemInformation",
    FieldError = "FieldError",
    FieldWarning = "FieldWarning",
    FieldInformation = "FieldInformation",
}

/** A dedicated version of ApiLongOperationInfo returned for excel expprt long operations. */
export interface ApiExportLongRunningTaskInfo extends ApiLongOperationInfo {
    /** When finished, this will contain the file guid to the export file */
    ExportFileGuid: string | undefined;
}

/** A dedicated version of ApiLongOperationInfo returned for excel import long operations. */
export interface ApiImportLongRunningTaskInfo extends ApiLongOperationInfo {
    /** List of failed imports. */
    FailedItems: ApiImportErrorReportItem[] | undefined;
    /** List of expected phases during import, filled only after the excel file was read */
    ExpectedPhases: ApiImportPhase[] | undefined;
    /** The current phase of the import */
    CurrentPhase: ApiImportPhase;
}

/** An individual error during import */
export interface ApiImportErrorReportItem {
    /** The type of the error, defined in ApiImportErrorType */
    ErrorType: ApiImportErrorType;
    /** The column header */
    ImportKey: string | undefined;
    /** The row number on the Worksheet the error occured on */
    Row: number;
    /** Target property of the baseobject (or subitem like teststep,enclosure etc) */
    PropertyName: string | undefined;
    /** Invalid value from worksheet */
    IncorrectValue: string | undefined;
    /** The Error Message */
    ErrorMessage: string | undefined;
    /** The column number on the Worksheet the error occured on */
    Column: number;
    /** The Worksheet the error occured on */
    WorkSheetName: string | undefined;
}

/** Represents reason of a failure of import operation Note that some of these errors can be caused by using the wrong culture This enum has the following values:  - `CreateAttachmentError` Never used  - `CreateDateTimeError` Invalid Datetime: value could not be parsed  - `CreateDependencyError` Invalid Depenceny  - `CreateEnclosureError` No Id column to match Enclosures to Defect  - `CreateEnclosureItemError` Invalid type supplied for enclosure  - `CreateHierarchyError` Error while matching requirement to parent  - `CreateListError` Invalid MultiChoiceDropDown: value could not be matched to a list of valid values  - `CreateNumberError` Invalid Number: value could not be parsed  - `CreateTestJobNoRelatedTestCaseImportedError` The TestCase for a TestScenario's TestJob was not imported during this import  - `CreateTestJobsError` No Id column to match Testjobs to testscenario  - `CreateTestStepError` No Id column to match Teststep to TestCase  - `CreateTestStepItemError` Invalid type supplied for TestStep  - `CreateUserError` Invalid User: value could not be matched to a single user  - `DefectNoFieldMatchedError` No data in Row to import into Defect  - `DuplicateId` The same id is given to several objects (has to be unique across all worksheets)  - `DuplicateUser` Value from import-file denotes more than one user  - `ImportFileInvalid` xls file can not be read as such  - `InvalidArchive` corrupt zip file  - `InvalidColumnNameError` Column mapped to not importable property of object  - `InvalidSheetName` Worksheetname is not recognized to relate to an objecttype.  - `NoDataInWorkSheet` No data to import found after header row/No columns found besides id column  - `NoKeyColumn` No Id column found in worksheet  - `NoPermissionToCreateItem` Importing user has not the permission to create object in destined folder  - `NoValidFileInArchive` Zip-archive contains not xls on root level  - `RequirementNoFieldMathchedError` No data in Row to import into Requirement  - `ScreenShotNotFoundError` Rich client only - linked Screenshot in rtf not found in import data  - `ServerError` An internal server error occured  - `TestCaseNoFieldMatchedError` No data in Row to import into Testcase  - `TestScenarioNoFieldMatchedError` No data in Row to import into testscenario */
export enum ApiImportErrorType {
    CreateDateTimeError = "CreateDateTimeError",
    CreateNumberError = "CreateNumberError",
    CreateUserError = "CreateUserError",
    CreateListError = "CreateListError",
    CreateHierarchyError = "CreateHierarchyError",
    CreateDependencyError = "CreateDependencyError",
    CreateEnclosureError = "CreateEnclosureError",
    CreateAttachmentError = "CreateAttachmentError",
    CreateTestStepError = "CreateTestStepError",
    InvalidColumnNameError = "InvalidColumnNameError",
    DefectNoFieldMatchedError = "DefectNoFieldMatchedError",
    RequirementNoFieldMathchedError = "RequirementNoFieldMathchedError",
    TestCaseNoFieldMatchedError = "TestCaseNoFieldMatchedError",
    ScreenShotNotFoundError = "ScreenShotNotFoundError",
    CreateTestStepItemError = "CreateTestStepItemError",
    CreateEnclosureItemError = "CreateEnclosureItemError",
    TestScenarioNoFieldMatchedError = "TestScenarioNoFieldMatchedError",
    CreateTestJobsError = "CreateTestJobsError",
    CreateTestJobNoRelatedTestCaseImportedError = "CreateTestJobNoRelatedTestCaseImportedError",
    NoPermissionToCreateItem = "NoPermissionToCreateItem",
    NoKeyColumn = "NoKeyColumn",
    NoDataInWorkSheet = "NoDataInWorkSheet",
    InvalidSheetName = "InvalidSheetName",
    DuplicateUser = "DuplicateUser",
    DuplicateId = "DuplicateId",
    NoValidFileInArchive = "NoValidFileInArchive",
    ImportFileInvalid = "ImportFileInvalid",
    InvalidArchive = "InvalidArchive",
    ServerError = "ServerError",
}

/** Represents reason of a failure of import operation The enumeration is sorted in the order these phases occur during import This enum has the following values:  - `CreatingDependencies` Creating Depedencies  - `CreatingHierarchy` Creating Requirement Hierarchy  - `CreatingTestJobs` Creating TestJobs from Testcases for TestScenarios, only using TestCases/TestScenarios created during this import  - `Done` Finished  - `Error` Aborted due to error during import  - `Finishing` Finishing up, writing Data to DB  - `ImportingDefects` Importing Defects  - `ImportingRequirements` Importing Requirements  - `ImportingTestCases` Importing TestCases and TestSteps  - `ImportingTestScenarios` Importing Testscenarion WITHOUT TestJobs  - `Initializing` Preparing for reading of file  - `ReadingFile` Reading the excel file and trying to map columns to baseobject-properties */
export enum ApiImportPhase {
    Initializing = "Initializing",
    ReadingFile = "ReadingFile",
    ImportingRequirements = "ImportingRequirements",
    ImportingDefects = "ImportingDefects",
    ImportingTestCases = "ImportingTestCases",
    ImportingTestScenarios = "ImportingTestScenarios",
    CreatingDependencies = "CreatingDependencies",
    CreatingTestJobs = "CreatingTestJobs",
    CreatingHierarchy = "CreatingHierarchy",
    Finishing = "Finishing",
    Done = "Done",
    Error = "Error",
}

/** Represents patch operation that modifies 'long operation'. */
export interface ApiLongOperationPatchOperation {
    Operation: string;
}

/** Abort 'long operation' operation. */
export interface ApiLongOperationPatchAbort extends ApiLongOperationPatchOperation {
}

/** A new email notification to be send to given users. */
export interface ApiCustomNotificationNew {
    /** List of recipients (ids of users) */
    Recipients: number[] | undefined;
    /** Subject of the email to be send (plain text) */
    Subject: string | undefined;
    /** Body of the email to be send (plain text) */
    Body: string | undefined;
}

/** Contains user information for administration. */
export interface ApiUser extends ApiUserInfo {
    /** Indicates if the user is server administrator or not. */
    ServerAdministrator: boolean;
    /** The status of the user. */
    Status: ApiUserStatus;
    /** List of projects with roles assigned to the user. */
    Projects: ApiUserProjectAssignment[] | undefined;
    /** List of licenses assigned to the user. */
    Licenses: ApiUserLicenseAssignment[] | undefined;
    /** List of license profiles */
    LicenseProfiles: ApiLicenseProfile[] | undefined;
}

/** Identifies the user status. This enum has the following values:  - `Activated` The user is activated.  - `Deactivated` The user is deactivated.  - `LicenseDeactivated` The license is deactivated. */
export enum ApiUserStatus {
    Activated = "Activated",
    Deactivated = "Deactivated",
    LicenseDeactivated = "LicenseDeactivated",
}

/** The user project assignment information. */
export interface ApiUserProjectAssignment {
    /** Assigned project, with subfolder information. */
    Project: ApiProjectIdNameHasSubfolders | undefined;
    /** Assigned role. */
    Role: ApiRoleIdName | undefined;
}

export interface ApiProjectIdNameHasSubfolders extends ApiProjectIdName {
    /** Indicates whether this project has any subfolders.  */
    HasSubfolders: boolean;
}

/** The user license assignment information. */
export interface ApiUserLicenseAssignment {
    /** The code of the license. */
    Code: string | undefined;
    /** The type of the license. */
    Type: ApiLicenseType;
}

/** Identifies the type of the licens. This enum has the following values:  - `Floated` Floated licens.  - `Named` Named licens. */
export enum ApiLicenseType {
    Floated = "Floated",
    Named = "Named",
}

export interface ApiLicenseProfile {
    /** The code of the license profile */
    ProfileCode: string | undefined;
    /** The name of the license profile */
    ProfileName: string | undefined;
    /** The maximal number of named licenses. */
    NamedTotal: number;
    /** The maximal number of floating licenses. */
    FloatingTotal: number;
    /** The used number of named licenses. */
    NamedUsed: number;
    /** The used number of floating licenses. */
    FloatingUsed: number;
}

/** Represents the necessary minimal information about a user. */
export interface ApiUserMinimalInfo {
    /** The id of the user. */
    Id: number;
    /** The username of the user. */
    UserName: string | undefined;
    /** The first name of the user. */
    FirstName: string | undefined;
    /** The surname / last name of the user. */
    Surname: string | undefined;
    /** The current user status. */
    Status: ApiUserStatus;
    /** If set, indicates the the user has at least one active license assigned. */
    AnyActiveLicense: boolean;
}

/** Contains information about created user. */
export interface ApiUserNewReponse {
    /** The id of the user. */
    UserId: number;
}

/** Represents the necessary information to create a user. */
export interface ApiUserNew {
    /** The username of the user. */
    UserName: string | undefined;
    /** The first name of the user. */
    FirstName: string | undefined;
    /** The surname / last name of the user. */
    Surname: string | undefined;
    /** The email address of the user. */
    Email: string | undefined;
    /** The phone number of the user. */
    Phone: string | undefined;
    /** The position of the user in the company. */
    Position: string | undefined;
}

export interface ApiUpdateUser {
    /** The new username of the user. */
    UserName: string | undefined;
    /** The new first name of the user. */
    FirstName: string | undefined;
    /** The new surname / last name of the user. */
    Surname: string | undefined;
    /** The new email address of the user. */
    Email: string | undefined;
    /** The new phone number of the user. */
    Phone: string | undefined;
    /** The new position of the user in the company. */
    Position: string | undefined;
}

/** Represent a request to modify a user. Actual subclasses are used, depending on OperationType. */
export interface ApiUserPatchRequest {
    OperationType: string;
}

/** Represents an operation that deactivates the user. */
export interface ApiUserPatchRequestDeactivateUser extends ApiUserPatchRequest {
}

/** Represents an operation that activates the user. */
export interface ApiUserPatchRequestActivateUser extends ApiUserPatchRequest {
}

/** Represents an operation that resets the user password. */
export interface ApiUserPatchRequestPasswordReset extends ApiUserPatchRequest {
}

/** Represents an operation that modifys server administrator flag. */
export interface ApiUserPatchRequestSetServerAdministrator extends ApiUserPatchRequest {
    /** Server administrator flag. */
    ServerAdministrator: boolean;
}

/** Represents an operation that modifys user password. */
export interface ApiUserPatchRequestSetUserPassword extends ApiUserPatchRequest {
    /** New user password. */
    NewPassword: string | undefined;
}

/** Represents the get license response. */
export interface ApiGetLicenseResponse {
    /** The list of licenses. */
    Licenses: ApiLicense[] | undefined;
}

export interface ApiLicense {
    /** The code of the license. */
    Code: string | undefined;
    /** The name of the license. */
    Name: string | undefined;
    /** The maximal number of named licenses. */
    MaxNamedLicensesAvailable: number;
    /** The maximal number of floating licenses. */
    MaxFloatingLicensesAvailable: number;
    /** The start date of the license. */
    StartTime: Date;
    /** The expire date of the license. */
    ExpiryTime: Date;
}

/** Contains a paginated result. */
export interface ApiPaginatedResultOfApiUserLastActivityInfo {
    /** The number of items which were skipped in the list of results.
This value is provided during the request. */
    StartAt: number;
    /** The maximum number of items which should be included in the result.
This value is provided during the request. */
    MaxResults: number;
    /** The overall number of items which are available. When using pagination,
this number is higher than the number of items which are included in the result. */
    Count: number;
    /** The actual items included in this response. */
    Items: ApiUserLastActivityInfo[] | undefined;
}

export interface ApiUserLastActivityInfo {
    LastActivity: Date | undefined;
    LicenseUsage: ApiLicenseProfileUtilizationInfo[] | undefined;
    ClientId: string | undefined;
    User: ApiUserInfo | undefined;
    State: ApiUserSessionState;
    ClientType: ApiAquaClientType;
}

export interface ApiLicenseProfileUtilizationInfo {
    Utilization: ApiLicenseProfileUtilization;
    ProfileCode: string | undefined;
    AsFloating: boolean;
}

/** This enum has the following values:  - `FloatingLicenseNotAvailable` Floating license active, but no more instances available.  - `LicenseGranted` License was granted.             - `NoValidLicense` No active license.  - `ProfileDeactivatedByLicense` License active, but profile assignment was deactivated by license. */
export enum ApiLicenseProfileUtilization {
    NoValidLicense = "NoValidLicense",
    LicenseGranted = "LicenseGranted",
    FloatingLicenseNotAvailable = "FloatingLicenseNotAvailable",
    ProfileDeactivatedByLicense = "ProfileDeactivatedByLicense",
}

/** This enum has the following values:  - `Active`  - `Inactive`  - `Unknown` */
export enum ApiUserSessionState {
    Unknown = "Unknown",
    Active = "Active",
    Inactive = "Inactive",
}

/** This enum has the following values:  - `API` API Client  - `Offline` Offline Desktop Client (Depricated)  - `Rich` Desktop Client  - `Unknown` Unknown or invalid client  - `Web` Web Client */
export enum ApiAquaClientType {
    Unknown = "Unknown",
    Rich = "Rich",
    Offline = "Offline",
    Web = "Web",
    API = "API",
}

/** Represents the get license permission response. */
export interface ApiGetLicensePermissionsResponse {
    /** The list of permissions. */
    Permissions: ApiPermission[] | undefined;
}

/** Contains a paginated result. */
export interface ApiPaginatedResultOfApiLoginIncident {
    /** The number of items which were skipped in the list of results.
This value is provided during the request. */
    StartAt: number;
    /** The maximum number of items which should be included in the result.
This value is provided during the request. */
    MaxResults: number;
    /** The overall number of items which are available. When using pagination,
this number is higher than the number of items which are included in the result. */
    Count: number;
    /** The actual items included in this response. */
    Items: ApiLoginIncident[] | undefined;
}

export interface ApiLoginIncident {
    CustomerId: number | undefined;
    LoginSuccessfull: boolean;
    OccurrenceDate: Date;
    ReasonCode: ApiLoginIncidentReason;
    ReasonData: string | undefined;
    ClientType: ApiAquaClientType;
    ClientId: string | undefined;
    Relogin: boolean;
    User: ApiUserInfo | undefined;
}

/** This enum has the following values:  - `AuthenticationFailure` User not authenticated (neither by external module, if any, nor by our mechanism; usually means invalid username or password).  - `CustomerDeactivated` The customer is deactivated.  - `FloatingLicenseNotAvailable` Not possible to obtain a floating license (all in use).  - `NoActiveLicenseAssignment` User is assigned with a license(s) but all assignments are deactivated.  - `NoLicenseAssignment` User is not assigned with any license.  - `NoLoginPermission` User is assigned with some valid licenses, but they does not include a login permission for given client type.  - `NotMemberOfCustomer` The user is not a member of the current customer.  - `Unknown` unknown reason (or no reason).  - `UserDeactivated` User is deactivated.  - `UserDeleted` User is deleted.  - `UsernameNotUnique` Indicates that the username is not unique. This might happen when different users have the same username in different capitalizations. */
export enum ApiLoginIncidentReason {
    Unknown = "Unknown",
    FloatingLicenseNotAvailable = "FloatingLicenseNotAvailable",
    NoLicenseAssignment = "NoLicenseAssignment",
    NoActiveLicenseAssignment = "NoActiveLicenseAssignment",
    NoLoginPermission = "NoLoginPermission",
    AuthenticationFailure = "AuthenticationFailure",
    UserDeactivated = "UserDeactivated",
    UserDeleted = "UserDeleted",
    NotMemberOfCustomer = "NotMemberOfCustomer",
    CustomerDeactivated = "CustomerDeactivated",
    UsernameNotUnique = "UsernameNotUnique",
}

/** Represent the necessary information to change the license type. */
export interface ApiUserLicenseAssignmentPatchRequest {
    OperationType: string;
}

export interface ApiUserLicenseAssignmentChangeLicenseTypePatchRequest extends ApiUserLicenseAssignmentPatchRequest {
    /** The new license type. */
    NewLicenseType: ApiLicenseType;
}

/** The response containing a URL that is only valid for a short period of time (default 10 minutes) */
export interface ApiCreateLoginLinkResponse {
    /** The URL containing the token that can be used to
connect to aqua for a limited time  */
    Url: string | undefined;
}

export interface ApiTestCase extends ApiItemWithDescription {
    /** True if test case has any steps.  */
    HasSteps: boolean;
    /** True if test case is parametrized i.e. value set needs to be selected before 
starting execution of this test case. 
Please note actual test data may be owned by another test case (i.e. is "referenced" only here) */
    HasData: boolean;
    /** True if test case has at least one execution. */
    HasExecutions: boolean;
    /** Contains information about the last execution status. */
    LastExecutionStatus: ApiTestCaseRunStatus;
    /** Contains id of the last execution. */
    LastExecutionId: number | undefined;
    /** Contains the test case execution defaults. */
    TestCaseExecutionDefaults: ApiTestCaseExecutionDefaults | undefined;
    /** Contains the information about required agent technologies. */
    RequiredAgentTechnologies: ApiAutomationTechnology[] | undefined;
    /** Information about the support level of the automatic execution. */
    SupportsAutomaticExecution: ApiAutomaticExecutionSupport;
}

export interface ApiTestCaseExecutionDefaultsBase {
    /** The value set guid. */
    ValueSetGuid: string | undefined;
    /** The tested version. */
    TestedVersion: string | undefined;
    /** On creation of a test execution those labels are copied over as ApiLabelAttached.
Version is not checked and can be null. */
    Labels: ApiLabelInfo[] | undefined;
}

/** Contains information about the test case execution defaults. */
export interface ApiTestCaseExecutionDefaults extends ApiTestCaseExecutionDefaultsBase {
    /** the id of the test case execution default. */
    Id: number;
    /** The id of the test case. */
    TestCaseId: number;
    /** The id and name of the agent. */
    Agent: ApiAgentIdAndName | undefined;
    /** The list of custom fields. */
    CustomFields: ApiFieldWithValue[] | undefined;
    /** Contains information about fields layout (i.e. how to layout fields in the edit mask). */
    EditLayout: ApiEditLayout | undefined;
}

/** This enum has the following values:  - `Complete` Automatic execution complete supported.  - `None` Automatic execution not supported.  - `Partially` Automatic execution partially supported. */
export enum ApiAutomaticExecutionSupport {
    None = "None",
    Partially = "Partially",
    Complete = "Complete",
}

/** Specifies the changes to perform on a specific item including its test data and test steps. */
export interface ApiItemUpdateWithTestDataAndTestSteps extends ApiItemUpdateWithDescription {
    /** Contains the updated test data. */
    TestData: ApiTestDataUpdate | undefined;
    /** Contains the updated information for the test steps. */
    TestSteps: ApiTestStepsUpdate | undefined;
}

/** Base class for updated test data of a test case. This class is abstract, not intended to be used directly. */
export interface ApiTestDataUpdate {
    Variant: string;
}

/** Represents test data to be updated as "local" i.e. owned by current test case. */
export interface ApiTestDataUpdateLocal extends ApiTestDataUpdate {
    /** The value sets which are part of the test data. */
    ValueSets: ApiTestDataUpdateValueSet[];
    /** The variables which are part of the test data. */
    Variables: ApiTestDataUpdateVariable[];
    /** The actual values contained in the test data. The table
is a two-dimensional array which contains for each value
set a list of values. The data is ordered according to
the ValueSets and Variables list. */
    Values: string[][];
}

/** Contains the meta data of a certain value set in the test data. */
export interface ApiTestDataUpdateValueSet {
    /** The GUID of the value set.
Must be null for newly created values sets. */
    Guid: string | undefined;
    /** The name of the value set. */
    Name: string;
}

/** Contains the meta data of a certain variable in the test data. */
export interface ApiTestDataUpdateVariable {
    /** The variable name. */
    Name: string;
}

/** Represents test data referenced from another test case. */
export interface ApiTestDataUpdateReferencedTestCase extends ApiTestDataUpdate {
    ReferencedTestCaseId: number;
}

/** Contains a list of different changes which should be applied to the test step collection. */
export interface ApiTestStepsUpdate {
    /** A list with the new test steps which should be added. */
    Added: ApiTestStepNew[] | undefined;
    /** A list with test steps which should be updated. */
    Modified: ApiTestStepUpdateWithId[] | undefined;
    /** A list with the ids of the test steps which should be removed. */
    Removed: number[] | undefined;
}

/** A base class representing test step of a test case. */
export interface ApiTestStepBase {
    /** Test step name. */
    Name: string | undefined;
    /** The index of this test step. */
    Index: number;
    /** The description of the test step. */
    Description: ApiRichText | undefined;
    /** The expected result of the test step. */
    ExpectedResult: ApiRichText | undefined;
    /** The actual result template of the test step. */
    ActualResultTemplate: ApiRichText | undefined;
    /** The type of this test step. */
    StepType: ApiTestStepType;
}

/** A new test step of a test case. */
export interface ApiTestStepNew extends ApiTestStepBase {
    /** Automation part of a test step. 
Lack of automation is represented either by null or by object with Technology=None */
    Automation: ApiAutomationSave | undefined;
    /** Contains information about nested test case. */
    NestedTestCase: ApiNestedTestCaseInfoNew | undefined;
}

/** Automation part of a test step, as used when saving data. */
export interface ApiAutomationSave {
    /** If not zero indicates that automation script (represented by this object) is from script library. 
In such case update is only possible via corresponding Script item, not via Test Case.  */
    ScriptId: number;
    /** Automation script details. Content depends on Technology.
If ScriptId is not zero, the Script attribute should not be provided at all. */
    Script: ApiAutomationScriptSave | undefined;
}

export interface ApiAutomationScriptSave {
    /** Indicates whether data represent a new (transient) content or an update of existing content. 
Should be set to true if we are saving a new automation into step that previously contained any automation already. */
    IsNew: boolean;
    Technology: string;
}

export interface ApiAutomationScriptNotSupportedSave extends ApiAutomationScriptSave {
}

export interface ApiAutomationScriptDatabaseSave extends ApiAutomationScriptNotSupportedSave {
}

/** A base class for models of automation that support attached files (e.g. shell, qtp etc.) used in save operations. */
export interface ApiAutomationScriptWithAttachedFilesSave extends ApiAutomationScriptSave {
    /** A list of files to be added. 
Note that each file includes Position (zero based index) where to insert the new file. 
Server at first deletes all files listed in 'DeletedFiles' and then inserts new files. 
In-place modification of attached files is not supported, thus modification is 
achieved by deleting existing attachment and adding a new one.  */
    NewFiles: ApiAutomationAttachedScriptFileNew[] | undefined;
    /** A list of files (their ids) to be removed. */
    DeletedFiles: number[] | undefined;
}

/** Automation part of a test step, as used when saving data. */
export interface ApiAutomationScriptShellSave extends ApiAutomationScriptWithAttachedFilesSave {
    /** Script content.  */
    ScriptContent: string | undefined;
    /** Code of shell profile to be used (if any) */
    Profile: string | undefined;
}

export interface ApiAutomationScriptJenkinsSave extends ApiAutomationScriptShellSave {
}

/** An attachment which should be created as part of a list of attachment changes for a certain item. The file attach must have been uploaded to /File beforehand.The InsertAt property indicates where on the list the new attachment should be located. */
export interface ApiAutomationAttachedScriptFileNew {
    /** The ID of the temporary upload which should be added as the new
attachment. The temporary upload can be created with the 
[UploadFile](#operation/File_UploadFile)
endpoint. */
    Guid: string;
    /** Location where to insert the new file.  */
    InsertAt: number;
}

export interface ApiAutomationScriptJMeterSave extends ApiAutomationScriptNotSupportedSave {
}

export interface ApiAutomationScriptNoneSave extends ApiAutomationScriptSave {
}

export interface ApiAutomationScriptPowerShellSave extends ApiAutomationScriptShellSave {
}

export interface ApiAutomationScriptQTPSave extends ApiAutomationScriptNotSupportedSave {
}

export interface ApiAutomationScriptRanorexSave extends ApiAutomationScriptNotSupportedSave {
}

export interface ApiAutomationScriptSoapUISave extends ApiAutomationScriptNotSupportedSave {
}

export interface ApiAutomationScriptUFTSave extends ApiAutomationScriptNotSupportedSave {
}

export interface ApiAutomationScriptUnixShellSave extends ApiAutomationScriptShellSave {
}

/** Contains information about nested test case. */
export interface ApiNestedTestCaseInfoNew {
    /** The id of the nested test case, set the id only if the type is nested test case. */
    Id: number;
    /** The guid of the value set, set the guid only if the type is nested test case. */
    NestedTestCaseValueSetGuid: string | undefined;
    /** Defines the source of variables. */
    NestedTestCaseVariablesInheritance: ApiNestedTestCaseVariablesInheritance;
}

/** Identifies the source of variables. This enum has the following values:  - `PreferNested` Variable source is from nested test case.  - `PreferOuter` Variable source is from host test case. */
export enum ApiNestedTestCaseVariablesInheritance {
    PreferOuter = "PreferOuter",
    PreferNested = "PreferNested",
}

/** Identifies the type of an execution. This enum has the following values:  - `Condition` Represents 'condition'  - `NestedTestCase` Only for internal use.  - `Step` Represents 'step' */
export enum ApiTestStepType {
    Step = "Step",
    Condition = "Condition",
    NestedTestCase = "NestedTestCase",
}

/** Contains update Information for a test step of a test case. */
export interface ApiTestStepUpdate {
    /** Test step name. When the value is null, it will be ignored. */
    Name: string | undefined;
    /** The index of this test step. */
    Index: number;
    /** The description of the test step. */
    Description: ApiRichText | undefined;
    /** The expected result of the test step. */
    ExpectedResult: ApiRichText | undefined;
    /** The actual result template of the test step. */
    ActualResultTemplate: ApiRichText | undefined;
    /** Contains information about nested test case. */
    NestedTestCase: ApiNestedTestCaseInfoUpdate | undefined;
    /** Automation part of the test step. 
If null, then automation is not updated. 
To represent update that clears automation please use instance of ApiAutomationScriptEmptySave */
    Automation: ApiAutomationSave | undefined;
}

export interface ApiTestStepUpdateWithId extends ApiTestStepUpdate {
    /** Test step id. */
    Id: number;
}

/** Contains update information for the nested test case. */
export interface ApiNestedTestCaseInfoUpdate {
    /** The guid of the value set, set the guid only if the type is nested test case. */
    NestedTestCaseValueSetGuid: string | undefined;
    /** Defines the source of variables. */
    NestedTestCaseVariablesInheritance: ApiNestedTestCaseVariablesInheritance;
}

/** Contains the necessary data to create a new item including its test data. */
export interface ApiItemNewWithTestDataAndTestSteps extends ApiItemNewWithDescription {
    /** Contains the updated test data. */
    TestData: ApiTestDataNew | undefined;
    /** Contains the test steps. */
    TestSteps: ApiTestStepNew[] | undefined;
}

/** Base class for models used when providing test data during test case creation. This class is abstract, not intended to be used directly. */
export interface ApiTestDataNew {
    Variant: string;
}

/** Represents test data to be used as "local" (i.e. owned by current test case). */
export interface ApiTestDataNewLocal extends ApiTestDataNew {
    /** The value sets which are part of the test data. */
    ValueSets: ApiTestDataNewValueSet[];
    /** The variables which are part of the test data. */
    Variables: ApiTestDataNewVariable[];
    /** The actual values contained in the test data. The table
is a two-dimensional array which contains for each value
set a list of values. The data is ordered according to
the ValueSets and Variables list. */
    Values: string[][];
}

/** Contains the meta data of a value set to be created in the test data. */
export interface ApiTestDataNewValueSet {
    /** The name of the value set. */
    Name: string;
}

/** Contains the meta data of a variable to be created in the test data. */
export interface ApiTestDataNewVariable {
    /** The variable name. */
    Name: string;
}

/** Represents test data referenced from another test case. */
export interface ApiTestDataNewReferencedTestCase extends ApiTestDataNew {
    ReferencedTestCaseId: number;
}

/** Contains necessary information for the test case execution defaults update. */
export interface ApiTestCaseExecutionDefaultsUpdate extends ApiTestCaseExecutionDefaultsBase {
    /** The agent id (or null, if saving executions for non-automated test case).  */
    AgentId: number | undefined;
    /** The list of custom fields. */
    CustomFields: ApiFieldUpdate[] | undefined;
}

/** A persistent test step of a test case. */
export interface ApiTestStep extends ApiTestStepBase {
    /** The id of the test step. */
    Id: number;
    /** Automation part of a test step. 
Lack of automation is represented by an object with Technology=None. */
    Automation: ApiAutomation | undefined;
    /** Contains information about nested test case. */
    NestedTestCase: ApiNestedTestCaseInfo | undefined;
}

/** Automation part of a test step, as used when loading data. */
export interface ApiAutomation {
    /** If not zero indicates that automation script (represented by this object) is referenced from script library.  */
    ScriptId: number;
    /** Automation script details. Content depends on Technology. */
    Script: ApiAutomationScript | undefined;
}

export interface ApiAutomationScript {
    Technology: string;
}

export interface ApiAutomationScriptNotSupported extends ApiAutomationScript {
}

export interface ApiAutomationScriptDatabase extends ApiAutomationScriptNotSupported {
}

/** A base class for models of automation that support attached files (e.g. shell, qtp etc.) used in load operations. */
export interface ApiAutomationScriptWithAttachedFiles extends ApiAutomationScript {
    /** A list of attached files. */
    AttachedFiles: ApiAutomationAttachedScriptFileInfo[] | undefined;
}

/** Automation part of a test step, as used when loading data. */
export interface ApiAutomationScriptShell extends ApiAutomationScriptWithAttachedFiles {
    /** Script content.  */
    ScriptContent: string | undefined;
    /** Code of shell profile to be used (if any) */
    Profile: string | undefined;
}

export interface ApiAutomationScriptJenkins extends ApiAutomationScriptShell {
}

/** Meta information for an attached file (used in some types of automation e.g. in PowerShell) Contains e.g. file name and size. This structure does not contain the content of the attachment which must be requested separately. */
export interface ApiAutomationAttachedScriptFileInfo {
    /** The id of the attachment. */
    Id: number;
    /** The full file name of the attachment including the file extension. */
    Filename: string | undefined;
    /** The file extension of the attachment. */
    FileExtension: string | undefined;
    /** The size of the attachment in bytes. */
    Size: number;
    /** The url where the content of the attachment is located. For this url,
the API will force browsers to display the content by setting the
content-disposition header to inline. */
    ViewUrl: string | undefined;
    /** The url where the content of the attachment is located. For this url,
the API will force browsers to download the file by setting the
content-disposition header to attachment. */
    DownloadUrl: string | undefined;
}

export interface ApiAutomationScriptJMeter extends ApiAutomationScriptNotSupported {
}

export interface ApiAutomationScriptNone extends ApiAutomationScript {
}

export interface ApiAutomationScriptPowerShell extends ApiAutomationScriptShell {
}

export interface ApiAutomationScriptQTP extends ApiAutomationScriptNotSupported {
}

export interface ApiAutomationScriptRanorex extends ApiAutomationScriptNotSupported {
}

export interface ApiAutomationScriptSoapUI extends ApiAutomationScriptNotSupported {
}

export interface ApiAutomationScriptUFT extends ApiAutomationScriptNotSupported {
}

export interface ApiAutomationScriptUnixShell extends ApiAutomationScriptShell {
}

/** Contains information about nested test case. */
export interface ApiNestedTestCaseInfo {
    /** Contains the information about accessbility of the test case. */
    NestedTestCaseAccessibility: ApiBaseItemAccessibility;
    /** No set if NestedTestCaseAccessibility is set to NoPermissions, true if test case contains any variables otherwise false. */
    HasVariables: boolean | undefined;
    /** The id of the nested test case, set the id only if the type is nested test case. */
    Id: number;
    /** The name of the nested test case. */
    Name: string | undefined;
    /** The value set, only set if the type is nested test case, if the ValueSet from the nested test case is deleted guid and name will be null. */
    NestedTestCaseValueSet: ApiTestDataReferencedValueSetInfo | undefined;
    /** Defines the source of variables. */
    NestedTestCaseVariablesInheritance: ApiNestedTestCaseVariablesInheritance;
}

/** Identifies the test case accessibility. This enum has the following values:  - `Accessible` The test case is accessible.  - `Archived` The test case is archived  - `Deleted` The test case is deleted.  - `NoPermissions` No permissions to access the test case. */
export enum ApiBaseItemAccessibility {
    Accessible = "Accessible",
    Deleted = "Deleted",
    NoPermissions = "NoPermissions",
    Archived = "Archived",
}

/** Contains the meta data of certain value set which is referenced somewhere (e.g. test step or test job). */
export interface ApiTestDataReferencedValueSetInfo {
    /** The GUID of the value set. */
    Guid: string | undefined;
    /** The name of the value set. Is null, when the
value set has been deleted. */
    Name: string | undefined;
    /** Indicates whether the value set has been deleted. */
    Deleted: boolean;
}

/** Contains information about created test step. */
export interface ApiAddSingleTestStepResponse {
    /** The id of the test step. */
    TestStepId: number;
}

/** Contains the metadata which is necessary for creating a new test case */
export interface ApiTestCaseCreateMeta extends ApiItemCreateMeta {
    /** If set, then 'Expected Results' field is mandatory when defining a test case.  */
    RequireExpectedResults: boolean;
}

/** Contains the metadata of fields of a test case being edited. */
export interface ApiTestCaseEditMeta extends ApiItemEditMeta {
    /** If set, then 'Expected Results' field is mandatory when defining a test case.  */
    RequireExpectedResults: boolean;
}

/** Contains information about updated value set (along with values). Variables ()number and names) must match existing test data. */
export interface ApiTestDataValueSetUpdate {
    /** The name of the value set. */
    ValueSetName: string | undefined;
    /** The variables contained in this value set together with their
values. */
    Variables: ApiTestDataVariableWithValue[] | undefined;
}

/** Contains the meta data of a certain variable in the test data. */
export interface ApiTestDataVariable {
    /** The variable name. */
    Name: string | undefined;
}

/** Represents a variable with its value in a certain value set. */
export interface ApiTestDataVariableWithValue extends ApiTestDataVariable {
    /** The value the variable has in the current value set. */
    Value: string | undefined;
}

/** Contains information about new value set (along with values) to be part of test data (of a test case). */
export interface ApiTestDataValueSetNew {
    /** The name of the value set. */
    ValueSetName: string | undefined;
    /** The variables contained in this value set together with their
values. */
    Variables: ApiTestDataVariableWithValue[] | undefined;
}

/** Contains the test data of test case. */
export interface ApiTestData {
    /** The value sets which are part of the test data. */
    ValueSets: ApiTestDataValueSetInfo[] | undefined;
    /** The variables which are part of the test data. */
    Variables: ApiTestDataVariable[] | undefined;
    /** The actual values contained in the test data. The table
is a two-dimensional array which contains for each value
set a list of values. The data is ordered according to
the ValueSets and Variables list. */
    Values: string[][] | undefined;
    /** The list of fields that can be used as replacement
placeholders in the TestCase */
    Fields: ApiFieldPlaceholder[] | undefined;
    Variant: string;
}

/** Contains the meta data of a certain value set in the test data. */
export interface ApiTestDataValueSetInfo {
    /** The GUID of the value set. */
    Guid: string | undefined;
    /** The name of the value set. */
    Name: string | undefined;
}

/** A placeholder field to be replaced with a value from the TestCase on test execution */
export interface ApiFieldPlaceholder {
    /** The placeholder text for this field */
    Placeholder: string | undefined;
    /** The field title for UI purposes */
    Title: string | undefined;
    /** The internal Id for the field. */
    FieldId: string | undefined;
    /** The type of the field. */
    FieldType: ApiFieldType;
}

/** Represents "local" test data (in a test case) i.e. owned by this test case. Such test data can be modified in scope of this test case. */
export interface ApiTestDataLocal extends ApiTestData {
    /** If not null, indicates whether this local test data is already referenced by other test cases. 
You need to provide 'IsReferenced' as an option to 'include' parameter in order to 
request initialization of this field.  */
    IsReferenced: boolean | undefined;
}

/** Represents "referenced" test data (in a test case) i.e. owned by another test case. Such test data cannot be modified in scope of current test case (please modify it in context of its owner test case) */
export interface ApiTestDataReferencedTestCase extends ApiTestData {
    /** Id of the referenced test case test data is shared from.  */
    ReferencedTestCaseId: number;
    /** Information about accessibility of the other test case (owner of referenced test data). */
    TestCaseAccessibility: ApiBaseItemAccessibility;
}

/** This model is used when generating a "preview" of test data i.e. request server to provide actual data for all formulas included in the data. */
export interface ApiTestDataPreview {
    /** Content of test data matrix. 
Outer array represent rows, inner arrays represent cells in the row.  */
    Values: string[][] | undefined;
}

/** A value set with its values. */
export interface ApiTestDataValueSet extends ApiTestDataValueSetInfo {
    /** The variables contained in this value set together with their
values. */
    Variables: ApiTestDataVariableWithValue[] | undefined;
}

/** The file format in which the test data should be exported. This enum has the following values:  - `CSV` CSV  - `XLS` The old Excel file format (97-2003)  - `XLSX` The new Excel file format (2007+)  - `XML` XML This enum has the following values:  - `CSV` CSV  - `XLS` The old Excel file format (97-2003)  - `XLSX` The new Excel file format (2007+)  - `XML` XML */
export enum ApiTestDataFileFormat {
    XLS = "XLS",
    XLSX = "XLSX",
    XML = "XML",
    CSV = "CSV",
}

/** Contains basic information information of a test execution. Especially, the step executions are not included here. */
export interface ApiTestExecutionInfo {
    /** Id of the execution. */
    Id: number;
    /** The formatted id of the execution. */
    FormattedId: string | undefined;
    /** Guid of the execution. */
    Guid: string | undefined;
    /** Type of the execution. */
    TestExecutionType: ApiTestExecutionType;
    /** Id of the test case the execution is related to. */
    TestCaseId: number;
    /** Name of the test case the execution is related to. */
    TestCaseName: string | undefined;
    /** Formatted name of the test case the execution is related to. */
    TestCaseFormattedId: string | undefined;
    /** Last editor of this execution */
    LastEditor: ApiFieldValueUser | undefined;
    /** Tester assigned to the execution */
    Tester: ApiFieldValueUser | undefined;
    /** Date of the execution */
    ExecutionDate: ApiFieldValueDateTime | undefined;
    /** Date of last modification */
    LastModified: ApiFieldValueDateTime | undefined;
    /** Duration of the execution */
    ExecutionDuration: ApiFieldValueTimeSpan | undefined;
    /** Execution status - aggregated over all steps */
    Status: ApiTestExecutionStatus;
    /** Name of the value set used (or none) */
    ValueSetName: string | undefined;
    /** Version */
    Version: number;
    /** Tested version */
    TestedVersion: string | undefined;
    /** User who marked the execution as irrelevant (if any) */
    IrrelevantFlaggedBy: ApiFieldValueUser | undefined;
    /** Date when execution has been marked as irrelevant (if was) */
    IrrelevantFlaggedAt: ApiFieldValueDateTime | undefined;
    /** Reason why execution has been marked as irrelevant (if was) */
    IrrelevantReason: string | undefined;
    /** True if execution has been marked as irrelevent.  */
    Irrelevant: boolean;
    /** Agents selected for this execution. Can be a pool (especially if execution consists of mixuture of different steps)  */
    AgentToUse: string | undefined;
    /** True if execution is finalized.  */
    IsFinalized: boolean;
    /** True if execution has any attachments.  */
    HasAttachment: boolean;
    /** True if execution has any defetcs related.  */
    HasDefect: boolean;
    /** Contains information specific for the execution in scope
of a test scenario. Can be null, if the execution was not in scope of a test scenario. */
    TestScenarioInfo: ApiTestExecutionTestScenarioInfo | undefined;
    /** Contains labels attached to this execution */
    AttachedLabels: ApiLabelAttached[] | undefined;
    /** Contains the custom fields of this execution */
    CustomFields: ApiFieldWithValue[] | undefined;
    HistoryTestCase: ApiItem | undefined;
}

/** Identifies the type of an execution. This enum has the following values:  - `Automated` Represents automated execution.  - `Manual` Represents manual execution. */
export enum ApiTestExecutionType {
    Manual = "Manual",
    Automated = "Automated",
}

/** Identifies the status of an execution. This enum has the following values:  - `Aborted` Execution has been aborted.  - `Blocked` At least one executed step was blocked, and there were no failures (only considered for manual tests)  - `Failed` At least one executed step marked as failed.  - `Incomplete` Some steps executed, but at least one step was not executed (and no failures or blocked yet).  - `InProgress` Execution is in progress.  - `NotApplicable` All steps were not applicable to the execution  - `NotRun` No steps executed yet.  - `Pass` All steps executed and passed.  - `Queued` The step is queued for automated execution.  - `Waiting` An execution was started and a step is waiting for pickup by agent */
export enum ApiTestExecutionStatus {
    NotRun = "NotRun",
    Incomplete = "Incomplete",
    Failed = "Failed",
    Pass = "Pass",
    Queued = "Queued",
    InProgress = "InProgress",
    Aborted = "Aborted",
    Blocked = "Blocked",
    Waiting = "Waiting",
    NotApplicable = "NotApplicable",
}

/** Contains information specific for the execution in scope of a test scenario. */
export interface ApiTestExecutionTestScenarioInfo {
    /** The index of this execution in the test scenario
execution. The index does not need to be consecutive as partial
execution of a test scenario is allowed. */
    Index: number;
    /** The run dependencies for this execution. */
    RunDependency: ApiRunDependencyEntry[] | undefined;
    /** The id of the test scenario in scope of which this execution
is performed. */
    TestScenarioId: number;
    /** If of the related test scenario execution. */
    TestScenarioExecutionId: number;
    /** The id of the test job to which this execution belongs. */
    TestJobId: number;
    /** Aggregated status of all test executions. */
    ExecutionStatistics: ApiTestScenarioExecutionStatistics | undefined;
}

export interface ApiRunDependencyEntry {
    /** Dependecy on run index. */
    RunIndex: number;
    /** Describes if true this is a hard dependency otherwise this is a soft dependecy. */
    OnSuccessOnly: boolean;
}

export interface ApiTestScenarioExecutionStatistics {
    NotRun: number;
    Incomplete: number;
    Failed: number;
    Pass: number;
    Queued: number;
    InProgress: number;
    Aborted: number;
    Blocked: number;
    Waiting: number;
    NotApplicable: number;
}

export interface ApiLabelAttached {
    /** Id of attached label. Does not reference to global label. */
    Id: number;
    /** Name of label. */
    Name: string | undefined;
    /** Description of label. */
    Description: string | undefined;
    /** Reference to another attached label. */
    ParentId: number | undefined;
}

/** Contains a paginated result. */
export interface ApiPaginatedResultOfApiTestExecutionInfo {
    /** The number of items which were skipped in the list of results.
This value is provided during the request. */
    StartAt: number;
    /** The maximum number of items which should be included in the result.
This value is provided during the request. */
    MaxResults: number;
    /** The overall number of items which are available. When using pagination,
this number is higher than the number of items which are included in the result. */
    Count: number;
    /** The actual items included in this response. */
    Items: ApiTestExecutionInfo[] | undefined;
}

/** Represents the test case execution preview response, containing a testexecution preview and further information. */
export interface ApiTestCaseExecutionPreviewResponse {
    /** Testexecution preview. */
    NewTestExecution: ApiTestExecutionNew;
    /** If true, then 'Actual Results' field is mandatory when manually executing.  */
    RequireActualResult: boolean;
    /** If granted, execution can be finalized due to permission */
    CanFinalizeTestExecution: ApiPermissionResult;
    /** Contains metadata which is necessary for creating new executions. */
    CreateMeta: ApiTestExecutionCreateMeta;
}

/** A new test execution to be saved. */
export interface ApiTestExecutionNew {
    /** A GUID which uniquely identifies the test
execution.The GUID can be null. If a GUID
is provided, it will be kept. */
    Guid: string | undefined;
    /** The id of the test case to which this execution belongs. */
    TestCaseId: number;
    /** The name of the executed test case when the execution
has been started. The name can be defined freely. */
    TestCaseName: string | undefined;
    /** Indicates whether the execution should be finalized. Finalized executions
cannot be modified any further. */
    Finalize: boolean;
    /** The name of the value set which was chosen for this
execution. The value set name can be chosen freely
here and is not validated against the value sets defined
in the test case. */
    ValueSetName: string | undefined;
    /** Contains information specific for the execution in scope
of a test scenario. Can be null, if the execution should
not happen in scope of a test scenario. */
    TestScenarioInfo: ApiTestExecutionNewTestScenarioInfo | undefined;
    /** Contains the steps of this execution. */
    Steps: ApiTestStepExecutionNew[] | undefined;
    /** The tested version. */
    TestedVersion: string | undefined;
    /** The duration of the execution. Can be set freely. Might be
measured by the client */
    ExecutionDuration: ApiFieldValueTimeSpan | undefined;
    /** Contains labels attached to this execution */
    AttachedLabels: ApiLabelAttached[] | undefined;
    /** The values which should be set for the custom fields */
    CustomFields: ApiFieldUpdate[] | undefined;
    /** Contains the attachments. */
    Attachments: ApiAttachmentNew[] | undefined;
}

/** Contains information specific for the execution in scope of a test scenario. */
export interface ApiTestExecutionNewTestScenarioInfo {
    /** The index of this execution in the test scenario
execution. The index does not need to be consecutive as partial
execution of a test scenario is allowed. */
    Index: number;
    /** The run dependencies for this execution. The run dependencies
can be defined freely here but are enforced afterwards by the UI
when updating the execution. */
    RunDependency: ApiRunDependencyEntry[] | undefined;
    /** The id of the test scenario in scope of which this execution
is performed. */
    TestScenarioId: number;
    /** The id of the test job to which this execution belongs. This id is optional
and ids which do not exist anymore will be silently dropped. A valid id needs
to be provided when the last execution information for a test job should be
updated. */
    TestJobId: number | undefined;
}

/** A new test step execution to be saved. */
export interface ApiTestStepExecutionNew {
    /** The one-based index of this test step in the list
of test steps. */
    Index: number;
    /** The name of this test step. */
    Name: string | undefined;
    /** The step type of this test step execution. */
    StepType: ApiTestStepExecutionStepType;
    /** The execution status of this test step execution. */
    Status: ApiTestStepExecutionUpdateStatus;
    /** The description of this test step. */
    Description: ApiRichText | undefined;
    /** The expected result of the execution of this test step. */
    ExpectedResults: ApiRichText | undefined;
    /** The actual result of the execution of this test step. */
    ActualResults: ApiRichText | undefined;
    /** The user who last modified the actual results field
or null if not modified outside the first test execution */
    ActualResultsLastUpdatedBy: ApiUserInfo | undefined;
    /** The time when the Actual Result was updated */
    ActualResultsLastUpdated: Date;
}

/** The possible step types for a test step execution. NestedTestCase is intentionally not included as test execution are flat. Test steps of a nested test case are merged into the flat test execution. This enum has the following values:  - `Condition` The step represents a condition.  - `Step` The step is a normal test step. */
export enum ApiTestStepExecutionStepType {
    Condition = "Condition",
    Step = "Step",
}

/** The list of statuses a test step execution can be set to when updating it. This enum has the following values:  - `Blocked` The execution of the step is blocked.  - `Failed` The execution of the step has failed.             - `NotApplicable` Step is not applicable for the current test execution, not considered for overall execution status.  - `NotRun` The step has not been executed yet.  - `Pass` The step has been executed successfully. */
export enum ApiTestStepExecutionUpdateStatus {
    NotRun = "NotRun",
    Pass = "Pass",
    Failed = "Failed",
    Blocked = "Blocked",
    NotApplicable = "NotApplicable",
}

/** Contains the metadata which is necessary for creating a new execution. */
export interface ApiTestExecutionCreateMeta {
    /** Contains all available fields together with their metadata. */
    Fields: ApiField[];
    /** Contains information about fields layout (i.e. how to layout fields in the edit mask). */
    EditLayout: ApiEditLayout;
}

/** Represents the test case execution preview request. */
export interface ApiTestCaseExecutionPreviewRequest {
    /** Tested version, is only used if test job tested version is not set. */
    TestedVersion: string | undefined;
    /** The guid of the value set. */
    ValueSetGuid: string | undefined;
    /** Contains labels that will be used for the test jobs created by this preview.
On creation of a test execution those labels are copied over as ApiLabelAttached.
Version is not checked and can be null. */
    Labels: ApiLabelInfo[] | undefined;
    /** Contains the custom fields of this execution */
    CustomFields: ApiFieldUpdate[] | undefined;
}

/** This enum determinates wich information should be included in the richtext. This enum has the following values:  - `All` All, this means Html and plain text are included.  - `HTML` Html is included.  - `PlainText` Plain text is included. */
export enum ApiRichTextIncludeType {
    HTML = "HTML",
    PlainText = "PlainText",
    All = "All",
}

export interface ApiAutomatedTestCaseExecution {
    /** Contains the id of the value set key. */
    ValueSetKey: string | undefined;
    /** Contains the information about the test version. */
    TestedVersion: string | undefined;
    /** Contains the id of the agent. */
    AgentId: number;
    /** Contains labels that will be used for the test jobs created by this preview.
On creation of a test execution those labels are copied over as ApiLabelAttached.
Version is not checked and can be null. */
    Labels: ApiLabelAttached[] | undefined;
    /** The values which should be set for the custom fields. */
    CustomFields: ApiFieldUpdate[] | undefined;
}

/** ONLT FOR INTERNAL USE Contains basic information about a item as requested from external system (e.g. JIRA plugin) using search by related external item id (e.g. JIRA Id). Please note that in case when current user has no access to view the item, only the Id field is properly filled. */
export interface ApiExternalInfo {
    /** The id of the item. */
    Id: number;
    /** The id of the project where test case is located.
If 0 then item is not accessible for current user.  */
    ProjectId: number;
    /** The id of the folder where item is located (or 0 if in root folder). */
    FolderId: number;
    /** The name of the item. */
    Name: string | undefined;
    /** The date when item was created. */
    DateCreated: ApiFieldValueDateTime | undefined;
    /** The date when item was last modified. */
    LastModified: ApiFieldValueDateTime | undefined;
    /** The date when item was last time executed. */
    LastExecutionDate: ApiFieldValueDateTime | undefined;
}

/** Contains all changes which were done to a test case in one operation together with information on when and by whom the test case has been changed. When no changes of a given type occurred, the corresponding field in this response will be missing. */
export interface ApiHistoryEntryTestCase extends ApiHistoryEntry {
    /** The list of changes to the test steps of this test step. Only
adding or removing of test steps is recorded here. */
    TestSteps: ApiHistoryTestSteps | undefined;
    /** Changes to the test data (if any). 
So far only the fact of modification of test data is recorded here 
(no further details/differences) */
    TestData: ApiHistoryTestData | undefined;
}

/** The list of changes to the test steps of a test case. */
export interface ApiHistoryTestSteps {
    /** True is any steps have been rearranged (i.e. changed their positions).  */
    Rearranged: boolean;
    /** The list of test steps which were added. */
    Added: string[] | undefined;
    /** The list of test steps which were removed. */
    Removed: string[] | undefined;
    /** The list of test steps which were modified. */
    Modified: ApiHistoryTestStepModified[] | undefined;
}

/** Contains the changes made to an existing test step. So far, only the test step name and id are included. */
export interface ApiHistoryTestStepModified {
    /** The id of the test step. */
    Id: number;
    /** The name of the test step. */
    CurrentName: string | undefined;
    /** The list of changes to the fields */
    Fields: ApiHistoryFieldChanged[] | undefined;
    /** Contains the automation.
             */
    Automation: ApiHistoryAutomation | undefined;
}

/** Contains the automation changes. */
export interface ApiHistoryAutomation {
    /** Contains the added automation type.
             */
    Added: ApiAutomationTechnology | undefined;
    /** Contains the removed automation type. */
    Removed: ApiAutomationTechnology | undefined;
    /** Contains the changes to the automation files of this test step. */
    Modified: ApiHistoryAutomationModified | undefined;
}

/** The list of changes to the automation related files. */
export interface ApiHistoryAutomationModified {
    /** The list of names of the script files which were added. */
    ScriptFilesAdded: string[] | undefined;
    /** The list of the script changes. */
    ScriptFilesModified: ApiHistoryScriptFileModified[] | undefined;
    /** The list of names of the script files which were removed. */
    ScriptFilesRemoved: string[] | undefined;
    /** The list of names of the data files which were added. */
    DataFilesAdded: string[] | undefined;
    /** The list of names of the data files which were removed. */
    DataFilesRemoved: string[] | undefined;
}

/** Changes to the script. */
export interface ApiHistoryScriptFileModified {
    /** The name of the File, is empty if script is changed directly. */
    FileName: string | undefined;
    /** The old value before the change, is empty if file changed. */
    ValueBefore: string | undefined;
    /** The new value after the change, is empty if file changed. */
    ValueAfter: string | undefined;
}

/** Represents changes in test data */
export interface ApiHistoryTestData {
}

/** Contains an entry for each test case that has steps */
export interface ApiTestCasesHaveStepsResponse {
    /** The indication if the test case has steps. Any missing
Test Case Ids that were originally provided in the
input can be assumed to have no steps */
    TestCases: { [key: string]: boolean; } | undefined;
}

/** Contains the placeholder fields of a test case. */
export interface ApiFieldPlaceholders {
    /** The list of fields that can be used as replacement
placeholders in the TestCase */
    Fields: ApiFieldPlaceholder[] | undefined;
}

/** Represents the test execution continue response. */
export interface ApiTestExecutionContinueResponse {
    /** Testexecution list. */
    TestExecutions: ApiTestExecutionExtendedInfo[];
    /** If true, then 'Actual Results' field is mandatory when manually executing.  */
    RequireActualResult: boolean;
    /** If granted, execution can be finalized due to permission */
    CanFinalizeTestExecution: ApiPermissionResult;
    /** The location (project and folder) of the item */
    Location: ApiItemLocation | undefined;
}

/** Contains basic information of a test execution. This information was extended by steps and attachments. */
export interface ApiTestExecutionExtendedInfo extends ApiTestExecutionInfo {
    /** Contains execution steps. */
    Steps: ApiTestStepExecution[] | undefined;
    /** List of files attached to this execution. */
    AttachedFiles: ApiAttachmentInfo[] | undefined;
    /** Contains information about fields layout (i.e. how to layout fields in the edit mask). */
    EditLayout: ApiEditLayout | undefined;
}

/** Represents single step of a test execution (manual or automated). */
export interface ApiTestStepExecution {
    /** Id of this step execution */
    Id: number;
    /** Status of the step execution */
    Status: ApiTestStepExecutionStatus;
    /** Name of executed step  */
    Name: string | undefined;
    /** The index of this test step. The index does not need to be consecutive as partial
execution is allowed. */
    Index: number;
    /** Type of step  */
    StepType: ApiTestStepType;
    /** Step's description (instructions) */
    Description: ApiRichText | undefined;
    /** Expected results */
    ExpectedResults: ApiRichText | undefined;
    /** Actual results */
    ActualResults: ApiRichText | undefined;
    /** The user who last modified the actual results field
or null if not modified outside the first test execution */
    ActualResultsLastUpdatedBy: ApiUserInfo | undefined;
    /** The time when the Actual Result was updated */
    ActualResultsLastUpdated: Date;
    /** Agent used to execute this step (if any). 
Note: in case of JMeter automation it can happen (but this is very uncommon though) 
that more than one agent executes the step. In this case this field contains comma separated list of agents.   */
    AgentsUsed: string | undefined;
    /** Last user who edited this step execution.  */
    LastEditor: ApiFieldValueUser | undefined;
    /** Indicates whether a defect exists which is related to this test step. */
    HasDefect: boolean;
    /** The type of test automation technology which is used for this test step. */
    AutomationTechnology: ApiAutomationTechnology;
}

/** Identifies the status of a test step execution. This enum has the following values:  - `Aborted` Step has been aborted.  - `Blocked` Step has been blocked.  - `Failed` Step has failed.  - `InProgress` Is being executed by some agent.  - `NotApplicable` Step is not applicable for the current test execution, not considered for overall execution status.  - `NotRun` Step has not been run yet.  - `Pass` Step has passed.  - `Queued` Directly queued for execution, will be executed as soon as agent is able to process it. */
export enum ApiTestStepExecutionStatus {
    NotRun = "NotRun",
    Failed = "Failed",
    Pass = "Pass",
    Queued = "Queued",
    InProgress = "InProgress",
    Aborted = "Aborted",
    Blocked = "Blocked",
    NotApplicable = "NotApplicable",
}

/** Represents a test execution (manual or automated). */
export interface ApiTestExecution extends ApiTestExecutionExtendedInfo {
    /** The location (project and folder) of the test execution which is the location of the
corresponding test case. */
    Location: ApiItemLocation | undefined;
    /** Contains execution logs (only for automated executions) */
    ExecutionLogs: ApiTestExecutionLog[] | undefined;
    /** Contains execution data attributes (only for automated executions) */
    ExecutionDataAttributes: ApiTestExecutionDataAttribute[] | undefined;
    /** Contains permissions for test execution. */
    Permissions: ApiTestExecutionPermission | undefined;
    /** If true, then 'Actual Results' field is mandatory when manually executing. */
    RequireActualResult: boolean;
    /** Contains information about the edit status. */
    EditStatus: ApiEditableInfo | undefined;
}

/** Represents single log of an automated test execution. */
export interface ApiTestExecutionLog {
    Id: number;
    StepName: string | undefined;
    StepIndex: number;
    Message: string | undefined;
    DetailedMessage: string | undefined;
    OccurrenceTime: ApiFieldValueDateTime | undefined;
    Type: ApiExecutionLogMessageType;
    ScreenShotCheckSum: string | undefined;
    Category: string | undefined;
}

/** Identifies the type of log execution entry. This enum has the following values:  - `ExecutionError`  - `InformationalDebug`  - `InformationalInfo`  - `InformationalSuccess`  - `InformationalWarn`  - `PreparationError`  - `ScriptExecutionError`  - `SUTError` */
export enum ApiExecutionLogMessageType {
    SUTError = "SUTError",
    ScriptExecutionError = "ScriptExecutionError",
    PreparationError = "PreparationError",
    ExecutionError = "ExecutionError",
    InformationalInfo = "InformationalInfo",
    InformationalDebug = "InformationalDebug",
    InformationalWarn = "InformationalWarn",
    InformationalSuccess = "InformationalSuccess",
}

/** Represents a single "exection data attribute". */
export interface ApiTestExecutionDataAttribute {
    /** Id of the attribute  */
    Id: number;
    /** Name of the attribute  */
    AttrName: string | undefined;
    /** Value of the attribute (as string) */
    AttrValue: string | undefined;
    /** Type of the attribute */
    AttrType: ApiTestExecutionDataAttributeType;
    /** Id of the related ProcessElementExecution */
    ProcessElementExecutionId: number;
    /** Id of the related TestStepExecution */
    TestStepExecutionId: number;
    /** Id of the related TestJobExecution */
    TestJobExecutionId: number;
    /** Id of the related TestJobExecution */
    DateModified: ApiFieldValueDateTime | undefined;
    /** Name of the related automated step.  */
    StepName: string | undefined;
    /** Zero based index of related automated step execution.  */
    StepIndex: number;
}

/** Identifies the type of execution data attribute This enum has the following values:  - `Float`  - `Integer`  - `String` */
export enum ApiTestExecutionDataAttributeType {
    String = "String",
    Integer = "Integer",
    Float = "Float",
}

/** Represents permissions of an test execution. Intended to be subclassed by classes with more fine-grained permission set for given context. */
export interface ApiTestExecutionPermission {
    /** Indicates whether user is able to create defects. */
    CanCreate: ApiPermissionResult;
    /** Indicates whether user is able to create the item dependency.
In order to create a dependency between two different item types it is enough to have 'Create Dependency' permission for either of the linked items.
If the permission is denied check the other side as well. */
    CanCreateDependency: ApiPermissionResult;
    /** Indicates whether user is able to create execution log. */
    CanCreateExecutionLog: ApiPermissionResult;
}

/** Represents the response for creating new execution, the response depends on the execution context. */
export interface ApiTestExecutionNewResponse {
    Context: string;
}

/** Represents the response for creating new test case execution. */
export interface ApiTestExecutionNewResponseTestCaseContext extends ApiTestExecutionNewResponse {
    /** The test execution identifier. */
    TestExecutionIdentifier: ApiTestExecutionIdentifier | undefined;
}

export interface ApiTestExecutionIdentifier extends ApiItemIdentifier {
}

/** Represents the response for creating new test scenario execution. */
export interface ApiTestExecutionNewResponseTestScenarioContext extends ApiTestExecutionNewResponse {
    /** The id of the testscenario execution. */
    TestScenarioExecutionId: number;
    /** List of related test executions.  */
    TestExecutionIdentifiers: ApiTestExecutionIdentifier[] | undefined;
}

/** A test execution to be updated. */
export interface ApiTestExecutionUpdateSingle {
    /** Contains the attachments. */
    Attachments: ApiAttachments | undefined;
    /** Contains the steps of this execution. */
    Steps: ApiTestStepExecutionUpdate[] | undefined;
    /** Tested version */
    TestedVersion: string | undefined;
    /** Contains labels attached to this execution */
    AttachedLabels: ApiLabelAttached[] | undefined;
    /** Duration of the execution */
    ExecutionDuration: ApiFieldValueTimeSpan | undefined;
    /** The values which should be set for the custom fields */
    CustomFields: ApiFieldUpdate[] | undefined;
}

/** A test execution with id to be updated. */
export interface ApiTestExecutionUpdate extends ApiTestExecutionUpdateSingle {
    /** The id of the execution. */
    Id: number;
    /** Indicates whether the execution should be finalized. Finalized executions
cannot be modified any further. */
    Finalize: boolean;
    /** Indicates if this is a continuation of the test execution */
    IsContinuation: boolean;
}

/** A test step execution single step to be updated. */
export interface ApiTestStepExecutionUpdateSingleStep {
    /** The execution status of this test step execution. */
    Status: ApiTestStepExecutionUpdateStatus | undefined;
    /** The actual result of the execution of this test step. */
    ActualResults: ApiRichText | undefined;
}

/** A test step execution to be updated. */
export interface ApiTestStepExecutionUpdate extends ApiTestStepExecutionUpdateSingleStep {
    /** The id of the test step. */
    Id: number;
    /** The user who last modified the actual results field
or null if not modified outside the first test execution */
    ActualResultsLastUpdatedBy: ApiUserInfo | undefined;
    /** The time when the Actual Result was updated */
    ActualResultsLastUpdated: Date;
}

/** Contains the necessary information for creating a new execution log entry which was specified by an end user. */
export interface ApiTestExecutionLogUserEntryNew {
    /** The category of the log message. */
    Category: string;
    /** The message of the log message */
    Message: string;
    /** A more detailed message with additional information */
    DetailedMessage: string | undefined;
    /** The time when the logged event occurred. When no time is
provided, the current server time will be used. */
    OccurrenceTime: Date | undefined;
    /** The type of the log message */
    Type: ApiExecutionLogMessageType;
}

export interface ApiTestExecutionPatchResponse {
    /** The guid of long running task. */
    Guid: string | undefined;
    /** The current status of the request. */
    ModifyingStatus: ApiTestExecutionModifyingStatus;
}

/** Represents current modifying status of an test execution. This enum has the following values:  - `Executing`  - `Finished` */
export enum ApiTestExecutionModifyingStatus {
    Finished = "Finished",
    Executing = "Executing",
}

/** Represents the test execution patch request. */
export interface ApiTestExecutionPatchRequest {
    /** The list of test executions ids which will be modified. */
    TestExecutionsIds: number[] | undefined;
    PatchType: string;
}

/** Represent the test execution cancel request. */
export interface ApiTestExecutionPatchCancel extends ApiTestExecutionPatchRequest {
}

/** Represent the test execution mark irrelevant request. */
export interface ApiTestExecutionPatchMarkIrrelevant extends ApiTestExecutionPatchRequest {
    /** The reason for marking the test executions irrelevant. */
    IrrelevantReason: string | undefined;
}

/** Represent the test execution mark relevant request. */
export interface ApiTestExecutionPatchMarkRelevant extends ApiTestExecutionPatchRequest {
}

/** Represent the test execution finalize request. */
export interface ApiTestExecutionPatchFinalize extends ApiTestExecutionPatchRequest {
    /** When true, incomplete executions should be finalized as well.
Otherwise, incomplete executions will be skipped. */
    FinalizeIncomplete: boolean;
}

/** Represents necessary information for creating an test execution lock. */
export interface ApiTestExecutionCreateLock {
    /** The id of the test execution. */
    TestExecutionId: number;
    /** Contains lock information. */
    LockInfo: ApiLockNew | undefined;
}

export interface ApiBulkExecutionsRequest {
    /** The Id of the project containing the test cases */
    ProjectId: number;
    /** The Id of the folder containing the test cases.
This is used for a permission check to verify that the
user has permission to Finalize the test executions if needed */
    FolderId: number;
    /** The test case Id and the value set to use for each test case */
    TestCaseIds: number[] | undefined;
    /** The value set to use for each test case execution (Item1 is the
test case Id and Item2 is the value set GUID) */
    ValueSetGuids: ValueTupleOfIntegerAndString[] | undefined;
    /** Whether or not the test execution should be finalized */
    Finalize: boolean;
    /** The labels that should be added to the test executions */
    Labels: ApiLabelInfo[] | undefined;
    /** The version number to associate with the test executions */
    Version: string | undefined;
    /** The status for all the steps in each test execution */
    Status: ApiTestStepExecutionStatus;
    /** The actual result for all the steps in each test execution */
    ActualResult: ApiRichText | undefined;
}

export interface ValueTupleOfIntegerAndString {
    Item1: number;
    Item2: string | undefined;
}

export interface ApiTestScenario extends ApiItemWithDescription {
    /** True if test scenario has at least one test case.  */
    HasTestCases: boolean;
    /** Contains information about the last execution status. */
    LastExecutionStatus: ApiTestScenarioRunStatus;
    /** True if test scenario has at least one execution. */
    HasExecutions: boolean;
}

/** This enum has the following values:  - `Blocked` At least one test job is Blocked and there are no Failed tets jobs  - `Failed` At least one test job is Failed  - `NotCompleted` At least one test job is NotCompleted and there are no Blocked or Failed test jobs  - `NotRun` None of test jobs have been executed yet  - `Passed` All test jobs are Passed */
export enum ApiTestScenarioRunStatus {
    NotRun = "NotRun",
    NotCompleted = "NotCompleted",
    Failed = "Failed",
    Passed = "Passed",
    Blocked = "Blocked",
}

export interface ApiItemUpdateWithTestJobs extends ApiItemUpdateWithDescription {
    /** Contains all the modifications which should be applied to
the test jobs. */
    TestJobs: ApiTestJobsUpdate | undefined;
}

export interface ApiTestJobsUpdate {
    /** A list with the new test jobs which should be added. */
    Added: ApiTestJobNew[] | undefined;
    /** A list with test jobs which should be updated. */
    Modified: ApiTestJobUpdateWithId[] | undefined;
    /** A list with the ids of the test jobs which should be removed. */
    Removed: number[] | undefined;
}

export interface ApiTestJobUpdate {
    /** Index of the test job in test scenario. */
    IndexInTestScenario: number;
    /** The list of run dependencies of this test job. */
    RunDependency: ApiRunDependencyEntry[] | undefined;
    /** The details of the test job which should be updated.
Can be null, when the details should not be updated. */
    Details: ApiTestJobDetailsUpdate | undefined;
}

export interface ApiTestJobNew extends ApiTestJobUpdate {
    /** Test case id. */
    TestCaseId: number;
}

/** Contains the details of the test job which should be updated. */
export interface ApiTestJobDetailsUpdate {
    /** Id of the agent which should be used. Can be null. */
    AgentToUse: number | undefined;
    /** Guid of the value set guid which should be used.
Can be null but only if the test case is not
parameterized. */
    ValueSetGuid: string | undefined;
    /** The tested version. Can be null. */
    TestedVersion: string | undefined;
    /** Contains labels attached to this test job.
On creation of a test execution those labels are copied over as ApiLabelAttached.
Version is not checked and can be null. */
    Labels: ApiLabelInfo[] | undefined;
    /** Contains the updates which should be applied to the
execution custom fields of this test job. */
    CustomFields: ApiFieldUpdate[] | undefined;
    /** Contains the tester user id. */
    TesterId: number | undefined;
}

export interface ApiTestJobUpdateWithId extends ApiTestJobUpdate {
    /** Test job id. */
    Id: number;
}

export interface ApiItemNewWithTestJobs extends ApiItemNewWithDescription {
    /** A list with the new test jobs which should be added. */
    TestJobs: ApiTestJobNew[] | undefined;
}

/** Represents the test scenario execution preview response, containing a testexecution preview and further information. */
export interface ApiTestScenarioExecutionPreviewResponse {
    /** Testexecution preview list. */
    NewTestExecutions: ApiTestExecutionNew[];
    /** If true, then 'Actual Results' field is mandatory when manually executing.  */
    RequireActualResult: boolean;
    /** If granted, execution can be finalized due to permission */
    CanFinalizeTestExecution: ApiPermissionResult;
    /** Contains metadata which is necessary for creating new executions. */
    CreateMeta: ApiTestExecutionCreateMeta;
}

/** Represents the test scenario execution preview request. */
export interface ApiTestScenarioExecutionPreviewRequest {
    /** Tested version, is only used if test job tested version is not set. */
    TestedVersion: string | undefined;
    /** List of test job ids. */
    TestJobIds: number[] | undefined;
}

export interface ApiAutomatedTestScenarioExecutionResponse {
    /** Contains the id of the test scenario execution. */
    TestScenarioExecutionId: number;
    /** Contains the long running task guid. */
    LongRunningTaskGuid: string | undefined;
}

/** Base class for the different execution requests which can be used to start an automated execution of a test scenario. */
export interface ApiAutomatedTestScenarioExecutionRequest {
    /** The id of the agent which should be used as a fallback when
no agent is specified for a test job. */
    AgentId: number | undefined;
    /** If true test jobs will be executed sequentially. */
    Sequential: boolean;
    ExecutionType: string;
}

/** Encapsulates the request for complete execution of an automated test scenario. All test jobs which are contained in the test scenario will be executed. */
export interface ApiAutomatedTestScenarioExecutionRequestAll extends ApiAutomatedTestScenarioExecutionRequest {
}

/** Encapsulates the request for a partial execution of an automated test scenario. The ids of the test jobs which should be executed can be provided. */
export interface ApiAutomatedTestScenarioExecutionRequestPartial extends ApiAutomatedTestScenarioExecutionRequest {
    /** List of test job ids which should be executed. */
    TestJobIds: number[];
}

/** Contains all changes which were done to a test scenario in one operation together with information on when and by whom the test scenario has been changed. When no changes of a given type occurred, the corresponding field in this response will be missing. */
export interface ApiHistoryEntryTestScenario extends ApiHistoryEntry {
    /** The list of changes to the test jobs of this test scenario. Only
adding or removing of test jobs is recorded here. */
    TestJobs: ApiHistoryTestJobs | undefined;
}

/** The list of changes to the test jobs of a test scenario. */
export interface ApiHistoryTestJobs {
    /** The list of names of the test jobs which were added
to the test scenario. */
    Added: string[] | undefined;
    /** The list of names of the test jobs which were removed
from the test scenario. */
    Removed: string[] | undefined;
    /** True is any test jobs have been rearranged (i.e. changed their positions).  */
    Rearranged: boolean;
    /** The list of test jobs which were modified. */
    Modified: ApiHistoryTestJobModified[] | undefined;
}

/** Contains the changes made to an existing test job. */
export interface ApiHistoryTestJobModified {
    /** The id of the test job. */
    Id: number;
    /** Formatted id of the related test case . */
    TestCaseId: string | undefined;
    /** The list of changes to the fields */
    Fields: ApiHistoryFieldChanged[] | undefined;
}

/** Contains information about created test job. */
export interface ApiAddSingleTestJobResponse {
    /** The id of the created test job. */
    TestJobId: number;
}

/** Contains the test job information. */
export interface ApiTestJob {
    /** Id of the test job. */
    Id: number;
    /** Index of the test job in test scenario. */
    Index: number;
    /** Tested version id. */
    TestedVersion: string | undefined;
    /** Run dependencies as list with more information. */
    RunDependency: ApiRunDependencyEntry[] | undefined;
    /** Test case information. */
    TestCaseInfo: ApiTestCaseJobInfo | undefined;
    /** Agent wich will be used on execution. */
    AgentToUse: ApiAgentIdAndName | undefined;
    /** Selected value set wich will be used on execution. */
    SelectedValueSet: ApiTestDataReferencedValueSetInfo | undefined;
    /** Contains labels attached to this execution */
    Labels: ApiLabelReference[] | undefined;
    /** Contains information about the last test job execution. */
    LastExecutionInfo: ApiLastExecutionInfo | undefined;
    /** Contains history about the test job execution. */
    ExecutionHistory: ApiTestCaseExecutionHistory | undefined;
    /** Contains Information about the tester. */
    Tester: ApiFieldValueUser | undefined;
    /** Contains the execution custom fields for this test job */
    CustomFields: ApiFieldWithValue[] | undefined;
}

export interface ApiTestCaseJobInfo {
    /** The id of the test case */
    Id: number;
    /** The name of the test case */
    Name: string;
    /** Contains the information about accessbility of the test case. */
    TestCaseAccessibility: ApiBaseItemAccessibility;
    /** The last modification date of the test case. */
    LastModified: ApiFieldValueDateTime | undefined;
    /** Information about the support level of the automatic execution */
    SupportsAutomaticExecution: ApiAutomaticExecutionSupport;
    /** If set, then the test case contains test data. */
    HasVariables: boolean;
    /** Contains the information about required agent technologies for the test job execution. */
    RequiredAgentTechnologies: ApiAutomationTechnology[] | undefined;
}

/** Reference to a label. Contains minimal informations. Used for attaching labels to elements, retaining information about the global label and changing accordingly. */
export interface ApiLabelReference {
    /** Id of this label. */
    Id: number;
    /** Name of this label. */
    Name: string | undefined;
    /** Flag to indicate that this label has sub-labels. */
    IsSuperLabel: boolean;
}

/** Contains information about the last execution. */
export interface ApiLastExecutionInfo {
    /** The id of the last execution. */
    LastExecutionId: number | undefined;
    /** Contains the last test job execution status. */
    LastExecutionStatus: ApiTestCaseRunStatus;
    /** Contains the last test job execution status date. */
    LastExecutionDate: Date | undefined;
}

export interface ApiTestJobPreviewResponse {
    /** The list of not accessible test case ids. */
    NotAccessibleTestCases: number[] | undefined;
    /** The preview list of the test jobs. */
    TestJobPreview: ApiTestJobPreview[] | undefined;
}

/** Contains the test job preview information. */
export interface ApiTestJobPreview {
    /** The id of the project. */
    ProjectId: number;
    /** The id of the folder. */
    FolderId: number;
    /** The id of the test case. */
    TestCaseId: number;
    /** The name of the test case. */
    TestCaseName: string;
    /** Information about the support level of the automatic execution */
    SupportsAutomaticExecution: ApiAutomaticExecutionSupport;
    /** If set, then test case contains test data. */
    HasVariables: boolean;
    /** Contains the information about required agent technologies for the test job execution. */
    RequiredAgentTechnologies: ApiAutomationTechnology[] | undefined;
    /** A default value set which can be preselected in the UI. Will be null, when
the test case is not parameterized. */
    DefaultValueSet: ApiTestDataValueSetInfo | undefined;
}

/** The configuration of the item grid for a specific project and item type */
export interface ApiGridConfig {
    /** The id of the currently selected user view.
Can be null when no user view is selected */
    ActiveUserViewId: number | undefined;
    /** Indicates whether sub folder should be included */
    IncludeSubfolders: boolean;
    /** Indicates whether archieved items should be
included */
    IncludeArchivedItems: boolean;
    /** Indicates whether the filter row of the grid
is visible. */
    ShowFilterRow: boolean;
    /** The currently set filter */
    FilterExpression: any[] | undefined;
    /** indicates whether the filter is active */
    IsFilterActive: boolean;
    /** The list of visible columns */
    Columns: ApiGridConfigColumn[] | undefined;
    /** The list of columns for which the data is sorted
or grouped by */
    SortGroup: ApiGridConfigColumnSortGroup[] | undefined;
}

/** Information regarding a single column */
export interface ApiGridConfigColumn {
    /** The id of the field */
    FieldId: string | undefined;
    /** The width of the column */
    Width: number;
    /** Indicates whether the column's position is fixed
and to which side */
    FixedPosition: ApiGridConfigColumnFixedPosition;
}

/** The position to which a column is fixed in the grid */
export enum ApiGridConfigColumnFixedPosition {
    None = 0,
    Left = 1,
    Right = 2,
}

/** Information regarding the sorting/grouping of a single column */
export interface ApiGridConfigColumnSortGroup {
    /** The id of the field */
    FieldId: string | undefined;
    /** The direction in which the data is sorted */
    SortOrder: ApiGridConfigColumnSortOrder;
    /** Indicates whether this column is grouped */
    IsGrouped: boolean;
}

/** The direction in which the column is sorted */
export enum ApiGridConfigColumnSortOrder {
    Ascending = 0,
    Descending = 1,
}

/** Contains the folder notification active and Inheritable rule. */
export interface ApiFolderNotificationRuleResponse {
    /** Item type this rule is defined for. */
    ItemType: ApiItemType;
    /** The current active folder rule. */
    ActiveFolderRule: ApiFolderNotificationRule | undefined;
    /** The next inheritable rule (could be the same as the active rule if the active rule is project default). */
    NextInheritableRule: ApiFolderNotificationRule | undefined;
}

/** Contains the folder notification rule. */
export interface ApiFolderNotificationRule {
    /** The location of the notification. */
    NotificationLocation: ApiItemLocation | undefined;
    /** Creator user info. */
    CreatedByUser: ApiUserInfo | undefined;
    /** Owner user info. */
    Owner: ApiUserInfo | undefined;
    /** The id of the rule. */
    Id: number;
    /** The type of the filter. */
    FilterType: ApiNotificationRuleFilterType;
    /** Possible filter options only available if FilterType is Custom. */
    CustomFilterOptions: ApiNotificationRuleFilterOptions | undefined;
    /** Ignore if owner action. */
    IgnoreIfOwnerAction: boolean;
    /** Use this rule for all subfolders. */
    Recursive: boolean;
    /** Indicates if this rule is inherited. */
    Inherited: boolean;
    /** Indicates if this rule is inherited from project default. */
    InheritedFromProjectDefault: boolean;
}

/** Represents the folder notification rule request. */
export interface ApiFolderNotificationRulePatchRequest {
    /** Item type this rule is defined for. */
    ItemType: ApiItemType;
    /** The id of the folder. */
    FolderId: number;
    /** Use this rule for all subfolders, this means all subfolder rules will be deleted. */
    Recursive: boolean;
    /** Patch operation which will be applied. */
    Operation: ApiFolderNotificationRulePatchTypes;
    /** New folder notification rule. */
    Rule: ApiFolderNotificationRuleReplacement | undefined;
}

/** Represents the folder notification rules patch types. This enum has the following values:  - `UseInheritedNotificationRule` Use the inherited notification rule, if the recusrive flag is set all user rules will be deleted.  - `UseThisNotificationRule` Use this notification rule. */
export enum ApiFolderNotificationRulePatchTypes {
    UseInheritedNotificationRule = "UseInheritedNotificationRule",
    UseThisNotificationRule = "UseThisNotificationRule",
}

/** Represents a folder favourite. */
export interface ApiProjectFolderFavourite {
    /** Id of the record.  */
    Id: number;
    /** Location, which includes project & folder information.  */
    Location: ApiItemLocation | undefined;
    /** Custom label of this folder favorite.  */
    Label: string | undefined;
}

/** Represents a new folder favourite. */
export interface ApiProjectFolderFavouriteNew {
    /** Id of the project where the favorite is to be created */
    ProjectId: number;
    /** Id of the folder where the favorite is to refer to. 
May be zero, what indicates favorite of root folder (i.e. project level) */
    FolderId: number;
    /** Custom label of this folder favorite. Empty values (and nulls) are allowed.  */
    Label: string | undefined;
}

/** Represents data required to execute operation that modifies folder favourite.  There are multiple modify operations supported - see ApiProjectFolderFavouritePatchTypes. Depending on the type the actual properties can differ. See subclasses for details. */
export interface ApiProjectFolderFavouritePatch {
    PatchOperation: string;
}

/** Contains data required to perform operation that renames a given folder favorite. */
export interface ApiProjectFolderFavouritePatchRename extends ApiProjectFolderFavouritePatch {
    /** Custom label of the favorite. */
    Label: string | undefined;
}

/** The information used when updating the user */
export interface ApiUserPatchOperation {
    PatchOperation: string;
}

export interface ApiUserPatchPosition extends ApiUserPatchOperation {
    /** The position text to set */
    Position: string | undefined;
}

/** Identifies the type of the intial. This enum has the following values:  - `All` Two letters as initials will be returned.  - `Single` One letter as initial will be returned. */
export enum ApiIntialType {
    All = "All",
    Single = "Single",
}

/** Contains information about created user view. */
export interface ApiUserViewNewResponse {
    /** The id of the user view. */
    UserViewId: number;
}

/** Contains necessary information for the user view update. */
export interface ApiUserViewUpdate {
    /** The name of the view. */
    Name: string | undefined;
    /** The description of the view. */
    Description: string | undefined;
    /** The color of the view.
Allowed are only predefined colors, for more information see: [Get predefined colors](#operation/System_GetColors). */
    Color: string | undefined;
    /** Indicates whether the view is public or not. */
    IsPublic: boolean | undefined;
    /** Contains all data of the user view which depends on
the item type. */
    FieldsData: ApiUserViewUpdateFieldsData | undefined;
    /** List of ApiItemTypes for wich this user view is applicable. */
    ApplicableItemTypes: ApiItemType[] | undefined;
}

/** Contains necessary information to create a user view. */
export interface ApiUserViewNew extends ApiUserViewUpdate {
    /** The id of the project. */
    ProjectId: number;
}

/** Contains all changes of a user view which depend on the item type: filter, sorting/grouping and columns. */
export interface ApiUserViewUpdateFieldsData {
    /** The item type to which the filter, sorting/grouping and
column information applies. */
    ItemType: ApiItemType;
    /** The filter of the view. */
    Filter: ApiFilterUpdate | undefined;
    /** Contains the list of columns. */
    Columns: ApiUserViewColumnUpdate[] | undefined;
    /** Contains the list of sorting and grouping information for columns. */
    SortingGrouping: ApiUserViewColumnSortGroupUpdate[] | undefined;
}

export interface ApiUserViewColumnUpdate {
    /** The id of the field for which the column is
defined. */
    FieldId: string | undefined;
    /** The width of the column. The minimal width is 25px, if the set value is lower, the minimum width is automatically applied. */
    Width: number;
}

/** Specifies sorting and grouping for a single column. */
export interface ApiUserViewColumnSortGroupUpdate {
    /** The name of the column. */
    FieldId: string | undefined;
    /** The sort order of the column. */
    SortOrder: ApiColumnSortOrder;
    /** Indicates if the column is grouped. */
    IsGrouped: boolean;
}

/** Represents the sort orders. This enum has the following values:  - `Ascending` Sorts the columns in descending order.  - `Descending` Sorts the columns in descending order. */
export enum ApiColumnSortOrder {
    Ascending = "Ascending",
    Descending = "Descending",
}

/** Contains information about the user view. */
export interface ApiUserView extends ApiUserViewInfo {
    Filter: ApiFilter | undefined;
    /** Contains the list of sorting and grouping information for columns. */
    SortingGrouping: ApiUserViewColumnSortGroupInfo[] | undefined;
    /** Contains the list of columns. */
    Columns: ApiUserViewColumnInfo[] | undefined;
}

/** Contains the user view column sorting and grouping information. */
export interface ApiUserViewColumnSortGroupInfo {
    /** The name of the column. */
    FieldId: string | undefined;
    /** The label of the column. */
    Title: string | undefined;
    /** The sort order of the column. */
    SortOrder: ApiColumnSortOrder;
    /** Indicates if the column is grouped. */
    IsGrouped: boolean;
}

/** Represents the user view column information. */
export interface ApiUserViewColumnInfo {
    /** The name of the column. */
    FieldId: string | undefined;
    /** The label of the column. */
    Title: string | undefined;
    /** The width of the column. */
    Width: number;
}

/** Represent the response for the user view patch collection operation. */
export interface ApiUserViewPatchCollectionResponse {
}

/** Represents data required to execute userview-modify collection operation. There are multiple project modify operations supported - see ApiUserViewPatchCollectionTypes. Depending on the type the actual properties can differ. See subclasses for details. */
export interface ApiUserViewPatchCollectionOperation {
    PatchOperation: string;
}

/** Represent the necessary information to copy user view. */
export interface ApiUserViewPatchCopyCollectionOperation extends ApiUserViewPatchCollectionOperation {
    /** The id of the user view. */
    UserViewId: number;
    /** The id of the target project. */
    TargetProjectId: number;
    /** The new name for the user view, if empty the old name will be kept. */
    NewName: string | undefined;
}

/** Represents a workflow. */
export interface ApiWorkflow {
    /** A list of all workflow nodes. */
    Nodes: ApiWorkflowNodeModel[] | undefined;
    /** A list of all workflow transitions. */
    Actions: ApiWorkflowTransitionModel[] | undefined;
    /** Graph contains information about transition between 
nodes and the information where to draw the nodes. */
    Graph: ApiWorkflowGraphModel | undefined;
}

/** Represents a workflow node */
export interface ApiWorkflowNodeModel {
    /** node name. */
    Name: string | undefined;
    /** true if this node is intial node. */
    IsInitialNode: boolean;
}

/** Represents a workflow transition. */
export interface ApiWorkflowTransitionModel {
    /** Node from which you are changing. */
    NodeFrom: ApiWorkflowNodeModel | undefined;
    /** Node to which you want to switch. */
    NodeTo: ApiWorkflowNodeModel | undefined;
}

/** Represents a workflow graph. */
export interface ApiWorkflowGraphModel {
    /** List of nodes with coordinates. */
    Nodes: ApiWorkflowGraphNodeModel[] | undefined;
    /** List of transitions. */
    Transitions: ApiWorkflowGraphTransitionModel[] | undefined;
}

/** Represents a workflow graph node. */
export interface ApiWorkflowGraphNodeModel {
    /** node name. */
    Name: string | undefined;
    /** X coordinate to draw. */
    X: number;
    /** Y coordinate to draw. */
    Y: number;
}

/** Represents a workflow graph transition. */
export interface ApiWorkflowGraphTransitionModel {
    /** Node name from which you are changing. */
    NodeFrom: string | undefined;
    /** Node name to which you want to switch. */
    NodeTo: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}